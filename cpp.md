# REF

# English

* literal：字面量常量
* manipulator：操纵符
* comments：注释
* argument：实参
* parameter：形参
* specifier：说明符
* compound：复合
* triviality：平凡性
* escape character：转义字符
* punctation：标点
* unary：一元
* reinterpret：解释
* dangling：悬挂的
* handle：处理
* robust：健壮的、稳固的、强壮的
* marco：宏
* synthesis：合成，综合
* synthesized：合成的
* delegate：委托
* vex：使困惑；使烦恼；使恼怒
* aggregate：聚合
* off the ending：尾后
* off the beginning：首前
* adaptor：适配器
* mechanism：机制
* strategy：策略
* generic：泛型的
* unary：一元
* predict：谓词
* nested：嵌套的
* utility：通常指提供实用功能的工具或库
* polymorphism：多态
* instantiate：实例化；例示，举例说明；
* plural：复数
* directive：指示
* volatile：（计算机内存）易失的；易变的；易挥发的；易汽化的；
* collapse：折叠
* anonymous：匿名的
* discriminant：判别式
* invoke：调用

# C++ 基础

## 1. main函数

`main` 函数是 C++ 程序的入口。在大多数系统中，`main` 函数的返回值用来指示状态。返回 0 表示成功，非 0 的返回值的含义由系统定义，通常用来指出错误类型。在 Unix 系统中，可以通过`echo $?` 获得 `main` 函数的返回值。

非 `void` 类型的函数都要有一个返回值，`main` 函数除外，如果我们没有显示的 `return` 语句，编译器会隐式的插入一个返回 `0` 的 `return` 语句。

`main` 函数可以接受两个参数：`int main(int argc, char **argv);` 其中第二个参数 `argv` 是一个数组，它的元素是指向 C 风格字符串的指针；第一个参数表示数组的大小。

> `char **argv` 等价于 `char *argv[]` 
>
> `argv` 是一个数组，数组元素的类型是 `char *`

其中，`argv[0]` 用来保存程序的名字，用户输入从 `argv[1]` 开始。

## 2. `[*]`keyword

alignas

alignof

asm

export

register

typeid

volatile

## 3. C++的输入输出方式

严格来说，C++ 并未定义任何输入输出语句，取而代之，通过一个全面的标准库来提供 I/O 机制。`iostream` 库下的 `istream` 和 `ostream` 分别表示输入流和输出流。一个流就是一个字符序列，是从 I/O 设备读出或者写入 I/O 设备的。**术语“流”想要表达的是，随着时间的推移，字符是顺序生成或消耗的。**就像水流一样。I/O 标准库定义了 4 个 I/O 对象，分别是 `cin`，`cout`，`cerr`，`clog`。

> "流"就是"流动"，是物质从一处向另一处流动的过程，比如我们能感知到的水流。C++的流是指信息从外部输入设备（如键盘和磁盘）向计算机内部（即内存）输入和从内存向外部输出设备（如显示器和磁盘）输出的过程，这种输入输出过程被形象地比喻为"流"。
>
> 由于流的概念，`>>` 用于输入又称为提取运算符；`<<` 用于输出又称为插入运算符。
>
> 通常标准输入或标准输出设备显示器称为标准流；外存磁盘上文件的输入输出称为文件流；对于内存中指定的字符串存储空间称为字符串流。
>
> 那么流的内容通常是什么呢？
>
> 流里的基本单位是字节，所以又称为字节流。字节流可以是ASCII字符、二进制数据、图形图像、音频视频等信息。文件和字符串也可以看成是有序的字节流，又称为文件流和字符串流。

程序员在调式时添加打印语句。这类语句应该保证“一直”刷新流，例如使用操纵符 `endl`。否则，程序崩溃，输出可能还留在缓冲区中，从而误导源于程序崩溃位置的推断。

C++ 提供了很多操纵夫用来帮助 `operator<<` 和 `operator>>` 控制输入或输出。常用的有操纵符：[更多操纵符](https://zh.cppreference.com/w/cpp/io/manip)

* `endl`：输出 `\n` 并刷新缓冲区
* `flush`：刷新输出流
* `setw`：更改下个输入/输出字段的位宽
* `dec`，`hex`，`oct`：更改输入/输出的基数
* `fixed`：更改浮点 I/O 的格式

## 4. comments

`//` 右侧的所有内容都会被编译器忽略，包括额外的双斜线。多行注释会忽略 `/*` 之后的所以内容，直到下一个 `*/`。当我们使用多行注释并注释多行时，最好能够显示的指出被注释的程序行，例如用 `*` 标记：

``` c++
/* This is comments:
 * line1
 * line2
*/
```

## 5. 输入数量不定的元素

我们可以通过 `while(std::cin >> val)` 来读取数量不定的数据，当我们使用一个 `istream` 对象作为条件时，其效果是检测流的状态。当遇到文件结束符 `EOF`，或遇到一个无效的输入时（例如类型不匹配），`istream` 对象的状态会变为无效，处于无效状态的 `istream` 对象会使条件变为假。

> 但输入类型不匹配时，只是结束 while 循环，程序并不会报错。
>
> 值得注意的是，如果接受类型是 `int`，即使输入一个 `double` 也会结束 `while` 循环，只不过这个值会被转换为 `int` 然后进入这一轮的 `while` 循环，但如果我们输入一个 `string`，则不会进入函数体。

在 UNIX 系统中，我们可以通过 `CTRL+D` 输入文件结束符，在 Windows 系统中，是先输入 `CTRL+Z`，然后按 `Enter` 键。

## 6. byte& word

大多数计算机以 2 的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为 “字节（byte）”，存储的基本单元称为 “字（word）”，它通常由几个字节组成。

在 C++ 语言中，一个字节至少能容纳机器基本字符集中的字符。

计算机进行数据处理时，一次存取、加工和传送的数据长度称为 “字”。计算机的字长决定了其 CPU 一次操作处理数据的实际位数的多少，因此可见字长越大，其性能越优越。在 64 位计算机中，字长应位 64bit，这意味着 CPU 一次可以处理 64bit 的数据。

## 7. 字符类型

| 类型     | 含义        | 最小尺寸 |
| -------- | ----------- | -------- |
| wchar_t  | 宽字符      | 16bit    |
| char16_t | Unicode字符 | 16bit    |
| char32_t | Unicode字符 | 32bit    |

一个 `char` 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 `char` 的大小和一个机器字节一样。`wchar_t` 类型用于确保可以存放机器最大拓展字符集中的任意一个字符。类型 `char16_t` 和 `char32_t` 则为 Unicode 字符集服务（Unicode是用于表示所有自然语言中字符的标准）。

> 此外，C++ 语言规定一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个long 一样大。

与其他整数类型不同，字符型被分为了三种：char，unsigned char，signed char，即，类型 char 和类型 signed char 并不一样。尽管字符型有三种，但是字符的表现形式只有两种：有符号和无符号的。类型 char 实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

因此我们在编写代码时，应该避免依赖于 char 类型的有无符号，即，如果我们需要确保 char 类型是有符号的，应该使用 signed char；如果我们需要确保 char 类型是无符号的，应该使用 unsigned char。此时的 char 更像一个整形。（虽然char 类型本身就是最小的整形）。而平时我们直接使用 char 时，是把他作为一个字符类型看待，而字符没有正负之分。另外，C 标准中明确指出 `size_t` 是无符号的。最后，如何验证当前编译器下 char 是否有符号呢？

``` C++
template<typename T>
bool isSigned() {
    return T(-1) < (T)0;
}

int main()
{
    cout << isSigned<char>() << endl; //true
    cout << isSigned<signed char>() << endl; // true
    cout << isSigned<unsigned char>() << endl; // fasle
    return 0;
} 
// g++ (Ubuntu 13.2.0-23ubuntu4) 13.2.0
```

从经验上看，大多数编译器都是按照 signed char 来实现 char 的。

## 8. 类型转换过程中的精度丢失

为什么 int 转换为 float 会有精度损失？这是因为在表格化浮点数中，包含隐藏位，float 一共有 24 位尾数部分，但是 int 类型除去符号位有 31 位，显然 float 的尾数部分无法表示 31 位数据。因此当 int 的值大于 $2^{24}$ 或小于 -$2^{24}$ 时，转换为 float 会有精度的损失。

对于无符号数，如果我们传入的数超出范围，结果是取模后的余数；对于有符号数，如果我们传入的数超出范围，结果是未定义的。

## 9. literal

### 字面值类型

* **字面值类型**是指编译时就能得到结果的类型，具体包括算术类型、数组、enum、字符串、引用和指针。自定义类（字面值常量类除外）、IO类不属于该类型。
* 字面值类型的对象有严格的要求，字面值类型是那些具有常量表达式属性的对象的类型。例如：字面值常量是算术类型。
* 对于引用和指针，其限定比较严格。不是所有的指针都是常量表达式。只有那些在编译时就确定地址指向的指针才是常量表达式，引用同理。
* 因此`nullptr`、`NULL`、指向固定地址的指针是字面值类型。

通过使用字面值类型，C++ 提供了一种在编译期执行计算和优化的方式，从而提高程序的性能。

> nullptr 是指针字面量。
>
> 浮点型字面量的默认类型是 double。我们可以用科学计数法表示浮点数。

### 1. 整形字面量

整形字面值的具体类型由它的值和符号决定。默认情况下，十进制字面量的值是都是带符号数，八进制和十六进制字面量的值既可能是带符号的也可能是无符号的。十进制字面量的类型是 int、long 和 long long 中能容纳当前值中尺寸最小的那个。八进制和十六进制则是 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中尺寸最小的那个。如果一个整形字面量连与之关联的最大数据类型都放不下，将产生错误。

``` C++
#include <iostream>
#include <typeinfo>
#include <cxxabi.h>

using namespace std;

int main()
{
    auto x = 0x80000000; // INT_MAX+1 --> uint
    auto y = 2147483648; // INT_MAX+1 --> long long  
    
    int status;
    char* demangled1 = abi::__cxa_demangle(typeid(x).name(), 0, 0, &status);
    std::cout << (status == 0 ? demangled1 : typeid(x).name()) << std::endl;
    char* demangled2 = abi::__cxa_demangle(typeid(y).name(), 0, 0, &status);
    std::cout << (status == 0 ? demangled2 : typeid(y).name()) << std::endl;
    
    free(demangled1);
    free(demangled2);
     
    return 0;
} 
```

尽管整形字面量可以存储在带符号数据类型中，但严格来说，无论是十进制数还是二进制、八进制、十六进制数，他们的字面量值本身都默认被视为无符号数，这意味着对于 `0xffffffff` 来说，它不会被解释为 `-1`，而是会被解释为 `unsigned int` 类型的最大值。即使我们用形如 `-1` 或者 `-0x1` 的负十进制字面量，那个负号也并不在字面值之内，它的作用仅仅是对字面值取负值而已，这就会带来一个问题：

```` C++
auto x = -0x80000000;   
cout << x << endl; // 2147483648
````

在这里我们明明通过负号将 `0x80000000` 转化为负数，但打印出来的数确实正数，这是因为 `0x80000000` 作为整形字面量先被推导为 `unsigned int` 类型，然后在对其取负数，其结果仍是无符号数。

### 2. 字符串字面量

字符串字面量值的类型实际上是由常量字符构成的数组，只不过每个字符串要在结尾处添加一个空字符（`\0`），因此字符串字面值的实际长度要比它的内容多 1。另外，如果两个字符串字面值位置相邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。

``` C++
cout << "fuckyou,"
    "Fiona!" << endl; // fuckyou,Fiona!
string s = "hello,"
    "fiona!"; // hello,fiona!
cout << s << endl;
```

### 3. 前缀和后缀

最后，我们还可以通过前缀或者后缀来明确的指定字面值的类型：

（1）字符和字符串字面量：

| 前缀      | 类型     |
| --------- | -------- |
| u         | char16_t |
| U         | char32_t |
| L         | wchar_t  |
| u8(utf-8) | char     |

（2）整形字面量：

| 后缀  | 最小匹配类型 |
| ----- | ------------ |
| u/U   | unsigned     |
| l/L   | long         |
| ll/LL | long long    |

u 和 l 或 ll 可以结合，例如 ul，可以匹配 unsigned long 或 unsigned long long

（3）浮点型字面量：

| 后缀 | 类型        |
| ---- | ----------- |
| f/F  | float       |
| l/L  | long double |

## 10. variable

变量是一个具名的、可供程序操作的存储空间。C++ 中，每个变量都有其数据类型，数据类型决定了变量所占内存空间的大小和布局方式，即数据元素的内容（属性），还定义了这类数据上可以进行的运算（方法）。

一般来说，我们并不严格区分变量（variable）和对象（object），即变量和对象我们可以视为同一个概念，即有某种数据类型的内存空间。

## 11. initialize & assign

虽然有时初始化和赋值的形式相同，都用 `=` 完成，但它们的含义并不相同。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

## 12. 列表初始化丢失信息

如果我们使用列表初始化且初始值存在丢失信息的风险，编译器一般不会报错，而是给出警告：

``` c++
#include <iostream>
#include <cstring>
#include <string>

using namespace std;

int main()
{
    long double ld = 3.1415926;
    
    int a(ld), b = ld;
    cout << a << ' ' << b << endl;

    int c = {ld}, d = {ld};
    cout << c << ' ' << d << endl;

    return 0;
} 
```

编译器警告信息：

``` shell
main.cpp:13:14: warning: narrowing conversion of ‘ld’ from ‘long double’ to ‘int’ [-Wnarrowing]
   13 |     int c = {ld}, d = {ld};
      |              ^~
main.cpp:13:24: warning: narrowing conversion of ‘ld’ from ‘long double’ to ‘int’ [-Wnarrowing]
   13 |     int c = {ld}, d = {ld};
      |      
```

## 13. 内置类型默认初始化

函数体内的内置类型变量不会默认初始化，此时如果我们使用未初始化的变量会导致未定义的错误。因此建议初始化每一个内置类型的变量，虽然并非必须如何，但这是一种简单且可靠的做法。

## 14. 分离式编译

C++ 的分离式编译（separate compilation）是一种将程序的不同部分（通常是源文件）分开编译的技术。这种方法允许开发者在大型项目中更高效地组织代码，提高编译速度和模块化程度。

分离式编译的主要概念

1. **源文件与头文件**：
   * **源文件**（`.cpp` 文件）包含具体的实现代码。
   * **头文件**（`.h` 或 `.hpp` 文件）用于声明类、函数和变量的接口，通常包含函数原型、类定义和常量等。
2. **编译过程**：
   * 在分离式编译中，每个源文件被单独编译为目标文件（`.o` 或 `.obj` 文件），然后所有的目标文件链接成最终的可执行文件。
   * 这种方法允许你修改某个源文件而不必重新编译整个项目，只需重新编译受影响的源文件即可。

优势

1. **提高编译效率**：在修改某个源文件后，只需重新编译该文件及其依赖的文件然后与之前已经编译过的文件链接即可，而不必重新编译整个项目。
2. **代码组织**：将接口（头文件）与实现（源文件）分开，使得代码更易于管理和维护。
3. **模块化**：使得代码的复用和分布式开发更加容易。

注意事项

1. **包含保护**：在头文件中使用包含保护（如 `#ifndef` / `#define`）来防止重复包含，避免链接错误。
2. **依赖关系管理**：确保在修改源文件时，及时更新相关头文件，以保持代码的正确性。

## 15. 声明和定义的关系

为了允许把程序拆分为多个逻辑部分来编写，C++ 支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

为了支持分离式编译，C++ 语言将声明和定义区分开来。声明使得变量为程序所知，一个文件如果想使用别处定义的名字必须包含对那个名字的声明。而定义负责创建与名字关联的实体，为变量和函数提供具体实现并分配内存。

因此变量只能被定义一次，但可以被多次声明。

如果想声明一个变量而非定义它，就在变量名前面添加关键字 `extern`，而不要显示的初始化变量：

``` c++
extern double pi = 3.14;   // declaration and definition
extern int x;   // declaration
int y;  // declaration and definition
```

## 16. 下划线命名

下划线命名不能乱用：C++ 为标准库保留了一些名字，用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。

## 17. for namespace 

下面的代码将会导致意想不到的变量遮掩（shadowing）现象，而不会报错：

``` C++
int main()
{
    int i = 100;
    for(int i = 0; i < 10; i ++ )   
        cout << "scope: " << i << endl;
    cout << "global: " << i << endl;
    return 0;
} 
```

**外部 `i` 的作用域**：

* 在 `main` 函数的作用域中，`i` 被初始化为 `100`。这个 `i` 是外部 `main` 函数中的变量。

**局部 `i` 的作用域**：

* 在 `for` 循环中，`int i = 0;` 声明了一个新的局部变量 `i`，这个局部变量遮蔽了外部的 `i`。因此，在 `for` 循环的作用域内，`i` 指的是局部变量。

## 18. compound type

复合类型是指基于其他类型定义的类型，C++ 中的复合类型有：

* array
* struct
* class
* union
* enum
* pointer
* reference

在同一条定义语句中，虽然“基本数据类型”只有一个，但是声明符的形式可以不同。也就是说，一条定义语句可能定义出不同类型的变量，例如：

``` c++
int a = 4, *p = &a, &r = a;
```

其中`a`，`*p` 和 `&r` 都是声明符， `*` 和 `&` 称之为“类型修饰符”，它是声明符的一部分，而不是基本数据类型。其中 `*` 用来修饰 `p`，`p` 就是一个复合类型指针；`&` 用来修饰 `r`，`r` 就是一个复合类型引用。

有时候我们可能将类型修饰符紧跟在基本数据类型后来，容易产生误解，因此不要误认为下面的语句声明了两个 `int` 类型的指针：

``` C++
int* p1, p2; 
// p1's type a pointer to int 
// p2's type is int
```

因此更推荐将类型修饰符与标识符写在一起而不是与基本数据类型写在一起，避免不必要的误解。

## 19. reference

引用不是一个对象，它只是一个别名，对引用的操作就是对所引用对象的操作。由于引用没有实际内存地址，因此不能定义引用的引用，也不能定义指向引用的指针。当引用指向常量时，不可以修改被引用的对象。不可以让一个非常量引用指向一个常量对象。

引用的类型必须与其所引用对象的类型一致，即使由 int 到 long 的转换也不可以，但有两种特殊情况：

1. 在初始化指向常量的引用时允许使用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型。尤其，允许为一个常量引用绑定非常常量的对象、字面值，甚至是一个表达式。
2. 指向常量的引用可能引用一个非const对象。

对于第一种情况，其本质上就相当于通过类型转换创建了一个临时对象，然后将引用绑定到这个临时对象上。在 C++ 中，只想常量的引用可以指向临时对象，有以下几点原因：

1. **防止对象拷贝**： 常量引用可以绑定到临时对象的一个重要原因是为了避免拷贝开销。如果常量引用不能绑定临时对象，编译器可能不得不创建一个新的对象副本，这会增加不必要的开销。如果对象是一个`int`，可能开销很小，但如果对象是一个很大的类或结构体，创建新的对象副本就会带来较大的额外的内存开销和拷贝时间开销。允许常量引用绑定临时对象是一种优化手段，可以减少对象的拷贝。
2. **临时对象的生命周期延长**： 当临时对象被常量引用绑定时，C++ 语言规则会自动延长该临时对象的生命周期，使其在常量引用的作用域结束之前都不会被销毁。这意味着只要常量引用有效，临时对象就一直存在。
3. **常量性保证安全性**： 常量引用（`const`）的一个重要特点是它不能改变所绑定的对象的值，这在绑定临时对象时提供了一定的安全性。由于你无法修改临时对象，程序的行为是确定的，不会因为对临时对象的修改而引发不可预期的错误。

## 20. pointer

指针本身是一个对象，它有自己的内存地址。`void*` 是一种特殊的指针类型，可用于存放任意类型对象的地址。区分空指针和无效指针，空指针即指针为 `NULL`，无效指针是指指针既不为空，也不指向某个对象，例如指向已被释放空间的指针。

和引用一样，指针的类型也必须与其所指对象类型一致，但也有几种特殊情况：

1. `void*` 类型指针。
2. 指向常量的指针可以指向非常量对象。
3. 上行转换：子类指针可以安全的隐式转换为父类指针。

注意对于 `type *`，对其解引用获得的是 `type&` 而不是 `type`，即，指针解引用获得的是指针所指的对象。

## 21. 标识符解释规则

``` c++
int val = 16;
int *p = &val;
int *&r = p; // r是一个指向指针p的引用
```

在面对一条比较复杂的指针或引用的声明语句时，从右向左解释有助于弄清他的真实含义。这是因为离变量名最近的符号最变量的类型有最直接的影响。因此由于 `&` 最靠近 `r`，所以 `r` 首先是一个引用，其次他是一个 `int *` 类型的引用。

----

对于数组来说，想要理解数组声明的含义，最好的办法是从数组的名字开始按照由内而外的顺序阅读：

``` C++
int *ptrs[10];	// ptrs是一个含有10个整形指针的数组
int (*ptrs)[10] = &arr; // ptrs是一个指针，指向有10个整形元素的数组
int* (*ptrs)[10] = &arr; // ptrs是一个指针，指向有10个整形指针的数组
```

## 22. const的链接性

在 C++ 中，默认状态下，const 对象是内部连接的，仅在当前文件内有效。这一点与 C 不同，C 语言的 const 对象是外部链接的，可以在不同的源文件之间共享。如果我们希望 C++ 中的 const 对象可以在不同源文件之间共享，对于该 const 对象，不管是声明还是定义都添加 extern 关键字即可。

所以，为什么 C++ 要规定 const 对象为内部链接呢？

> 这是因为在编译阶段，编译器通常会对常量进行优化，即所谓的常量传播或者常量折叠，表现为将常量对象直接替换为该对象的值或者将常量表达式替换为计算结果。这样我们就不用在内存当中实际存储这些变量的值了，从而减少内存访问和计算开销。
>
> 而如果我们将 const 的链接性定义为外部链接，那么不同文件中的 const 变量则更容易产生链接后的命名冲突，因此编译器保守起见，不去进行常量优化。同理，当 `const` 变量在某些情况下具有外部链接属性（例如，使用 `extern`），编译器可能会认为这些变量在不同源文件中可能冲突，从而影响优化的决策。

总而言之，就是为了进行编译优化。

但这里有一个问题，我们之所以不去进行常量优化，是担心程序中可能存在命名冲突，也即链接错误。那么，既然在最终链接时发现了命名冲突，并导致链接错误，那么为什么编译器不能更激进一些，先尝试优化，最后如果有冲突再报错呢？也就是说，不管三七二十一，直接把常量全优化了，这样如果程序真的存在命名冲突，反正也是链接错误；如果不存在命名冲突，那就是成功的优化。横竖都是赢，何乐而不为呢？

> 这就要从编译器的优化原理来解释了：
>
> 1. **编译器优化的整体流程**
>
> 编译器的优化过程通常分为多个阶段，包括以下几个：
>
> * **前端阶段**：负责语法解析和类型检查，生成中间代码（如抽象语法树）。
> * **中间阶段**：进行各种优化，比如常量折叠、循环优化、代码内联等。
> * **后端阶段**：生成目标机器代码，并在最终的链接过程中合并多个翻译单元。
>
> **编译阶段和链接阶段是分开的**。在编译阶段，编译器通常只处理单个翻译单元（一个 `.cpp` 文件），它并不知道其他文件中的 `const` 变量定义。因此，如果编译器在编译阶段对 `const` 变量进行激进优化，比如将它们直接替换为常量值，它不知道是否在其他翻译单元中有同名但不同值的 `const` 变量存在。
>
> 2. **潜在的风险：编译阶段与链接阶段的分离**
>
> 当编译器决定在编译阶段优化某个 `const` 变量为其字面值时，它是基于翻译单元内部的知识做出的决定。如果链接阶段发现了命名冲突，虽然链接器会报错，但问题在于编译器已经进行了**前置优化**，并且这种优化依赖于假设该 `const` 变量在全局范围内是唯一且不冲突的。
>
> * **如果优化过早进行**（如在编译阶段将 `const` 变量替换为字面常量），编译器可能会丢失对原始变量地址的引用信息。如果链接器发现了同名的 `const` 变量，这种早期的优化可能已经破坏了代码的结构和行为。
> * 一旦发现命名冲突，优化可能已经让程序处于一种不可恢复的状态，因为原本的符号引用已经被替换成了常量，无法再简单恢复为符号引用。
>
> 3. **编译器的保守策略：避免不安全的优化**
>
> 为了保证程序的**正确性**和**可维护性**，编译器在遇到具有外部链接潜力的 `const` 变量时，往往采取保守策略，避免过早优化。特别是在链接前，编译器并不知道这些 `const` 变量是否会在其他翻译单元中出现重定义的情况。
>
> * **可预测性**：如果编译器不进行优化，它能保证程序在链接阶段不会由于变量冲突而产生意外的行为。
> * **安全性**：即使发生链接错误，程序的符号引用仍保持不变，不会由于过早替换为常量而丢失语义上的正确性。
>
> 4. **为什么编译器不更激进？**
>
> 从理论上来说，编译器可以尝试在编译阶段进行激进的优化，比如将所有的 `const` 变量都直接替换为它们的字面值，然后在链接阶段再去检测冲突。但是这种做法带来了几个问题：
>
> * **复杂性和成本**：一旦编译器进行了这种激进优化，后续再发现冲突时，恢复优化前的状态会非常困难，且增加了编译器实现的复杂性。
> * **潜在错误的隐蔽性**：如果编译器早期进行了错误的假设并进行了优化，后续的错误可能不会立刻暴露出来。优化本身可能会掩盖真正的问题，甚至让问题更难调试和修复。
>
> 5. **更安全的替代方案：内部链接**
>
> 在 C++ 中，默认情况下 `const` 变量是具有**内部链接**的，编译器通过这种设计策略规避了命名冲突的问题：
>
> * 每个翻译单元中的 `const` 变量是独立的，编译器可以**放心地优化**这些变量，而不必担心其他文件中定义了相同名称的 `const` 变量。
> * 这种设计允许编译器在编译阶段进行激进的优化，因为它确保了这些常量的唯一性和局部性，不会引发链接阶段的冲突。
>
> 6. **总结**
>
> 编译器采取保守的优化策略是为了避免在链接阶段引入不可预测的行为或破坏程序的结构。虽然在最终链接时会发现命名冲突并报错，但如果编译器在编译阶段就进行了激进优化，这种优化可能导致程序行为被破坏，甚至在报错之前已经无法恢复。
>
> 这种保守策略确保了编译器不会在编译时进行可能破坏程序行为的优化，即使它在链接阶段报错，程序的结构和引用仍然是安全的、可预测的。

总而言之，就是避免优化可能导致的对程序行为（语义）的破坏，进而掩盖问题甚至导致其他的问题。

## 23. The as-if rule

C++ 中的 **"as-if" 规则** 是指编译器可以对代码进行任何优化，只要优化后的程序行为与标准规定的行为没有区别。换句话说，编译器可以自由地进行各种优化，但前提是程序的**可观察行为**与未优化时完全一致。

"As-If" 规则的关键点：

1. **可观察行为**：
   * 可观察行为包括变量的值、函数调用、输出结果（例如打印到控制台或写入文件）等。
   * 编译器可以改变程序的输出、产生的副作用或执行顺序，只要这些变化不会被程序的可观察行为检测到。
2. **允许的优化**：
   * 编译器可以跳过、重排代码，甚至删除一些看似没用的操作，只要这些更改不会影响程序的最终输出或行为。例如：
     * **循环展开**：编译器可以将循环优化为更高效的指令。
     * **常量折叠**：编译器可以在编译时计算常量表达式，而不是在运行时计算。
     * **跳过未使用的变量**：如果某个变量未使用，编译器可以直接将其移除。
3. **本质**：
   * 编译器的这些优化不会违反 C++ 标准规定的行为，因为从外部观察来看，程序执行的结果与未优化的结果完全相同。

例子：

```
cpp复制代码int x = 10;
int y = 20;
int z = x + y;
std::cout << z << std::endl;
```

编译器可以直接将 `z` 计算为 `30` 并跳过 `x + y` 的实际计算，因为这不会影响程序的可观察行为，输出结果依然是 `30`。这就是 "as-if" 规则的典型例子。

总结

"as-if" 规则使编译器能够自由优化代码，提升程序性能，只要这些优化不改变程序的可观察行为。

## 24. top-level const

和引用不同，由于指针本身是一个对象，因此指针本身可以是一个常量，而指针所指的对象也可以是一个常量，为了区分这两个const，我们用 top-level const 表示指针本身是个常量，用 low-level const 表示指针所指对象是一个常量。

更一般的，顶层 const 可以表示任意的对象是常量，这一点对任何数据类型都适用，如算数类型、类、指针等。底层 const 则与指针和引用等符合类型的基本数据类型部分有关。

> 由于引用本身不是一个对象，因此指向引用的 const 都是底层 const。

当执行对象的拷贝（初始化/赋值）操作时，顶层 const 不影响，对于底层 const，非常量可以转换为常量，反之则不行。这很容易理解，我们不能将一个指向常量对象的指针拷贝到一个不是指向常量对象的指针，因为它可以修改所指向对象的值。

> 忽略顶层 const 意味着，对于 `const type val;` 你既可以传入一个 const 对象，也可以传入一个非 const 对象，这都是合法的。

## 25. constexpr和常量表达式

常量表达式是指**值不会改变**并且**在编译过程就能得到计算结果**的表达式。显然，字面量就属于常量表达式。

> 注意常量 != 常量表达式

一个对象（或表达式）是不是常量表达式由它的数据结构和初始值共同决定。例如对于一个 `int` 类型变量来说，它无论如何也不可能是一个常量表达式。另一方面，常量也未必就是一个常量表达式，因为常量的值可能在运行时才能获取到，例如它是一个函数的返回值。

因此说在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式。C++11 标准规定，允许将变量声明为 constexpr 类型以便编译器来验证变量的值是否是一个常量表达式。即，声明为 constexpr 的变量一定是一个常量，并且必须使用常量表达式初始化（可以在编译期求值）。

常量表达式的值需要在编译时就得到计算，因此对声明 constexpr 时用到的类型必须有所限制。这些类型必须是“字面值类型”。其中，算符类型，指针类型，引用类型，聚合类型，枚举类型和 constexpr 修饰的类型都是字面值类型。

> 对于那些需要动态管理内存的对象，他们肯定不是字面值类型，因为它们需要在运行时分配和销毁内存。

尽管指针和引用都能定义成 constexpr，但它们的初始值受到严格限制，即需要满足顶层 const 的定义，指针的初始值必须是存储在某个固定地址中的对象；引用虽然没有顶层 const 的概念，但引用所指向对象也必须是存储在某个固定地址中的对象，例如函数中的局部对象是不合法的，因为它们的地址是随机的。

> 注意 constexpr 的常量总是顶层 const。

## 26. triviality

在C++中，**平凡性（Triviality）** 是指一个类型的特殊性质，这个性质决定了该类型是否拥有默认的、无需编译器进行复杂生成和操作的构造函数、拷贝构造函数、移动构造函数、析构函数和赋值运算符。**平凡的类型**非常简单，允许编译器在内存中直接操作对象（例如，通过简单的内存拷贝构造新对象），而不需要调用特殊的函数。

一个类型的**平凡性**主要影响编译器的优化、对象的复制和销毁过程。C++ 标准定义了平凡的类型具有以下几个特征：

平凡类型的特征

1. **默认构造函数是平凡的**：
   * 类型没有用户定义的默认构造函数。也就是说，编译器生成的默认构造函数只进行简单的内存分配，并不执行任何复杂的初始化操作。
2. **拷贝构造函数是平凡的**：
   * 如果类没有用户定义的拷贝构造函数，并且所有基类和成员的拷贝构造函数也是平凡的，那么拷贝构造函数是平凡的。
3. **移动构造函数是平凡的**：
   * 同样，如果没有用户定义的移动构造函数，并且所有成员和基类的移动构造函数都是平凡的，那么移动构造函数也是平凡的。
4. **析构函数是平凡的**：
   * 类不能有用户定义的析构函数，且所有基类和成员的析构函数也必须是平凡的。
5. **赋值运算符是平凡的**：
   * 如果类没有用户定义的赋值运算符，并且所有基类和成员的赋值运算符都是平凡的，那么赋值运算符也是平凡的。

非平凡类型的特征

如果一个类型有以下情况之一，它就不是平凡的：

* 拥有用户定义的构造函数、析构函数、拷贝/移动构造函数或赋值运算符。
* 类型中包含非平凡的成员变量或继承了非平凡的基类。
* 类型包含指针或使用动态内存分配。

平凡类型的意义

* **内存操作效率**：平凡类型的对象可以通过 `memcpy` 等直接操作内存进行拷贝，因为它们的构造函数和析构函数不需要复杂的操作。
* **编译器优化**：编译器可以在某些情况下对平凡类型进行更好的优化，因为它们没有复杂的构造或析构逻辑。

示例

```C++
struct TrivialType {
    int a;
    int b;
}; // 这是一个平凡类型

struct NonTrivialType {
    int a;
    int b;
    NonTrivialType() { a = 0; b = 0; } // 用户定义的构造函数，非平凡
};
```

在上面的例子中：

* `TrivialType` 是平凡的类型，因为它没有用户定义的构造函数、析构函数、或其他非平凡的操作。
* `NonTrivialType` 是非平凡类型，因为它有一个用户定义的构造函数。

平凡类型与字面值类型的关系

平凡类型和字面值类型（*literal type*）有相似之处，但它们不是完全相同的概念。字面值类型要求类型必须能在编译期进行常量表达式求值，而平凡性更关注对象的构造、析构和拷贝的复杂度。

因此说下面的 node 是平凡的，尽管它的成员函数 `f()` 中有动态内存管理的操作：

``` c++
struct node {
    int a;
    void f() {
        int *p = new int(4);
        delete p;
    }
};

int main()
{
    cout<<boolalpha<<is_trivial<node>::value<<endl;
    constexpr node a = node();
    return 0;
} 
```

## 27. typedef 陷阱

如果某个类型别名代指的是复合类型，那么把它用到声明语句里就会产生意想不到的效果：

``` c++
int a = 20;
int b = 30;

int main()
{
    typedef int *pint;
    const pint p1 = &a;
    const int* p2 = &a;
    return 0;
} 
```

在上面的例子当中，虽然从形式上看，`int *` 是对 `pint` 的替换，但在 `const`  的修饰下，`p1` 和 `p2` 的含义完全不同。对于 `p1`，`const` 修饰的是 `pint`，而 `pint` 是指向 `int` 类型的指针，因此 `const` 修饰的是指针， `p1` 是一个指向 `int` 类型的常量指针。对于 `p2`，`const` 修饰的是 `int`，因此 `p2` 是一个指向 `const int` 类型的普通指针。

## 28. auto

`auto` 一般会忽略顶层 `const`，保留底层 `const`。

对于引用类型，编译器以引用对象的类型作为 `auto` 的类型。

## 29. decltype

decltype 是第二类类型指示符，编译器并不实际调用 declytpe 指示的函数，而是使用当调用发生时函数的返回值的类型作为 decltype 的结果。

不同于 auto，decltype 会保留表达式的引用和顶层 const 属性。

特别的，如果表达式是一个变量（左值），那么变量名加上一对括号与不加时会有不同。如果 decltype 的表达式是加上了括号的变量，结果将是引用。这主要是为了方便允许开发者在需要引用类型时轻松使用。并且括号的存在并不会改变表达式的本质特性，即 `(a)` 依然是一个左值，`((a+b))` 依然是一个右值。

另外下面还有一些返回引用的例子：

* 对指针解引用
* 赋值表达式



## 30. 类定义后的分号

之所以要在 class 或 struct 的定义后面写一个分号，是因为类体后面可以紧跟变量名以表示对该类型对象的定义。但并不建议这样做，因为这混淆了对类的定义和对于类对象的定义，把两种不同实体的定义杂糅在了一条语句中。

## 31. 不能使用圆括号初始化类内数据成员

这是因为如果使用圆括号初始化成员变量会导致语法歧义，可能被解析为函数成员，而不是成员初始化。因此 C++ 不允许在类定义中使用圆括号来初始化成员变量。

## 32. 头文件不应包含using声明

如果头文件里有某个 using 声明，那么每个使用了该头文件的文件就有有这个声明。对于某些程序来说，在不经意间包含了一些名字，反而可能产生始料未及的命名冲突。

## 33. signed和unsigned混用

一般容器的 `size()` 返回的都是一个 `size_type` 类型的无符号数，因此如果我们使用 `size()`，就不要再使用 `int` 了，从而避免可能的有无符号数的混用问题。

## 34. string

如果我们希望初始化一个空 string 对象，直接 `string s;` 即可，无需 `string s("");`，因此 string 会调用默认构造函数。

使用标准读入读取 string 对象时，会忽略输入前后的空格。当使用 getline 读取 string 时，不会忽略输入前后的空格，最后的换行符读取后会被丢弃。

对 string 执行加法运算时，需要确保加号两侧至少有一个 string 对象，这是因为 C++ 语言中的字符串字面值并不是标准库类型 string 的对象。

> 之所以这样出了历史原因之外，也是为了与 C 兼容，因为 C++ 的 string 是动态内存管理，而字符串字面量是静态内存管理。如果 C++ 要实现字符串字面量是 string 对象这一操作，就要改变字符串字面量的内存管理方式，以适配 string，但这样就与 C 中的字符串字面量不是同一个概念了。

## 35. 下标越界

C++ 标准并不要求标准库检测下标是否合法，也就是说当我们的下标不合法时，C++ 并不会报错。但一旦使用了一个超出范围的下标，就会产生不可预知的后果。

当我们通过一个越界的索引访问容器内容时，可能导致缓冲区溢出（buffer overflow）。

## 36. const容器

以 `vector` 为例，如果我们声明了一个 `const vector<T> v;`。那么这个向量的内容是不可修改的，这意味着你不能调用 `push_back`，`pop_back`，`resize` 等改变向量大小和内容的方法。而之所以不能调用这些方法，是因为此时 `this` 指针的类型会被推导为 `const T*`，这意味着我们无法通过 `this` 指针在成员函数中修改对象任何的数据成员，并且也无法调用非 `const` 属性的成员函数。

再看下面的代码：

``` c++
const vector<int> a{1, 2, 3};
for(auto &x : a) {
    cout << x << ' ';
    x = 1024; // ???
}
```

代码中对 `x` 的修改是不合法的，因为此时 `x` 被推导为 `const int&`，这是因为当我们通过范围 `for` 循环遍历容器时，相同于通过迭代器来遍历容器。

> 在范围 `for` 循环内部，编译器会为容器创建一个迭代器，并在每次迭代时使用迭代器访问容器元素。

而当容器类型是 `const` 时，迭代器的类型是 `const_iterator` 而不是 `iterator`，上面的代码相当于：

``` c++
const vector<int> a{1, 2, 3};
for(vector<int>::const_iterator it = a.begin(); it != a.end(); ++ it) {
    cout << *it << ' ';
}
```

## 37. vector

`vector` 不是一个类型。要注意，`vector` 只是一个模板，它并不是一个类型，由 `vector` 生成的类型必须包含 `vector` 中元素的类型，例如 `vector<vector<int>>`。

当使用花括号对 `vector` 进行列表初始化时，会优先将花括号里的内容解释为容器的初始值列表，只有列表初始化无法进行时，才会考虑其他初始化方法。例如：

``` C++
vector<string> s{10}; 
cout << s.size() << endl;   // 10
vector<string> s2{"hello", "world!"};
cout << s2.size() << endl;  // 2
```

C++ 标准要求 `vector` 应该能在运行时高效快速的添加元素。因此既然 `vector` 对象能高效的增长，那么在定义 `vector` 对象的时候设定其大小也就没什么必要了，事实上这么做性能可能更差。只有一种情况例外，那就是所有元素的值都一样。但在某些情况下，如果已知大约要添加元素的数量，并且元素数量很大，可以通过 `reserve` 预留空间以提高性能，因为 `vector` 的动态扩容可能需要拷贝数组元素，另外频繁的分配和释放可能导致内存碎片化进而影响程序的整体性能。

一个容易忽略的点就是，如果容器内元素支持比较运算，那么 `vector` 也是支持比较运算的。其运算规则和 `string` 相似。

## 38. iterator

使用迭代器进行 `for` 循环时，通过 `==` 或 `!=` 来判断循环是否结束比 `<` 更推荐，因为不是所有的容器都有 `<` 运算符，只有支持下标运算的容器才重载了 `<`，但是所有的容器都支持 `==` 和 `!=`。

通过 `begin` 和 `end` 获取迭代器时，如果容器类型不是常量，返回的是 `iterator`；如果容器类型是常量，则返回的是常量迭代器 `const_iterator`，通过该迭代器遍历元素只能读不能写。但有时，我们只希望获得常量迭代器，则可以通过 `cbegin` 和 `cend` 实现。

## 39. array

所谓数组的维度，是指数组中元素的个数，即对于 `a[d]` 来说，`d` 就是数组的维度。在编译的时候数组的维度就因该是已知的，也就是说数组的维度必须是一个常量表达式。

严格来说，C++ 没有多维数组，通常所说的多维数组，其实就是数组元素为数组的数组。对于多维数组的初始化，有两种初始化方式：

1. 有内嵌花括号的初始化

``` c++
int a[3][3] = {
    {1},	// 第一维剩余部分默认初始化
    {2},	// 第二维剩余部分默认初始化
        	// 第三维默认初始化
};
/*
1 0 0 
2 0 0 
0 0 0 */
```

2. 没有内嵌花括号的初始化：

``` c++
int a[3][3] = {
    1, 2, 3, 4
};
/*
1 2 3 
4 0 0 
0 0 0  */
```

对于多维数组元素的遍历，有一些比较有意思的形式：

```C++
int a[3][3] = {
    1, 2, 3, 
    4, 5, 6,
    7, 8, 9
};

int main()
{
    // case1：指针
    {
        for(int (*p)[3] = a; p != a + 3; p ++ ) {
            for(int *q = *p; q != *p + 3; q ++ ) 
                cout << *q << ' ';
            cout << endl;
        }
    }
    // case2：auto
    {
        for(auto *p = a; p != a + 3; p ++ ) {
            for(auto *q = *p; q != *p + 3; q ++ ) 
                cout << *q << ' ';
            cout << endl;
        }
    }    
    // case3：auto+范围for循环
    {
        for(auto &p : a) {
            for(auto &q : p) 
                cout << q << ' ';
            cout << endl;
        }
    }


    return 0;
} 
```

---

在 C++ 中，不允许定义长度为 0 的数组，它应该导致编译错误。但在 C99 中，允许大小为 0 的**“灵活数组成员”**，它只能在结构体的最后一个成员中使用，形式上并不指定数组的大小，而是在结构体实例化之后动态分配内存。C++ 中禁止这么做是因为 `vector` 是一个更好的替代品。

我们可以通过 `sizeof` 运算符得到数组的大小进而可以根据数组元素的大小可得到数组元素的个数，不过对于上面提到的“灵活数组成员”，在编译时无法直到它的大小，因此无法使用 `sizeof` 运算符。因此如果使用“灵活数组成员”，它的一般形式为:

``` c++
struct Node {
    int size;
    int data[];
};

int main()
{
    int n = 10;
    Node *node = (Node *)malloc(sizeof(Node) + n * sizeof(int));
    node->size = n;
    for(int i = 0; i < n; i ++ ) {
        node->data[i] = i + 1;
    }
    for(int i = 0; i < node->size; i ++ ) {
        cout << node->data[i] << ' ';
    }
    cout << endl;

    return 0;
} 
```

---

在使用初始值列表对数组初始化时，如果制定了数组的维度，那么初始值列表中元素的个数不能大于数组的维度；如果初始值列表中元素的个数小于数组的维度，那么剩余元素会初始化为默认值，因此 `int a[n]={};` 即可初始化所有数组元素为 `0`。

---

字符数组有一种额外的初始化形式，即使用字符串字面值来初始化。不过要注意字符串字面值结尾处的空字符 `\0` 也会拷贝到数组当中：

``` C++
char a1[] = "0123";
cout << sizeof(a1) << endl; // 5
char a2[4] = "0123"; // wrong:没有额外空间存放空字符
```

---

一个容易忽视的点就是，我们可以通过范围 `for` 循环来遍历数组。这是因为数组大小在编译期就已知了，并且数组的大小还会被隐式的存储在栈或堆上。这也同样解释了我们为什么能使用 `sizeof` 运算符计算数组大小。

不过要主义的是，当我们使用范围 `for` 循环遍历多维数组的时候，**除了最内层的循环外，其它所有循环的控制变量都应该是引用类型。**这是因为如果不通过引用类型来控制外层循环，由于数组会自动转换为指针，`auto` 会把数组推导为一个指针，而内层循环试图在一个指针内进行遍历，这显然是不合法的。

----

数组还有一个特性，那就是在很多用到数组的地方，编译器会自动地将其替换为一个指向数组首元素的指针。这就会导致一些特殊的情况：

``` c++
int a[] = {1, 2, 3};
auto b(a);  // <==> int *b = a;
```

实际上相当于：`auto c(&a[0]); // <==> int *c = a;`

当程序直接使用数组的名字时，也会自动将其转换为指向数组首元素的指针。看下面的例子：

``` c++
int a[3][3] = {
    1, 2, 3, 
    4, 5, 6,
    7, 8, 9
};

int main()
{
    for(int (*p)[3] = a; p != a + 3; p ++ ) {
        for(int *q = *p; q != *p + 3; q ++ )
            cout << *q << ' ';
        cout << endl;
    }
    return 0;
} 
```

但是当使用 `decltype` 关键字时，由数组到指针的转换不会发生，`decltype(a)` 返回的是由三个整数构成的数组。另外，作为取地址符（`&`），`sizeof` 及 `typeid` 等运算符的运算对象时，数组也不会自动转换为指针。

---

数组不是一个 `class`，因此它也没有 `begin` 和 `end` 成员函数，如果我们想通过迭代器的形式遍历数组，需要自行指定 `begin` 和 `end`：

``` C++
int a[] = {1, 2, 3};
int *begin = &a[0], *end = &a[3];
```

尽管这样可行，但是并不可靠，因为我们需要手动指定地址，而人总是会出错的！为了解决这个问题，C++11 新标准引入了两个名为 `begin` 和 `end` 的函数，它可以接受数组或容器作为它的参数：

``` c++
int a[] = {1, 2, 3};
int *b = begin(a), *e = end(a);
```

----

数组的索引下标允许是一个负数，相当于当前指针前面的位置。而 `vector` 和 `string` 的下标是无符号数，不能为负，因此如果你传入一个负数，会被解释为一个正数，这个正数往往很大而越界，使用它的应为是未定义的。如果使用 `at` 函数来访问会抛出一个 `out_of_range` 异常。

## 40. C Style Character String

C 风格字符串不是一种类型，而是为了表示和使用字符串而形成的一种约定成俗的写法。按此习惯书写的字符串存放在字符数组（`char[]`）中并以空字符（`\0`）结尾。

不能像 `string` 一样直接通过 `<` 运算符来比较两个 C 风格字符串的大小。因为我们已经知道编译器会把对数组的操作转换为对指针的操作，因此直接比较两个字符数组相当于比较这两个数组的首指针。如果我们想要比较两个字符数组，需要使用 `strcmp(p1,p2)` 函数。如果 `p1==p2` 返回 `0`；如果 `p1<p2` 返回一个负数（`-1`）；如果 `p1>p2` 返回一个正数（`1`）。

通过 `strlen(p)` 可以获取字符数组的长度，不包含空字符。

通过 `strcat(p1,p2)` 可以将 `p2` 附加到 `p1` 之后，但要保证 `p1` 有足够的空间来容纳 `p2`。

最后，我们并不推荐使用 C 风格字符串，因为 C++ 标准库的 string 更安全，更高效。

考虑到为了与 C 兼容，C++ 提供了 `string` 转换为 C 风格字符串的方式：`stribg.c_str()`，它返回一个 `const char*` 对象。

## 41. buffer overflow

**缓冲区溢出**（Buffer Overflow）是编程中的一种常见漏洞或错误，尤其在 C 和 C++ 语言中更为常见。它发生在程序尝试写入比目标缓冲区（通常是一个数组或内存块）所能容纳的更多数据时，导致数据溢出到相邻的内存区域。这可能导致程序崩溃、内存破坏，甚至被恶意利用进行攻击。

缓冲区溢出的工作原理：

在程序中，缓冲区通常是分配给特定类型数据的固定大小的内存块，例如字符数组或整数数组。当程序试图将超过该大小的数据写入缓冲区时，溢出的数据会覆盖到缓冲区之外的内存区域。这些区域可能包含其他数据、指针，甚至程序的执行路径，这为恶意用户提供了注入代码或控制程序执行的机会。

缓冲区溢出的例子：

以下是一个简单的 C++ 代码示例，展示了缓冲区溢出是如何发生的：

```C++
#include <iostream>
#include <cstring>  // 包含 strcpy

int main() {
    char buffer[10];  // 定义了一个长度为10的字符缓冲区

    // 如果输入字符串超过了缓冲区大小，就会发生缓冲区溢出
    strcpy(buffer, "This is a very long string");  // 溢出错误

    std::cout << "Buffer: " << buffer << std::endl;
    return 0;
}
```

在这个例子中，`buffer` 只能容纳 10 个字符，但是我们使用 `strcpy` 复制了一个比它长得多的字符串。这会导致缓冲区溢出，溢出的数据可能覆盖程序的其他内存区域，从而导致未定义行为。

**缓冲区溢出**（Buffer Overflow）是编程中的一种常见漏洞或错误，尤其在 C 和 C++ 语言中更为常见。它发生在程序尝试写入比目标缓冲区（通常是一个数组或内存块）所能容纳的更多数据时，导致数据溢出到相邻的内存区域。这可能导致程序崩溃、内存破坏，甚至被恶意利用进行攻击。

缓冲区溢出的危害：

1. **程序崩溃**：如果溢出数据覆盖了重要的内存区域，程序可能会立即崩溃。
2. **安全漏洞**：攻击者可以利用缓冲区溢出漏洞注入恶意代码（称为**代码注入攻击**），并劫持程序的控制流，执行任意指令。这是早期许多恶意软件和病毒传播的方式。
3. **内存破坏**：溢出可能破坏程序的其他数据结构，导致数据丢失或错误。
4. **远程代码执行**：通过精心设计的输入，攻击者可能远程控制受影响的程序，执行任意代码，甚至获取系统权限。

缓冲区溢出的种类：

1. **栈缓冲区溢出**：

   * 发生在栈上分配的缓冲区上。例如局部变量的数组。
   * 溢出可能覆盖函数的返回地址，从而导致控制流劫持。

   ```
   cpp复制代码void foo() {
       char buffer[8];
       strcpy(buffer, "A long string");
   }
   ```

2. **堆缓冲区溢出**：

   * 发生在堆上分配的缓冲区上（如通过 `malloc` 或 `new` 分配的内存）。
   * 堆溢出可以覆盖其他分配在堆上的数据或破坏内存管理信息。

   ```C++
   void foo() {
       char* buffer = new char[8];
       strcpy(buffer, "A long string");
   }
   ```

如何防止缓冲区溢出：

1. **使用安全函数**：

   * 避免使用不安全的函数，如 `strcpy`、`sprintf`，改用安全版本的函数，如 `strncpy`、`snprintf`，指定要复制的最大字符数以防止溢出。

   ```C++
   char buffer[10];
   strncpy(buffer, "This is a very long string", sizeof(buffer) - 1);
   buffer[sizeof(buffer) - 1] = '\0';  // 确保最后一个字符是 null 终止符
   ```

2. **手动检查输入长度**：

   * 在处理用户输入或外部数据时，确保检查输入数据的长度，并将其限制在缓冲区的大小范围内。

3. **使用标准库的容器类**：

   * 在 C++ 中，优先使用 `std::vector`、`std::string` 等动态调整大小的容器，避免手动管理固定大小的缓冲区。

   ```C++
   std::string buffer = "This is a long string";
   ```
   
4. **启用编译器的安全机制**：

   * 现代编译器提供了多种缓冲区溢出保护机制，例如栈保护（Stack Canaries）和地址空间布局随机化（ASLR），这些技术可以在运行时检测溢出并终止程序。

   例如，编译时加上 `-fstack-protector` 标志可以启用栈保护：

   ```shell
   g++ -fstack-protector your_program.cpp
   ```
   
5. **使用静态或动态分析工具**：

   * 使用静态分析工具（如 `Clang` 的静态分析器、`Coverity`）或动态分析工具（如 `Valgrind`）来检测缓冲区溢出等内存问题。

## 42. `[*]`输入输出流的同步

https://www.cnblogs.com/lysuns/p/4278944.html

## 43. `[*]`lvalue和rvalue

C++ 的表达式要么是左值，要么是右值。这两个名词都是从 C 语言继承过来的。在 C 中，左值和右值的区分比较简单，只涉及变量和表达式的存储地址问题。但在 C++ 中，由于移动语义和右值引用的引入，C++ 增加了对值生命周期和可移动性的关注，右值进一步细化为纯右值和将亡值。

## 44. 运算对象的求值顺序

复合表达式是指含有两个或多个运算符的表达式。求复合表达式的值首先需要将运算符和运算对象合理的组合在一起，**优先级和结合律决定了运算对象组合的方式**。也就是说，它们决定了表达式中每个运算符对应的运算对象来自表达式的哪一部分。表达式中的括号无视上述规则。

**优先级虽然规定了运算对象的组合方式，但是并没有说明运算对象按照什么顺序求值。**在大多数情况下，不会明确指明求值的顺序。例如：

``` c++
int val = f1() + f2();
```

`val` 是一个由加法组合而成的表达式，我们可以明确 `f1()` 和 `f2()` 一定会在执行加法之前调用。但是对于 `val`，我们无法确定是 `f1()` 先求值还是 `f2()` 先求值。

对于那些没有指定执行顺序的运算符，如果表达式指向并修改了一个对象，将会引发错误并产生未定义的行为。例如：

``` c++
int val = 0;
cout << val << ' ' << ++ val << endl;	// 未定义行为
```

对于上面的输出语句，编译器可能先求 `++val` 的值再求 `val` 的值，输出 `1 1`；也可能先求 `val` 的值再求 `++val` 的值，输出 `0 1`。甚至编译器还可能做出完全不同的操作。但无论怎样，由于表达式的行为是不可预知的，因此无论编译器生成什么代码程序都是错误的。

不过有四种运算符明确规定了运算对象的求值顺序：

* `&&`：左侧为真右侧才执行
* `||`：左侧为假右侧才执行
* `,`：右侧结果的值
* `?:`：真时计算左侧的值，假时计算右侧的值

---

最后，我们要强调的是：运算对象的求值顺序与优先级和结合律无关，在一条形如 `f()+g()*h()+j()` 的语句中：

* 优先级规定，`g()` 的返回值和 `h()` 的返回值相乘
* 结合律规定，`f()` 的返回值先与 `g()` 和 `h()` 的乘积相加，所得结果再与 `j()` 的返回值相加
* 对于这些函数的调用顺序并没有明确规定

因此，如果 `f`、`g`、`h` 和 `j` 是无关函数，它们不会改变同一对象的状态，那么它们的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。

因为 C++ 语言并没有规定加法和乘法运算符的运算对象的求值顺序，这给编译器留下了优化的余地，编译器可以选择任意的求值顺序。

因此，如果我们改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。

## 45. 取余的符号

首先，参与取余运算的两个运算对象必须是整数类型，如果是其它类型此时并不会进行自动类型转换。

对于 `m % n`，无论在 C 还是 C++ 中，如果 `m` 不能整除 `n`，取模结果的符号都是和 `m` 相同的。

为什么会这样设计？

考虑取模运算的定义，如果 `m` 和 `n` 是整数且 `n` 非 `0`，则 `m=(m/n)*n+m%n`。为了除法和取模操作之间的一致性得以保持。取模运算的结果需要补偿整数除法向零取整带来的偏差，这样才能保证余数加上商乘以除数等于原始的被除数 `m`。

由于向零取整的缘故，导致当商为正数时，这个正数更小了；当商为负数时，这个负数更大了。因此当 `m` 为负数时，余数 `m%n` 也应该为负数，以抵消商变大的影响；当 `m` 为正数时，余数 `m%n` 也应该为正数，以抵消商变小的影响。

## 46. `[*]`右结合律的运算符

平常我们遇到的运算符基本都是左结合律的，但也有一部分运算符是右结合律的：

* 赋值运算符

## 47. 复合赋值运算符

相较于 `A = A op C` 的形式，`A op= C` 可以少访问一次 `A`。因此某些情况下可以些许提高程序性能。

编译器通常将 `A op= C` 优化为仅对 `A` 的值进行一次访问，因为它不需要先读取 `A` 的值再写回，能够直接修改 `A`。

因此，**`A op= C` 形式只需要一次内存访问**（仅一次写操作或一次读取-写入操作，具体取决于硬件架构）。

**内存访问的代价**：在现代计算机系统中，内存访问是相对较慢的操作，尤其是在 `A` 是一个大对象（如数组、类实例等）时。减少内存访问次数可以提高性能，特别是在嵌套循环、批量计算或者大型数据集上进行操作时。

**CPU 指令优化**：`A op= C` 通常可以通过更少的指令实现，而 `A = A op C` 可能涉及更多的指令，尤其在涉及临时变量和额外的内存读取时。复合赋值操作允许编译器利用 CPU 寄存器和流水线（pipeline）的优化，使代码执行得更高效。

现代编译器通常能智能地优化代码，但 `op=` 形式明确提示编译器进行内存访问的优化。尽管编译器可能对 `A = A op C` 进行一些优化，但使用 `A op= C` 形式更直接，避免对 `A` 的多余读取。

## 48. `*++it`，`++*it`，`*it++`

* `*++it` 相当于 `*(++it)`
* `++*it` 相当于 `++(*it)`
* `*it++` 相当于 `*(it++)`

`*` 和 `++` 的优先级是相同的，所以考虑结合律，单目运算符的结合律是从右向左的。

## 49. 三目（条件）运算符

三目运算符的优先级相当低，仅仅比赋值和逗号表达式的优先级高，因此当用到三目运算符时建议总是加上括号，即 `(cond ? exprexpr2)`。

当三目运算符的两个表达式都是左值或能转换为同一类型的左值类型时，运算的结果是左值；否则运算的结果是右值。

``` C++
int a = 1, b = 2;
bool flag = true;

(flag ? a : b) = 1024;
cout << a << endl; // 1024
cout << b << endl; // 2
```

注意对于上面的 `(flag ? a : b) = 1024;` 如果不加括号，即 `flag ? a : b = 1024;` 编译器会把它解释为 `flag ? a : (b = 1024);` 而不是 `(flag ? a : b) = 1024`

这是因为编译器在处理 `flag ? a : b = 1024;` 时，会将这个表达式堪称三个部分：

* condition: `flag`
* case true: `a`
* casr false: `b=1024`

## 50. `[*]`关于优先级和结合性的思考

**准确来说，优先级和结合性确定了表达式的<font color=blue>语义结构</font>，不能跟求值次序混为一谈。**

> 语义结构就涉及到编译器根据文法规则构建语法树。

所谓语义结构，我们就可以理解为“加圆括号的过程”，通过加圆括号，编译器就能准确无误的确定执行顺序了，表达式的语义就是固定的了，例如：

* `flag ? a : b = 1024` 转换为 `flag ? a : (b = 1024)`
* `cout << a < b` 转换为 `(cout << a) < b`
* `a = b = c = 1024` 转换为 `a = (b = (c = 1024))`
* `*it++` 转换为 `*(it++)`
* `cond ? ++x, ++y : --x, --y` 转换为 `(cond ? ++x, ++y : --x), --y`

通过这个过程，我们也能更好的理解，求复合表达式的值首先需要将运算符和运算对象合理的<font color=blue>**组合**</font>在一起，**优先级和结合律决定了运算对象组合的方式。**

## 51. 位运算符

参与位运算的对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且，此时的左移操作可能会改变符号位的位置，因此这是一种未定义行为。**所以强烈建议仅将位运算用于处理无符号类型**。

一般来说，如果运算对象是“小整形”，它的值会被自动提升为较大的整数类型。例如 `char` 和 `short` 会自动提升为 `int`。注意不是提升为 `unsigned int`。例如，对于下面的程序，计算输出的值：

``` c++
unsigned char q = 0b01110001;
cout << (~q << 6) << endl;
```

## 52. sizeof

`sizeof` 返回一条表达式或一个类型名字所占的字节数。它在编译期求值并返回一个 `size_t` 类型的常量表达式。

当求表达式的字节数时， `sizeof` 并不会实际计算表达式的值。因此说，对于 `sizeof *p;`，即便 `p` 是一个无效指针或空指针，也不会有什么影响，因为 `sizeof` 并不需要真的解引用指针也能知道它所指对象的类型。

C++11 允许通过作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问类的成员，但是 `sizeof` 运算符无需我们提供一个具体的对象，因为 `sizeof` 运算符无需真的获取该成员。例如：

``` c++
struct Foo {
    int i;
    double d;
};

int main()
{
    cout << sizeof(Foo::i) << endl;
    cout << sizeof(Foo::d) << endl;
    cout << sizeof(Foo) << endl;
    return 0;
}  
```

注意，如果类成员的访问属性不是 `public`，则不可以在类外直接通过域运算符来访问。

对 `string` 和 `vector` 对象执行 `sizeof` 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间：

``` c++
vector<int> v1{1, 2, 3};
vector<int> v2;
string s1("hello");
string s2;
cout << sizeof(v1) << ' ' << sizeof(v2) << endl; // 24 24
cout << sizeof(s1) << ' ' << sizeof(s2) << endl; // 32 32
```

不过对于数组， `sizeof` 会返回数组中元素大小之和。

对于引用，`sizeof` 会返回引用所指对象的大小，这符合对引用的操作就是对引用所指对象的操作的规则。

## 53. 逗号运算符

逗号表达式按照从左向右的顺序求值，在求右侧的值时会把左侧的值丢弃，因此其最终结果是右侧表达式的值。

逗号的优先级是最低的。 

## 54. intergral pormotion

在大多数表达式中，比 `int` 类型小的整型值首先提升为较大的整数类型。例如一个 `char` 类型和一个 `short` 类型相加，它们都会提升为 `int` 类型。

如果两个运算对象都带符号或者都不带符号，那么较小的类型将提升为较大的类型。

如果一个运算对象带符号，一个运算对象不带符号：

1. 类型相同：例如 `unsigned int` 和 `int`，那么 `int` 会转换为 `unsigned int`
2. 无符号数的类型更大：例如 `unsigned long long` 和 `int`，那么 `int` 会转换为 `unsigned long long`
3. 有符号数的类型更大：此时有符号数可以保存无符号数的所有制，例如 `unsigned int` 和 `long long`，那么 `unsigned int` 转换为 `long long`

## 55. C++风格显式（强制）类型转换

### static_cast

任何具有明确定义的类型转换，只要不包含底层 `const`，都可以使用 `static_cast`。

### const_cast

`const_cast` 是专门用来改变运算对象的底层 `const` 的。常常用于用函数重载的上下文中。

``` c++
const string& shorterString(const string &s1, const string &s2)
{
    return s1.size() < s2.size() ? s1 : s2;
}

string& shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1),
        const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```

### dynamic_cast

`dynamic_cast` 利用 **运行时类型识别（RTTI）** 来确保类型转换的安全性。在运行时，它会检查转换的类型是否合法，并根据情况返回合适的结果。

例如我们可以用它来确保某个基类向派生类的转换是安全的。如果我们自己就能确保该转换的安全性而无需借助编译器的检查，可以直接使用 static_cast 实现基类到派生类的类型转换。

向上转换是指将派生类指针或引用转换为基类指针或引用。C++ 中向上转换是隐式支持的，不需要使用 `dynamic_cast`，但可以使用 `dynamic_cast` 显式完成转换。

在多重继承或虚继承的情况下，`dynamic_cast` 可以用于不同派生类之间的转换。例如，当两个类之间有共同的虚基类时，可以在这些类的指针或引用之间进行转换。

``` c++
#include <iostream>

class Base {
public:
    virtual void show() = 0;  // 基类必须是多态的
};

class Derived1 : virtual public Base {
public:
    void show() override { std::cout << "Derived1\n"; }
};

class Derived2 : virtual public Base {
public:
    void show() override { std::cout << "Derived2\n"; }
};

int main() {
    Derived1 d1;
    Base *basePtr = &d1;
    Derived2 *d2Ptr = dynamic_cast<Derived2*>(basePtr);  // 跨类转换

    if (d2Ptr) {
        d2Ptr->show();  // 如果转换成功
    } else {
        std::cout << "转换失败\n";  // 输出 "转换失败"
    }

    return 0;
}
```

### reinterpret_cast

`reinterpret_cast` 通常为运算对象的位模式提供较低层次上的重新解释，例如：

``` c++
char cp[] = "12341234";
int *ip = reinterpret_cast<int*>(cp);
cout << hex << ip[0] << ' ' << ip[1] << endl;
// 34333231 34333231
```

字符 `1` 的十六进制表示为 `0x31`，字符 `2` 的十六进制表示为 `0x32`…。因此我们可以推断出，`cp` 为首地址的内存存储的数据为：`0x31 0x32 0x33 0x34 0x31 0x32 0x33 0x34 0x00`。

如果我们要将其解释为 `int` 类型，需要考虑字节序。在计算机中，数据一般是以小段方式存储的，这样低地址存放低位数据，方便计算机处理。而大段方式在低地址存放高位数据，更符合我们现实中的情况，利于人类阅读。

在这里，我的计算机是以小段方式存储的，因此当 `cp` 解释为 `int` 时，低地址会存放地位数组，因此 `1` 是低地址处的数据，所以它会被放到 `int` 的地位；而 `4` 是高地址处的数据，因此它会被放到 `int` 的高位。所以输出是 `0x34333231` 而不是 `0x31323334`。

使用 `reinterpret_cast` 是非常危险的，因为它虽然确保了语法层面的正确性，但它的某些行为可能导致错误的：

``` C++
int ip[] = {0x64636261, 0x64636261, 0x64636261};
char *cp = reinterpret_cast<char*>(ip);
cout << cp << endl;
string str(cp);
cout << str << endl;
```

会输出：

``` shell
abcdabcdabcd���
abcdabcdabcd���-5V
```

我们发现最后会输出一些乱码，这是因为从 `int*` 转换为 `char*` 之后，`char*` 并没有空字符 `\0`，也就会导致缓冲区溢出问题。

另外，`reinterpret_cast` 本质上是依赖于机器的，因为不同的机器可能对二进制位有不同的解释规则。因此若想安全的使用它，必须要涉及的类型和编译器实现转换的过程都非常了解。

### 旧式强制类型转换

``` C++
type(expr);	// 函数形式的强制类型转换
(type)expr;	// C语言风格的强制类型转换
```

## 56. `char *cp=“12341234”`

在 C++ 中，语句 `char *cp = "12341234";` 会将字符串字面量 `"12341234"` 的地址赋值给指针 `cp`。虽然这种写法在 C 语言中是合法的，但在现代 C++ 中，它已经被认为是不安全的，甚至可能引发问题。下面详细说明这一语句的行为及其潜在问题。

### 1. 字符串字面量存储位置

在 C 和 C++ 中，字符串字面量（如 `"12341234"`）通常存储在**只读内存**中。这意味着该字符串的内容是常量，不应该被修改。

* `"12341234"` 会被放在静态只读区，编译器将其视为 `const char[9]`（包括末尾的空字符 `\0`）。
* 尽管语句 `char *cp = "12341234";` 将字符串的地址赋值给了 `char*`，但这意味着指针 `cp` 指向的是只读内存中的内容。

### 2. 潜在问题

#### 2.1. 修改只读数据

由于 `cp` 是一个 `char*` 类型的指针，它并没有明确地标记为指向常量数据（`const`）。因此，程序员可以通过 `cp` 试图修改字符串的内容，例如：

```C++
cp[0] = 'X';  // 试图修改 "12341234" 的第一个字符
```

这将导致**未定义行为**。在许多系统中，试图修改只读内存会导致程序崩溃（如段错误 `segmentation fault`）。

#### 2.2. 推荐的写法

为了避免这种潜在的问题，现代 C++ 要求将字符串字面量视为 `const`，并使用 `const char*` 来指向它：

```C++
const char *cp = "12341234";
```

这样，编译器会阻止你通过 `cp` 修改字符串的内容。如果你试图修改它，将会在编译时产生错误，保证了安全性：

```C++
cp[0] = 'X';  // 编译时会报错，因为 cp 指向 const 数据
```

### 3. 动态分配内存

如果你需要修改字符串的内容，可以将字符串字面量复制到动态分配的内存中，然后对其进行操作。例如：

```C++
#include <iostream>
#include <cstring>  // for strcpy

int main() {
    char *cp = new char[9];  // 动态分配内存
    strcpy(cp, "12341234");  // 复制字符串到动态内存
    cp[0] = 'X';  // 可以安全修改
    std::cout << cp << std::endl;

    delete[] cp;  // 释放动态分配的内存
    return 0;
}
```

在这种情况下，字符串存储在堆中，可以安全地修改它的内容。

## 57. 优先级，结合律，求值顺序

每个运算符都有其对应的优先级和结合律，优先级规定了符合表达式中运算符组合的方式。结合律则说明当运算符的优先级一样时应该如何组合。求值顺序则规定了是先对右侧对象求值还是先对左侧对象求值还是都可以。

## 58. 空语句

一般来说，当循环的全部工作在条件部分就可以完成时，我们通常会用到空语句：

``` C++
while(cin >> val && val != target)
    ;	// 空语句
```

空语句一般来说是无害的，但如果在 `if` 或者 `while` 后面跟了一个额外的空语句就可能完全改变程序员的初中。例如：

``` c++
while(iter != v.end()) ; // 空语句会导致无限循环
	++ iter;
```

因此，非必要请不要有额外的空语句，例如：`int val = 1;;` 这是不好的写法。

## 59. 语句作用域

可以在 `if`、`switch`、`while` 和 `for` 语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：

``` C++
double get_num()
{
    double x;   cin >> x;
    return x;
}

int main()
{
    int x = 10;
    if(double x = get_num()) { // X只在if内部可见
        cout << x << endl;
    }
    cout << x << endl;
    return 0;
}  
```

## 60. dangling else

在 C++ 中，dangling else（悬垂else）问题是指在嵌套的条件语句中，由于缺少明确的分组或合适的花括号，编译器可能将 `else` 语句错误的与离它<FONT COLOR=BLUE>最近</FONT>的 `if` 匹配以避免二义性，而不是开发者希望的那个 `if`。这个问题主要是因为 C++ 的条件语句语法允许 `if-else` 结构不适用花括号，从而造成了不确定性。例如：

``` c++
if (x > 5)
    if (y > 15)
        std::cout << "x > 5 and y > 15" << std::endl;
else
	std::cout << "x <= 5" << std::endl;
```

我们觉得它是：

```c++
if (x > 5) {
    if (y > 15) {
        std::cout << "x > 5 and y > 15" << std::endl;
    }
}
else {
    std::cout << "x <= 5" << std::endl;
}
```

实际上是：

``` c++
if (x > 5) {
    if (y > 15) {
        std::cout << "x > 5 and y > 15" << std::endl;
    }
	else {
    	std::cout << "x <= 5" << std::endl;
    }
}
```

因此为了避免 dangling else 问题，一种编程规范是始终在条件语句中使用花括号，尽管可能只有一条语句。

## 61. switch

`case` 标签必须是**常量、整形**表达式。并且每个标签只能有一个值，因此 `case 1, 3, 4:` 的写法是错误的，正确的写法应该是：

``` c++
case 1:
case 3:
case 4:
```

`switch` 的 `case` 标签并不是一个独立的作用域，一个标签中的内容对于其他标签是可见的。

即使不准备在 `default` 标签下做任何工作，定义一个 `default` 标签也是有意义的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么都没做。

对于最后一个 `case` 标签和 `default` 标签有必要时都应该加上 `break`，这是一个好的习惯。

## 62. switch内部的变量定义

首先我们要明确声明和初始化在 `run time` 的不同之处。

* 对于声明语句：只需要在编译期进行处理，让编译器能认识这个符号是什么类型的。而在程序实际运行时，这种“单一声明”没有对应的机器指令，不需要跑。
* 对于声明且初始化的语句：在 `run time` 时也是有指令的，需要运行这些指令才能达到相应的效果。

这一点我们可以从汇编层面更清晰的看到。

``` c++
int main()		
{
    return 0;
}  
```

对应的汇编代码为：

``` assembly
main:
        push    rbp
        mov     rbp, rsp
        mov     eax, 0
        pop     rbp
        ret
```

``` c++
int main()
{
    int val;
    return 0;
}  
```

对应的汇编代码为：

``` assembly
main:
        push    rbp
        mov     rbp, rsp
        mov     eax, 0
        pop     rbp
        ret
```

可以发现，尽管我们额外声明了一个 `int val;` ，汇编代码也没有任何变化，说明声明语句并没有带来额外的机器指令。

那么如果我们将其定义了呢？

``` c++
int main()
{
    int val = 32;
    return 0;
}  
```

对应的汇编代码为：

``` assembly
main:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], 32	# 初始化机器指令
        mov     eax, 0
        pop     rbp
        ret
```

可以发现我们需要额外执行一条用于初始化 `val` 的机器指令。

因此，如果不能运行这条机器指令，`int val=32;` 的效果就没有达到，那么干脆在编译时，直接禁止你使用。**C++ 规定，不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置。**以此确保程序的安全性和一致性，因为如果我们使用了未经初始化的变量，其行为是未定义的。例如 `goto`，`switch`，函数返回等方式都可能直接跳到变量的作用域中而不先执行初始化。

那么对于 `switch` 来说，我们前面提到过，不同 `case` 的作用域是一致的，因此说如果我们在 `case 1` 中定义了一个变量，那么在后面的 `case 2` 中该变量是可见的。而 `case 1` 未必会得到执行，这就可能导致该变量的初始化语句未得到执行，编译器就会报错。

为了解决该问题，我们有两种方案：

（1）使用声明而不是初始化

（2）通过花括号将变量定义在块内，从而对其他 `case` 不可见：

``` C++
int main()
{
    int op = 1;
    switch(op)
    {
        case 1:
        {
            int x = 10;
            cout << x << endl;
        }
        break;
        case 2:
        {
            int x = 20;
            cout << x << endl;
        }
        default:
        {
            double x = 3.14;
            cout << x << endl;
        }
        break;
    }
    return 0;
}  
```

## 63. do-while循环内的变量定义

在 `do-while` 中，由于先执行 `do` 在执行 `while`，因此在 `while` 部分定义变量显然是不合法的。

## 64. 隐式初始化陷阱

当我们在程序的任何地方写下 `string s;` 时，不要误认为我们仅仅只是声明了一个 `string` 类型的变量 `s`，它实际上通过默认构造函数完成了“隐式初始化”。也即完成了定义。

## 65.  range-for原理

范围 `for` 语句的定义来源于与之等价的传统 `for` 循环：

``` c++
vector<int> v;

for(auto &x : v) {
    ...
}

for(auto begin = v.begin(); begin != v.end(); ++ begin) {
    ...
}
```

通过等价的 `for` 形式，我们也能理解，为什么不能在范围 `for` 内部增删容器对象的元素了，因为这样会使 `begin` 和 `end` 迭代器失效。

## 66. goto和label

在 C++ 中，**label（标签）**是一种用于标记代码位置的语法元素，通常与 `goto` 语句配合使用。`label` 标志了代码中的一个位置，程序可以通过 `goto` 跳转到这个位置执行后续的代码。

C++ 中的标签作用域是 **函数级别的**，这意味着你可以在同一个函数内部跳转到任意位置，但标签的跳转不能跨越函数边界。也就是说，`goto` 不能跳出或跳进其他函数。

> goto只能在在当前函数内的 label 中跳转。不可以在不同函数中跳转。
>
> label 独立于程序中的变量和其它标识符的名字。可以理解为 label 是一个独立的命名空间。

## 67. exception handler

### 1. what()

异常类型只定义了一个成员函数，用于提供关于异常的一些文本信息：

 `virtual const char* what() const noecept;`

例如：

``` c++
#include <iostream>
#include <exception>
#include <string>

class MyException : public std::exception {
private:
    std::string message;

public:
    MyException(const std::string& msg) : message(msg) {}

    virtual const char* what() const noexcept override {
        return message.c_str();  // 返回异常信息
    }
};

int main() {
    try {
        throw MyException("This is a custom exception");
    } catch (const std::exception& e) {
        std::cout << "Caught exception: " << e.what() << std::endl;
    }

    return 0;
}
```

### 2. 异常安全的代码

异常中断了程序的正常执行。这意味着当异常发生时，调用者请求的一部分计算已经完成了，另一部分则尚未完成。通常情况下，略过部分代码意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。那些在异常发生期间正确执行了“清理”工作的程序称为“异常安全”的代码。也即即使程序出现了异常，也能安全运行的程序代码。

编写异常安全的代码使非常苦难你的。我们必须时刻清楚异常何时发生，异常发生后程序如何确保对象有效、资源无泄漏、程序处于合理状态，等等。

### 3. 标准异常

C++ 定义了一组类用于报告标准库函数遇到的问题。它们分别定义在 4 个头文件中：

* `<exception>`：定义了最通用的异常类 `exception`，它是所有异常类的基类。只报告异常的发生，获取基础的错误信息，不提供任何额外信息。
* `<new>`：定义了 `bad_alloc` 异常类型。
* `type_info`：定义了 `bad_cast` 异常类型。
* `stdexcept`：定义了几种常用的异常类，如下表所示：

| 异常             | 说明                                           |
| ---------------- | ---------------------------------------------- |
| exception        | 最常见的问题                                   |
| runtime_error    | 只有在运行时才能检测出的错误                   |
| range_error      | 运行时错误：生成的结果超出了有意义的值域范围   |
| overflow_error   | 运行时错误：计算上溢                           |
| underflow_error  | 运行时错误：计算下溢                           |
| logic_error      | 程序逻辑错误                                   |
| domin_error      | 逻辑错误：参数对应的结果值不存在               |
| invalid_argument | 逻辑错误：无效参数                             |
| length_error     | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
| out_of_range     | 逻辑错误：使用一个超出有效范围的值             |

我们只能以默认初始化的方式初始化 `exception`、`bac_alloc` 和 `bad_cast` 对象，不允许为这些对象提供初始值。其他类型异常则应该使用 `string` 或 C 风格字符串初始化以提供含有错误相关的信息。

### 4. 计算错误

| 异常类型              | 描述                                                 | 应用场景                                                     |
| --------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| **`range_error`**     | 表示生成了超出逻辑范围的结果，但与硬件无关。         | 结果超出了**业务逻辑**的有效范围，但仍在数据类型允许的范围内。 |
| **`overflow_error`**  | 表示上溢，数值超出了数据类型能表示的最大值。         | 数值计算结果超出了**类型**所能表示的范围，如整数或浮点数上溢。 |
| **`underflow_error`** | 表示下溢，数值接近零，但小于数据类型能表示的最小值。 | 数值接近零但小于**类型**的表示范围，通常用于浮点数的下溢情况。 |

### 5. 逻辑错误

`domain_error` 表示传给函数的参数不在其定义域内。即，参数的取值在数学或逻辑上是不合法的。**应用场景**: 当函数的输入参数无法产生有效的输出结果时会抛出该异常。例如，计算一个负数的平方根时，负数不属于实数平方根函数的定义域。

`invalid_argument` 表示传递给函数的参数无效。与 `domain_error` 不同，`invalid_argument` 通常用于表示非数学性问题，例如传入错误的数据格式或类型。**应用场景**: 当传入的参数本身与函数所预期的格式或类型不符时，会抛出该异常。例如，将一个非数字字符串传递给要求数字输入的函数。

 `length_error` 表示在操作一个容器或字符串时，尝试创建或操作的对象长度超出了该类型所能表示的最大长度。**应用场景**: 当操作的容器或字符串长度超出其类型的允许范围时会抛出该异常。例如，尝试创建一个非常大的字符串或者向容器添加超出其最大容量的元素时。

 `out_of_range` 表示访问了无效的索引或超出了有效范围的值。它通常在尝试访问超出容器边界或给定不合法的索引时抛出。**应用场景**: 当访问的索引超出容器（如数组、向量、列表等）的边界时会抛出该异常。比如，访问一个空向量中的元素或者超出数组边界的索引。

总结：

* **`domain_error`** 是用于数学定义域外的错误，通常发生在数学函数处理非法参数时。
* **`invalid_argument`** 用于参数不符合函数要求的情况，通常与数据格式或类型有关。
* **`length_error`** 是指在创建或操作容器时，长度超过了允许的最大值。
* **`out_of_range`** 主要用于索引访问，表示试图使用超出容器有效范围的索引。

## 68. 鲁棒性

**“鲁棒”一词通常用于描述系统、程序或算法在面对变化、错误或不确定性时的稳定性和可靠性。**它源于英语中的“**robust**”，广泛应用于计算机科学、工程、统计学等多个领域。

### 1. **鲁棒性定义**

* **对抗性**：鲁棒系统能够抵御输入数据的噪声、错误或异常，而不导致系统崩溃或输出不正确的结果。
* **适应性**：鲁棒系统能够在各种环境和条件下保持其功能和性能，即使在面对不完全信息或不确定性时。
* **故障容忍**：鲁棒系统能够在发生部分故障时继续运行，提供有限的功能，而不是完全失败。

### 2. **鲁棒性的重要性**

* **用户体验**：鲁棒性增强了软件的稳定性，使用户在使用时不会频繁遇到错误或崩溃。
* **安全性**：在安全关键的应用（如医疗、航空航天等）中，鲁棒性可以降低系统故障的风险，保护人身安全。
* **维护成本**：鲁棒系统通常需要更少的维护和支持，降低了长期运行的成本。

### 3. **实现鲁棒性的方法**

* **输入验证**：确保输入数据的有效性和完整性，防止错误数据导致系统崩溃。
* **异常处理**：使用异常处理机制来捕获并处理错误，确保程序能够优雅地处理问题，而不是直接崩溃。
* **冗余设计**：通过引入冗余（如备份系统或冗余组件）来增强系统的容错能力。
* **测试和验证**：进行充分的测试，包括边界条件、异常情况和极端输入，以确保系统在各种情况下都能正常运行。

### 4. **鲁棒性在不同领域的应用**

* **软件开发**：鲁棒性体现在软件能够处理无效输入或异常情况而不崩溃。
* **机器学习**：鲁棒性意味着模型在面对未见数据、噪声或对抗样本时依然表现良好。
* **网络安全**：鲁棒系统能够抵御各种攻击（如拒绝服务攻击），保持服务的可用性和完整性。

### 5. **鲁棒性与强健性**

鲁棒性与“强健性”这两个概念常常混用，但有所不同：

* **鲁棒性**：强调系统在错误、噪声或不确定性下的表现。
* **强健性**：更倾向于系统对变化和干扰的适应能力。

## 69. cerr, cout, clog

| 特性           | `cout`                                   | `cerr`                   | `clog`                   |
| -------------- | ---------------------------------------- | ------------------------ | ------------------------ |
| **用途**       | 正常输出                                 | 错误或警告信息输出       | 日志或调试信息输出       |
| **缓冲行为**   | **缓冲输出**，延迟到缓冲区满或刷新时输出 | **非缓冲输出**，立即输出 | **缓冲输出**，延迟输出   |
| **输出流类型** | 标准输出（通常是控制台）                 | 标准错误（通常是控制台） | 标准日志（通常是控制台） |

## 70. npos

`npos` 是 C++ 中定义的一个常量，通常用于表示字符串操作中的无效位置。它的全称是 "no position"。

在 C++ 的标准库中，`npos` 是 `std::string` 和其他相关容器（如 `std::wstring`、`std::u16string` 等）中的一个特殊的静态常量。`npos` 的值通常被定义为 `-1`，但由于它是无符号类型（`std::string::size_type`），实际上会被解释为一个非常大的数字（通常是 `std::string::size_type` 能表示的最大值，通常是 `size_t(-1)`）。因此，`npos` 表示一种特殊的情况，即找不到某个位置。

使用场景：**字符串查找**: 当在字符串中查找子串时，如果子串不存在，返回值会是 `npos`。

## 71. 作用域和生命周期

首先，名字的作用域和对象生命周期是不同的两个概念。

* 名字的作用域是程序文本的一部分，名字在其中可见
* 对象的生命周期是程序执行过程中该对象存在的一段时间

例如在函数内定义的 `static` 变量，它的名字的作用域仅限于这个函数，在该函数外不可见。但是它的生命周期从第一次定义它时开始，知道程序终止时才解释。

所以说，尽管我们无法在函数外面访问这个 `static` 变量，但这个对象是确切存在的：

``` c++
int f()
{
    static int x;
    x ++ ;
    return x;
}

int main() 
{
    f();
    cout << x << endl; // ‘x’ was not declared in this scope
    return 0;
}
```

## 72. pass by pointer 陷阱

pass by pointer 肯定是不如 pass by reference 好的，这是因为当我们传入指针时，指针本身会被 copy 一份，因此当在函数中修改指针本身时，对传入的实参并无影响。在某些时候我们会忽略这一点，误认为在函数当中对指针的修改会应用到实参上。

>  例子暂时想不出来好的…

## 73. 函数

函数的参数分为形参和实参，实参的主要作用是初始化形参。实参出现在函数调用的地方，形参出现在函数定义的地方。形参名是可选的，如果形参没有名字，那么我们就无法使用它。

函数的返回类型不能是数组或函数类型，但可以是指向数组或函数的指针。

函数的声明也称为函数原型，它包含了调用该函数所需要的全部信息。

我们知道函数参数的 const 属性是不作为函数签名的，这是因为在传参数的时候，顶层 const 被忽略掉了。这体现为，无论我们传入的实参是 const 对象还是非const 对象，函数的行为都是一致的。

## 74. 数组作为函数的参数

### 1. 形参格式

当我们想把数组作为函数的形参时，有三种可供选择的方案：

1. 声明为指针 `void func(int *p);`
2. 声明为不限维度的数组 `vodi func(int p[])`
3. 声明为维度确定的数组 `void func(int p[size])`

由于数组传入函数时实参自动转换成指向数组首元素的指针，因此这三种方式是等价的。编译器只检查传入的参数是否是 `int *` 类型。 特别的，对于第三种方式，传入的维度 `size` 只是一个期望，实际数组大小不一定为 `size` 也是可以的。

### 2. 如果传入数组大小

由于数组不能拷贝，传数组实际上是传指针，所以我们并不知道数组的确切大小。下面有三种方法为函数提供额外的信息：

1. 数组本身包含一个结束符号：类似于 C 风格字符串在最后有一个 `\0` 作为结束符。
2. 使用标准库规范，通过两个迭代器来表示数组大小：`void func(int *begin, int *end);`，`end` 应该为数组最后一个元素的下一个元素。
3. 额外传入一个 `size_t` 类型的变量表示数组大小。

### 3. 传引用

前面我们提到过，形参可以指定数组的维度，虽然它并没有什么实际的作用。但如果此时形参是一个引用的话，数组实参的维度必须与形参指定的维度严格匹配，这是因为当形参为引用时，数组不会自动转换为指针。

``` C++
void func(int (&p)[10]) {}

int main() 
{
    int a[] = {1, 2, 3};
    func(a);   // 参数类型不匹配
    return 0;
}
```

### 4. 传递多维数组

我们曾经介绍过，在 C++ 语言中实际上并没有真正的多维数组，所谓多维数组其实就是数组的数组。所以说，数组的第二维（以及后面所有维度）的大小都是数组类型的一部分。所以说，除了第一维，我们必须明确的指定其他维度的大小。

## 75. 含有可变参数的函数

### 1. `initializer_list<T>`

如果所有参数的类型相同，可以使用 `initializer_list<T>`。从形式和使用上看，它似乎也是一个容器，但是它的元素永远是常量，我们无法修改 `initializer_list` 对象中的元素。不过这也有一个好处，那就是当我们试图拷贝一个 `initializer_list` 对象的时候，并不会有实际的拷贝动作，而是直接与原始列表共享元素。

``` C++
initializer_list<int> a{1, 2, 3, 4};
initializer_list<int> b(a);
for(auto &x : a)    cout << &x << ' ';  cout << endl;
for(auto &x : b)    cout << &x << ' ';  cout << endl;
```

输出为：

``` shell
0x7ffe32940060 0x7ffe32940064 0x7ffe32940068 0x7ffe3294006c 
0x7ffe32940060 0x7ffe32940064 0x7ffe32940068 0x7ffe3294006c 
```

### 2. 省略符 `...`

这是一种 C 风格的可变参数形式，一般不推荐在现代 C++ 中使用。因为它不支持类型安全，并且使用复杂。

### 3. 可变模板参数

``` C++
// 递归出口
void print() {}

template<typename T, typename... Args>
void print(T arg, Args... args) 
{
    cout << arg << ' ';
    print(args...);
}


int main() 
{
    print('a', 1, 3.14, "string");
    return 0;
}
```

在使用可变模板参数时，**模板参数包中的每个参数类型在<font color=blue>编译时</font>就已经被确定**。编译器会为每种类型的组合生成特定的代码，并为每个参数分配合适的存储空间。每个模板参数的值通常存储在栈上（或者可能根据情况存储在寄存器中）。编译器通过参数包的展开处理每个参数。在内存布局上，不同类型的参数将按其顺序依次存储。不同类型的大小由各自的类型决定，编译器根据它们的内存对齐要求来安排它们的存储位置。

### 4. `std::any`

`std::any`（C++17 引入）允许你存储任意类型的对象，并且在需要时可以检查和提取类型。因此 `std::any` 结合容器非常适合用于需要存储多种不同类型的值，但这些类型在编译时并不确定的场景。

主要功能：

1. **存储任意类型的值**：`std::any` 可以存储任何拷贝构造可用的对象。
2. **类型安全的访问**：可以使用 `std::any_cast` 来提取存储的值，并且提供了类型检查。
3. **检查类型**：可以使用 `any.type()` 来获取存储值的类型。

主要方法：

* `any_cast<T>(any)`：提取 `std::any` 中存储的值，并转换为 `T` 类型。如果类型不匹配，会抛出 `std::bad_any_cast` 异常。
* `has_value()`：判断 `std::any` 是否包含值。
* `type()`：返回 `std::type_info`，可以用来比较存储的类型。

注意事项：

1. **性能**：由于 `std::any` 需要在运行时进行类型管理和动态内存分配，它的性能通常比直接使用模板或具体类型要慢，因此仅在有必要时才使用。
2. **类型安全性**：虽然 `std::any` 提供了类型检查功能，但如果在使用 `std::any_cast` 时尝试将值转换为错误的类型，会抛出 `std::bad_any_cast` 异常。使用 `type()` 方法可以先检查类型，确保安全访问。
3. **存储的值必须是可拷贝的**：`std::any` 只能存储那些可以拷贝构造的类型，因此不可拷贝的对象不能存储在 `std::any` 中。

例如：
``` c++
void process(vector<any> &args)
{
    for(auto &arg : args)
    {
        if(arg.type() == typeid(char)) {
            cout << "char: " << any_cast<char>(arg) << endl;
        }
        else if(arg.type() == typeid(short)) {
            cout << "int: " << any_cast<int>(arg) << endl;
        }
        else if(arg.type() == typeid(double)) {
            cout << "double: " << any_cast<double>(arg) << endl;
        }
        else if(arg.type() == typeid(string)) {
            cout << "string: " << any_cast<string>(arg) << endl;
        }
        else {
            cout << "Unknown type" << endl;
        }
    }
}

int main() 
{
    vector<any> args = {'a', 3.14, 123, "hello"};
    process(args);

    return 0;
}
```

`std::any` 的具体实现（如何存储不同类型的元素，动态内存分配？）依赖于标准库的实现细节。大多数情况下，这种实现并没有直接提供公开的 API 来查询是否进行了动态分配，但你可以通过分析性能和内存占用来推断。

总结来说：

* **小对象**：通常不会触发动态内存分配，`std::any` 使用栈上存储。
* **大对象**：会触发动态内存分配，将数据存储在堆上。

这意味着在使用 `std::any` 时，如果存储的是较大的数据结构，可能会引入动态内存分配的开销。

## 76.  `[*]`返回数组指针

因为数组不能被拷贝，所以函数不能直接返回数组。不过，函数可以返回数组的指针或引用。不过从语法上来说，将函数的返回类型设置为数组的指针或引用比较麻烦，但是我们可以通过类型别名等方法来简化这一操作。

### 1. 尾置返回类型

### 2. decltype

### 3. typedef





## 77. 函数签名，名称重整，extern “C”

函数签名（function signatrue）用来唯一标识一个函数的特征。通常包括函数名称和参数信息（类型和数量）。在支持函数签名的语言中，编译器使用函数签名来区分同名但参数不同的函数。

> 在有些语言中，返回类型也会影响函数签名，但在 C++ 中，返回类型不属于函数签名的一部分。

在编译器生成的目标文件中，函数签名不会以原始形式存在。名称重整（name mangling）是编译器在编译过程中，将函数名及其签名转换成一个唯一的标识符的过程。这个标识符在生成的目标文件中使用，用于区分重载函数和其他全局符号。C++ 编译器会通过名称重整将函数签名编码到函数名称中，以便链接器能够正确区分不同的重载函数。

C 语言不支持函数重载，且其符号名称不会被重整。为了在 C++ 中调用 C 的函数，通常需要使用 `extern "C"` 来禁止名称重整，使得编译器生成与 C 语言兼容的符号。

对于下面 C++ 代码：

``` c++
void print(int &x, double b) // _Z5printRid
{
    puts("int, double");     
}

int print(const int x, const int y) // _Z5printii
{
    return x + y;
}

void print(int const *p)	// _Z5printPKi
{
    puts("int const *p");
}

extern "C" {
    void print(int x)  // print
    {
        puts("int");
    }
}
```

我们可以使用 `nm` 命令来获取名称重整后的符号：

``` SHELL
jyyyyx@SegmentTree:~/cpp$ g++ main.cpp -o app
jyyyyx@SegmentTree:~/cpp$ nm app | grep print
0000000000001188 T _Z5printPKi
0000000000001149 T _Z5printRid
0000000000001170 T _Z5printii
00000000000011aa T print
```

其中：

* `_z` 是特定的前缀，表示这是一个重整过的符号
* `5print` 是函数名，`5` 表示函数名的字符长度
* `i`，`d` ，`P` 和 `R`  分别表示 `int`，`double`，`pointer` 和 `reference`
* `k` 表示这是一个 `const` 修饰符

另外我们还可以发现，`extern "C"` 中的函数没有名称重整。另外就是顶层 `const` 属性和返回类型对重整后的名称没有任何影响。

## 78. 重载与作用域

重载对作用域的一般性质并没有什么改变：如果我们在内层作用域声明名字，它将隐藏外层作用域中声明的同名实体。因此我们无法在不同的作用域中重载函数。

尽管在局部作用域声明函数是不明智的选择，但这里仅作为示例：

``` C++
void print(const string &s)  {
    cout << s << endl;
}

void print(double d) {
    cout << d << endl;
}

void func()
{
    bool isReading = false; // 隐藏了外部reading函数
    string s = isReading(); // 错误
    void print(int x);  // 屏蔽外层的两个print函数
    print("hello"); // 错误
    print(3.14); // 正确，调用 print(int)
    print(16); // 正确，调用 print(int)
}
```

> 在 C++ 中，名字查找发生在类型检查之前。这很显然，先找到了名字，才能知道它能接受什么样的参数类型。

## 79. 模式实参

<font color=blue>**默认实参只能出现在函数声明或定义之一。**</font>不能在两者中都定义默认实参，否则编译器会报错，。一般是在头文件的声明中定义默认实参。

### 1. 关键词传参

首先，C++ 不能像 Python 那样按照关键词传递参数，因此下面的函数调用是错误的：

``` c++
void print(const string &s, int a)  {
    cout << s << endl;
    cout << a << endl;
}


int main() 
{
    print(a = 1.1, s = "hello");	// 编译错误
    return 0;
}
```

### 2. 动态添加默认值

C++ 可以通过函数声明动态修改默认实参的个数，不过只能添加，而不能减少或者修改已有的默认实参。由于定义是一次性的，而声明可以多次，所以通过多次声明即可增加默认实参的个数。

例如：

``` c++
void print(int a, int b, int c = 3);

void print(int a, int b = 2, int c);

void print(int a = 1, int b, int c);

void print(int a, int b, int c)
{
    cout << a << ' ' << b << ' ' << c << endl;
}


int main() 
{
    print();
    return 0;
}
```

注意在后续的声明当中，已经有默认实参的形参不能再给予默认值，即使这个默认值和原来相同。

### 3. 动态修改默认值

前面我们提到，我们可以通过多次声明来增加默认值的个数，但是不能修改已有的默认值。其实我们有一种办法可以修改默认值，那就是将默认值绑定到一个全局对象上，通过修改全局对象实现默认值的修改。注意不能将默认值绑定到局部对象上。

``` C++
int val = 10;

void print(int x = val)
{
    cout << x << endl;
}

int main() 
{
    print();    // 10
    val = 1024;
    print();    // 1024
    return 0;
}
```

## `[*]`80. constexpr 

### 1. constexpr变量



### 2. constepxr函数

constexpr 唯一可执行的语句就是返回语句。

参数和返回值必须是字面值类型。



## 81. `[*]`头文件？源文件？

将inline函数和constexpr函数的定义放在头文件中

一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个文件内

## 82. 预处理宏

assert 是一种预处理宏。所谓预处理宏其实是一个预处理变量，他的行为有点类似于内联函数。预处理名字由预处理器而非编译器管理，因此我们可以直接使用 assert 而不是 std::assert。

我们还可以通过其它预处理器定义的预处理名字来调试程序：

* `__FILE__`：存放文件名的字符串字面值
* `__func__`：存放当前函数名的字符串字面值
* `__LINE__`：存放当前行号的字符串字面值
* `__TIME__`：存放文件编译时间的字符串字面值
* `__DATE__`：存放文件编译日期的字符串字面值

## 83. 函数匹配

函数匹配的过程：

1. 确定候选函数：根据函数名查找
2. 确定可行函数：参数相同并且类型相同或者类型可以隐式转换过去
3. 寻找最佳匹配：（最佳体现在每个参数都是最佳的）
   * 该函数每个实参的匹配都不劣于其它可行函数需要的匹配
   * 至少有一个实参的匹配优于其它可行函数提供的匹配

编程建议：调用重载函数时应尽量避免强制类型转换（很容易导致函数匹配二义）。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

那么，如何判断参数匹配的优劣性呢？

编译器将实参类型到形参类型的转换划分为几个等级：

1. 精确匹配
   * 实参类型和形参类型相同
   * 向实参添加顶层const或从实参中删除顶层const：例如实参可以是`const int`，形参可以是`int`（或反之）。
   * 实参从数组类型或函数类型转换为对应的指针类型
2. 通过const转换实现的匹配：为复合类型添加底层const属性
3. 通过类型提升实现的匹配：  把char、unsigned char、short、unsigned short转换成int类型
4. 通过算术类型转换或指针转换实现的匹配：  long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int之间的转换称为类型转换
5. 通过类类型转换实现的匹配

> 注意区分好类型提升和算术类型转换。
>
> 另外就是对于 char 类型来说，如果没有 char 类型与它精确匹配，它会自动提升到 int 而不是 short。

## 84. 函数指针

函数的“类型”是指出去变量名的其余部分，包括返回类型和参数信息。指向不同函数类型的指针间不存在转换规则，这意味着在匹配重载函数时必须精确匹配。

声明数组指针很简单，对于函数 `ret_type func(args);` 只需要将函数名 `func` 替换为指针 `*fp` ，就声明了一个函数指针 `fp`：`ret_type (*fp)(args);` 注意需要用圆括号括起来。

类似于数组，当我们直接使用函数名时，该函数会自动转换为一个指针。这体现在：

* 直接用函数名给指针赋值
* 可以像函数一样使用函数指针
* 类似于数组的直接`int a[]` 作为形参一样，我们也可以直接用函数原型作为形参，但要注意此时虽然像是声明了一个函数，但依然是一个函数指针

``` c++
void func(int x)
{
    cout << "x: " << x << endl;
}

// cmp是一个函数指针
int func1(int a, int b, int cmp(int a, int b))
{
    return cmp(a, b);
}

// func2和func1是等价的
int func2(int a, int b, int (*cmp)(int a, int b))
{
    return cmp(a, b);
}

int main() 
{
    void (*fp)(int) = func;
    fp(1);      // fp更像一个函数
    (*fp)(2);   // fp更像一个指针
    return 0;
}
```

有时函数类型可能比较复杂，我们可以利用 `using` 来指定别名，不过要注意函数和函数指针的区别：

``` c++
int add(int a, int b)
{
    return a + b;
}

//using funcType = int(int,int);  // 声明了一个函数类型
using funcType = decltype(add); // 等价形式

//using funcPtr = int(*)(int,int); // 声明了一个指针类型(指向函数的指针)
using funcPtr = decltype(&add); // 等价形式

int func(int a, int b, funcType cmp)
{
    return cmp(a, b);
}


int main() 
{
    //funcType f1 = add;  // 编译错误，funcType是个函数类型而不是指针类型
    funcPtr  f2 = add;
    cout << func(3, 4, f2) << endl;
    cout << func(3, 4, add) << endl;
    return 0;
}
```

## 85. this

this 形参是隐式定义的。事实上，任何自定义的名为 this 的参数或变量的行为都是非法的。

因为 this 总是指向调用函数的那个对象，所以 this 是一个常量指针，我们不允许修改 this 中保存的地址。

也因为 this 是一个指针，因此当我们传入的对象有 const 属性时，this 也应该相应的变为底层 const 属性，不允许修改所指向对象的值。具体的，当成员函数有 const 属性时，隐式定义的 this 指针是一个指向常量的指针。此时我们不可以通过 this 指针修改任何成员变量。而带有 const 修饰的函数称为常量成员函数。

## 86. 类作用域

类本身就是一个作用域。类的成员函数的定义嵌套在类的作用域之内。这也解释了，为什么当我们在类外定义函数时，需要在函数名前面加上 `类名::`，就是为了告诉编译器这个函数的作用域是属于这个类的。我们知道类内的函数都是隐式 inline 的，不过对于在类外定义的函数，该成员函数默认情况下不是 inline 的。

----

编译器分两步处理类：

* 首先编译成员的声明
* 直到类完全可见时才轮到成员函数体。

也即，编译器处理完类中的全部声明后才会处理成员函数的定义。因此成员函数体可以随用使用类中的其他成员（变量和函数）而无需在意这些成员出现的次序。

----

不过我们也可以发现一个事实，那就是返回类型出现在类作用域之前，所以返回类型实际上是在类作用域之外的。因此如果我们的返回类型需要使用类作用域内的类型成员，需要使用作用域运算符。例如：

``` c++
struct Foo {
public:
    typedef vector<int> vi_t;
    vi_t get();
private:
    vi_t vec;
};

// 返回类型位于类作用域之外,需要加上类名::
Foo::vi_t Foo::get() {
    // 函数体位于作用域之内,无需加上类名::
    return vi_t();
}

int main() 
{
    Foo f;
    Foo::vi_t vec = f.get();
    for(int i = 0; i < 4; i ++ )   vec.push_back(i);
    for(auto &x : vec)  cout << x << endl;
    return 0;
}
```

----

然后就是要注意，在类中也可以使用类定义之前的变量。特殊的，对于在类的外部定义的成员函数，还需要考虑在成员函数定义之前的全局作用域中的声明。

## 87. 执行输出任务的函数

一般来说，执行输出任务的函数应该尽量减少对格式的控制，例如自定义的输出语句不应该负责换行，这样可以确保由用户代码来决定是否换行。

## 88. `[*]`类成员在内存中的存储方式 

``` C++
class Foo {
public:
    void printA() {
        cout << "printA" << endl;
    }
    virtual void printB() {
        cout << "printB" << endl;
    }
};

int main() 
{
    Foo *f = nullptr;
    f->printA();
    f->printB();
    return 0;
}
```

问题：以上代码的输出结果是什么？

答案是输出“printA”后，程序崩溃。类中包括成员变量和成员函数。new出来的只是成员变量，成员函数始终存在，所以如果成员函数未使用任何成员变量的话，不管是不是static的，都能正常工作。

printB()为虚函数，虚函数表指针存在类的对象中，此处类对象未实例化，所以无法获得虚函数表指针，从而无法获得printB()函数的指针，无法运行printB()函数。

----

 C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。

---

静态成员函数和非静态成员函数的区别：

静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区的，因而可以说它们都是属于类的，但是类为什么只能直接调用静态类成员函数，而非静态类成员函数(即使函数没有参数)只有类对象才能调用呢？

原因是：

当类的非静态类成员函数的参数中包括类的成员变量时，此时还会包含一个指向类对象的指针类型参数(即this指针)，此时只有类对象才能调用非静态类成员函数(此时this指针有实值)。

需要说明，不论成员函数在类内定义还是在类外定义，成员函数的代码段都用同一种方式存储。不要将成员函数的这种存储方式和inline(内联)函数的概念混淆。不要误以为用inline声明(或默认为inline)的成员函数，其代码段占用对象的存储空间，而不用inline声明的成员函数，其代码段不占用对象的存储空间。不论是否用inline声明(或默认为inline)，成员函数的代码段都不占用对象的存储空间。用inline声明的作用是在调用该函数时，将函数的代码段复制插人到函数调用点，而若不用inline声明，在调用该函数时，流程转去函数代码段的入口地址，在执行完该函数代码段后，流程返回函数调用点。inline与成员函数是否占用对象的存储空间无关，它们不属于同一个问題，不应搞混。

## 89. ctor和const

不同于其它函数，ctor不能被声明为const。当我们创建类的一个const对象时，知道ctor完成初始化过程，对象才真正获得其“常量”属性。因此，ctor在const对象的构造过程中可以向其写值。

## 90. ctor初始值列表

### 1. 性能更高

为什么说推荐使用初始值列表进行初始化，它比在构造函数体内初始化更快？

这是因为**对于没有类内初始值的变量，如果在初始值列表中没有对其初始化，那么初始值列表会对其<font color=blue>默认初始化</font>。**因此说当构造函数体开始执行时，所有成员变量都得到了初始化，而此时构造函数体所谓的“初始化”实际上是再进行赋值操作。这意味着成员变量先再初始值列表被默认构造，然后在构造函数体内又被重新赋值，等于是做了两次工作。例如：

``` c++
class Bar {
public:
    Bar() { cout << "Bar::ctor" << endl; }
    Bar(int x) { cout << "Bar::ctor(int)" << endl; }
};

class Foo {
public:
    Foo() { cout << "Foo:ctor" << endl; }
    Foo(int x) { b = Bar(10); cout << "Foo::ctor(int)" << endl; }
private:
    Bar b;
};

int main() 
{
    Foo b(1);
    return 0;
}
```

输出为：

``` c++
./bin/app 
Bar::ctor
Bar::ctor(int)
Foo::ctor(int)
```

对于 Foo 的构造函数 `Foo(int x)`，它实际上相当于：

``` c++
Foo(int x) : x(0), b(Bar())
{ b = Bar(10); cout << "Foo::ctor(int)" << endl; }
```

可见在初始值列表对 `b` 进行了一次初始化。

### 2. 不可复制对象

对于不可复制对象，例如 const 对象，引用等，我们只能在初始值列表中对其初始化吗，而不能在函数体中赋值。

### 3. 初始化顺序

构造函数的初始值列表只说明yongyu初始化成员的值，而不限定初始化的具体执行顺序。事实上，成员的初始化顺序与它们在类定义中从出现的顺序一致。可以看下面的例子：

``` c++
struct A {
    A() {
        cout << "A::ctor" << endl;
    }
    A(const A &a) {
        cout << "A::copy ctor" << endl;
    }
};

struct B {
    B() {
        cout << "B::ctor" << endl;
    }
    B(const B &b) {
        cout << "B::copy ctor" << endl;
    }
};

struct C {
public:
    C(A _a = A(), B _b = B()) : b(_b), a(_a) {}
private:
    A a;
    B b;
};
```

输出：

``` shell
B::ctor
A::ctor
A::copy ctor
B::copy ctor
```

尽管我们在初始化列表中先初始化 `b`，但 `a` 依然先进行了初始化。

因此说，最好令构造函数的初始值的顺序与成员的声明顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其它成员，这样做的好处是可以不必考虑成员的初始化顺序。例如 `X(int val) : i(val), j(val)` 要优于 `X(int val) : i(val), j(i)`。 

## 91. 类的基本思想

类的基本思想是“数据抽象”。

所谓数据抽象，就是说通过将复杂的数据结构隐藏起来，向外界提供简单一致的接口，使开发者专注于如何使用这些数据，而不是关心于它们是如何实现的。 

数据抽象主要通过两种方式实现：

1. 抽象数据类型：抽象数据类型是一种理论上的概念，定义了某种数据结构以及可对该数据结构执行的操作，但不涉及这些操作的具体实现。例如，堆栈（Stack）或队列（Queue）就是抽象数据类型，定义了插入、删除、访问等操作，而具体的实现方式可能是基于数组或链表。<FONT COLOR=BLUE>定义数据成员和函数成员的能力</FONT>
2. 封装：封装是面向对象编程中的一个核心原则，它将数据和操作封装在对象中，并提供公共接口（如方法）供外部访问，但隐藏了对象内部的实现细节。用户只需要知道如何调用这些接口，而不需要了解内部是如何实现的。<FONT COLOR=BLUE>保护类的成员不被随意访问的能力</FONT>

如果我们将类的实现细节设置为 public，那么这并不算是一种封装。因为用户可以自行使用类中的变量和函数实现自己想要的需求，从形式上看类的实现细节是公开的，可修改的，自然谈不上封装了。

## 92. 友元的声明

友元声明只能出现在 class 内部，但是在 class 中的那个位置并无要求。并且由于友元函数不是类的成员，因此也不受它所在区域访问控制级别的约束。不过一般来说，最好在类定义的开头或结束位置集中声明友元。

尽管我们实际上可以在 class 内部定义友元函数，但友元函数在 class 内部的声明仅仅指定了<font color=blue>访问的权限</font>，而非一个传统意义上的函数声明。也可以这么理解，在 class 内部的友元声明，仅仅声明了这是一个友元，而不是声明了这是一个函数。

> 在 class 内部定义的友元函数也是隐式 inline 的。 

因此我们有必要在类的外部专门对函数进行一次声明。虽然许多编译器并未强制要求友元函数必须在使用之前在类的外部声明，但最好还是这样做，因为即使更换了一个强制要求这样做的编译器，也不必修改代码。我们可以看下面的代码：

``` c++
struct Foo {
    friend void f() { cout << "f" << endl; }
    void g();
};

 // void f();

void Foo::g() {
    f(); // 编译器会报错，找不到f()的定义
    cout << "g" << endl;
}
```

我们必须在类的外部声明友元函数 `f()` 才能使用它。

除了将一个非成员函数声明为友元之外，我们也可以把一个类声明为友元，也可以把其他类的成员函数声明为友元。

最后，友元不会被继承或传递。

## 93. 类型成员

所谓类型成员，就是在 class 中定义的类型别名。由于它是类成员，因此它也受到访问级别的限制。我们可以直接使用作用域运算符访问类型成员，而无需使用对象访问。

类型成员必须先定义后使用。我们知道编译器处理类时会先处理所有声明再处理所有定义（函数体），但要注意对于函数来说，返回类型以及参数类型并不属于定义的一部分，它们属于函数的声明。而编译器在处理声明时是按顺序执行的。因此如果函数声明用到了类型成员而类型成员在函数声明之后，就会导致函数声明看不到类型成员的声明。因此推荐把类型成员放到类的开头。

``` c++
struct Foo {
public:
    // 返回类型和参数类型会报错
    // 函数体内的类型标识符不会报错
    vi_t get(vi_t vec) {
        vi_t vec;
    }
    typedef vector<int> vi_t;
private:
    vi_t vec;  
};
```

## 94. 可变数据成员

一个可变数据成员永远不会是 const ，即使它是 const 对象的成员。通过 `mutable` 关键字将一个数据成员声明为可变数据成员。

## 95. Most Vexing Parse

在 C++ 中，声明 `A a();` 这样的语法**并不会创建一个对象**，相反，它被解释为一个**函数声明**，这是 C++ 语法的一个常见陷阱，通常被称为**最令人困惑的解析**（**Most Vexing Parse**）。

## 96. 从const成员函数返回*this

对于 const 成员函数，隐式的 this 指针是一个常量指针，此时如果我们想要返回对象的引用，必须返回常量引用。

## 97. 对于成员函数中的公共代码使用私有功能函数

即，如果多个成员函数中有公共代码，那么应该将这部分代码拿出来放到一个访问级别为 `private` 的函数当中。由于 class 内部的成员函数隐式 inline 的特性，调用私有功能函数并不会带来额外的函数调用开销。

## 98. 成员函数中名字的查找顺序

1. 在成员函数体内查找
2. 在类内查找
3. 在成员函数定义之前的作用域内查找

## 99. 委托构造函数

C++11 新标准拓展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数。一个委托构造函数使用它所属类的其它构造函数执行自己的部分或全部初始化过程。例如：

``` c++
struct A {
    A(int _a, int _b, int _c) 
        : a(_a), b(_b), c(_c) 
        {}
    A(int _a) : A(_a, 0, 0) {}  // 委托三参数的构造函数
    int a, b, c;
};
```

## 100. 默认初始化和值初始化

[值初始化](https://en.cppreference.com/w/cpp/language/value_initialization)是在以空初始化器构造对象时进行的初始化。它的效果是零初始化，特殊的对于类对象，如果值初始化调用的默认构造函数是用户自定义的，那么执行默认初始化。否则执行零初始化。

## 101. class对象值初始化BUG

看下面的代码：

``` c++

class Foo {
public:
    Foo() {  }
    Foo(int _a, int _b, int _c) 
        : a(_a), b(_b), c(_c) 
        {
            cout << "ctor::iii" << endl;
        }
public:
    short a;
    int b;
    double c;
};

Foo global;

int main() 
{
    static Foo static_local;
    Foo local;
    Foo local_vaue{};
    cout << global.a << ' ' << global.b << ' ' << global.c << endl;
    cout << static_local.a << ' ' << static_local.b << ' ' << static_local.c << endl;
    cout << local_vaue.a << ' ' << local_vaue.b << ' ' << local_vaue.c << endl;
    cout << local.a << ' ' << local.b << ' ' << local.c << endl;
    return 0;
}
```

输出结果为：

``` shell
0 0 0
0 0 0
27751 779647075 2.11653e+214
27751 779647075 3.64265e-319
```

我们发现 `local` 对象和 `local_value` 对象的值是无意义的，对于 `local` 对象的结果我们可以预料，但在第 `100` 节我们讲过，值初始化的对象，基本类型的值应该为 `0` 才对，为什么这里是无意义的值呢？

我们修改一下代码：

``` c++
#include "header.h"

using namespace std;

class Foo {
public:
    // Foo() {  }
    // Foo(int _a, int _b, int _c) 
    //     : a(_a), b(_b), c(_c) 
    //     {
    //         cout << "ctor::iii" << endl;
    //     }
public:
    short a;
    int b;
    double c;
};

Foo global;

int main() 
{
    static Foo static_local;
    Foo local;
    Foo local_vaue{};
    cout << global.a << ' ' << global.b << ' ' << global.c << endl;
    cout << static_local.a << ' ' << static_local.b << ' ' << static_local.c << endl;
    cout << local_vaue.a << ' ' << local_vaue.b << ' ' << local_vaue.c << endl;
    cout << local.a << ' ' << local.b << ' ' << local.c << endl;
    return 0;
}
```

注释掉我们自己定义的两个构造函数，再次观察结果：

``` c++
0 0 0
0 0 0
0 0 0
27751 779647075 2.11653e+214
```

可以发现，此时 `local_value` 对象的值是正常的，全部为 `0`。

我们再次修改代码：

``` c++
class Foo {
public:
    Foo() = default;
    Foo(int _a, int _b, int _c) 
        : a(_a), b(_b), c(_c) 
        {
            cout << "ctor::iii" << endl;
        }
public:
    short a;
    int b;
    double c;
};

Foo global;

int main() 
{
    static Foo static_local;
    Foo local;
    Foo local_vaue{};
    cout << global.a << ' ' << global.b << ' ' << global.c << endl;
    cout << static_local.a << ' ' << static_local.b << ' ' << static_local.c << endl;
    cout << local_vaue.a << ' ' << local_vaue.b << ' ' << local_vaue.c << endl;
    cout << local.a << ' ' << local.b << ' ' << local.c << endl;
    return 0;
}
```

将我们原本自己定义的默认构造函数 `Foo() {}` 修改为系统为我们提供的默认构造函数 `Foo() = default;`

再次观察结果：

``` C++
0 0 0
0 0 0
0 0 0
27751 779647075 3.64265e-319
```

可以发现，此时 `local_value` 对象的值也是正确的。

其实通过对比也可以发现，问题就出现在我们自定义的默认构造函数 `Foo(){}` 上，它没有对我们的基本类型对象进行正确的初始化。

按理来说，我们自定义的 `Foo(){}` 和 `=default` 生成的构造函数应该相同啊？

---

好了，破案了。

C++ Prime 7.5.1 节说到，如果我们没有在初始值列表显示的初始化成员变量的话，则该成员将在构造函数体之前执行“默认初始化”。而对于局部变量，基础类型在默认初始化下的值是未定义的。因此这里的 `local_value` 对象输出的值是未定义的。

所以说，停止你的UB行为！请你在构造函数中初始化成员变量，而不是依赖于编译器。

## 102. 隐式的类类型转换

能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。这类构造函数又称为“转换构造函数”。

但要注意，编译器只会自动执行一步类类型转换（内置类型转换除外）。例如：

``` c++
struct Foo {
    Foo() = default;
    Foo(string _x) : x(_x) {}
    string x;
};

void func(Foo f)
{
    cout << f.x << endl;
}

int main() 
{
    // func("hello");   // 需要先从const char*转换为string再从string转换为Foo
    func(string("hello"));
    return 0;
}
```

我们可以通过关键字 `explicit` 禁止这种自动类型转换。只允许在类内声明使用 `explicit`  关键字。

## 103. aggregate class

聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。聚合类的定义：

* 所有成员都是 public 的
* 没有任何构造函数
* 没有类内初始值
* 没有基类，没有virtual函数

从形式上看，聚合类真的就是“类型的聚合”。

聚合类型的主要特点是它允许你使用聚合初始化，即我们可以通过一个花括号括起来的成员初始值列表来初始化聚合类的数据成员，注意初始值的顺序要与类中声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。

从定义上看，聚合类型可以有普通成员函数，但实际应用当中一般不会使用普通成员函数？

## 104. 字面值常量类

数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但他符合下面要求，则它也是一个字面值常量类：

* 数据成员必须是字面值类型
* 类必须至少含有一个 constexpr 构造函数
* 类必须使用析构函数的默认定义
* 如果一个数据成员含有类内初始值，则内置数据类型的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的 constepxr 构造函数

> 数以字面值常量类并不要求所有成员都是public

constexpr 成员函数是隐式 const 的。

虽然我们不能定义 const 构造函数，但是可以将构造函数声明为 constexpr 。constexpr 构造函数可以声明为 `=default` 或 `=delete`。否则，constexpr 构造函数的函数体一般为空，这是因为 constepxr 函数只允许在返回语句进行计算，而构造函数没有返回语句。

## 105. 类的静态成员

首先，静态成员是类成员，它是属于类的。因此和其它成员一样，静态成员也有访问权限限制，我们可以将其声明为 public 或 private。

虽然静态成员不属于类的某个对象，但我们依然可以通过类的对象、指针或引用来访问静态成员。在成员函数中也无需作用域运算符就能访问静态成员。

也正因为静态成员不属于类对象而是属于类，因此有以下特性：

* 静态成员没有 this 指针。也不能将静态成员函数声明为 const，因此 const 函数的含义是将 this 指针修饰为 const。
* 静态数据成员并不是在创建对象的时候初始化的，这意味着它不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。
* 静态成员只能使用静态成员，而不能使用非静态成员。因为当我们使用非静态成员时，编译器需要知道你是在操作那个具体的对象，如果没有指定对象而直接访问非静态成员，编译器无法知道你想操作的是那个对象的成员。

``` C++
struct Foo {
    static int val;
    static int sret(int x);
    const static int i = 1024;

    int ret(int x) {
        return x;
    }
};


int Foo::sret(int x) {
    return i - x;
}
int Foo::val = sret(10);

int main() 
{
    cout << Foo::val << endl;
    return 0;
}
```

在上面的代码中，我们利用静态成员函数 `sret` 来初始化静态成员变量 `val`。和函数的类外定义一样，主要出现了 `Foo::`，编译器就知道后面内容的作用域是 `class Foo`。

通常情况下，类的静态成员不应该在类的内部初始化。而然，我们可以为静态常量成员提供类内初始值。在 C++ 中，**`const static`** 的整型变量（如 `int`）可以直接在类内部进行初始化，而对于非整型的静态常量（如 `double` 或 `float`），则需要使用 **`constexpr`** 。

和友元一样，即使我们在类内部定义了静态成员，也应该在类外部声明一下。

和其它对象一样，静态数据成员也只能初始化一次，因此最好将静态数据成员的定义与其它非内联函数的定义放在同一个文件中。

和 explicit 关键字一样，static 关键字只能出现在 class 内部声明，在 class 外部定义时无需重复 static 关键字。

----

由于静态成员独立于任何对象。因此，在某些非静态成员可能非法的场合，静态成员却可以正常使用：

1. 静态数据成员可以是不完全类型，非静态数据成员想要实现这个效果只能使用指针或引用

``` c++
struct Foo {
    static Foo sf;
    Foo *pf;
    Foo &rf; // 虽然语法通过但编译错误。因为引用必须在构造函数中进行初始化；而不能调用构造函数创建一个Foo对象就无法初始化Foo的引用。死锁了属于是。
    // Foo f; // Foo必须是完全类型
};
```

2. 静态数据成员可以作为默认实参，非静态数据成员在构造函数执行时还未初始化，因此不能作为默认实参

``` c++
struct Foo {
    Foo(int _max = MAX) : cur(_max) {}
    int cur;
    static const int MAX = 1024;
};
```

## 106. 不完全类型

已经声明但是尚未定义的类型。不完全类型不能用于定义变量或者类的成员，但是不完全类型定义指针或引用是合法的。

## 107. 合成默认构造函数

如果类内没有显示声明一个构造函数，编译器会合成一个默认构造函数。该构造函数会检查类的数据成员，如果有类内初始值就用它执行初始化操作，否则就执行默认初始化。

## 108. `[*]`值初始化

```c++
class Foo {
public:
    Foo() {}    // 注释掉呢？
    int x, y;
};

int main() 
{
    vector<Foo> a(10);
    for(int i = 0; i < 10; i ++ ) {
        cout << a[i].x - a[i].y << endl;
    }
    Foo b;
    cout << b.x << ' ' << b.y << endl;
    Foo c{};
    cout << c.x << ' ' << c.y << endl;
    return 0;
}

```

值初始化并不总是意味着0初始化

## 109. operator +=

和 `operator=` 一样，`operator+=` 也可以连加，因此它也需要返回左值。

``` C++
int a = 1, b = 2, c = 3;
a += b += c += 3;   
// c = 6
// a += b += 6
// b = 8
// a += 8
// a = 9
cout << a << ' ' << b << ' ' << c << endl;
```



## 110. `[*]`动态生存期的资源的类

程序使用动态内存出于以下三种原因之一：

1. 程序不知道自己需要使用多少对象：vector，string
2. 程序不知道所需对象的准确类型：基类指针？
3. 程序需要在多个对象间共享数据：指针

## 111. 为什么不需要检查下标是否大于0？

``` c++
class String {
private:
    std::shared_ptr<vector<string>> data;
    void check(size_type i, const string &msg) const {
        if(i >= data->size()) {
            throw(out_of_range(msg));
        }
    }
};
```

在上面的代码中，check 函数为何没有检查下标是否为负数?

因此 check 是我们的私有成员函数，它只会被 String 的成员函数调用而不会被用户调用。因此，我们可以很容器的确保传递给它的 i 的值符合要求，而不必进行检查。

## 112. 对const char* 的比较

``` C++
"hello" == "world";
```

上面的比较不是 string 之间的比较，而是两个指向 const char* 的指针的比较。

## 113. 引用



----

引用的意义：

> 1. 引用可以看作某个变量的“别名”，作为某个变量的别名而存在，因此在一些场合可以代替指针。
> 2. 引用相对于指针来说具有更好的可读性和实用性，能起到指针的部分作用，但是比指针安全。
> 3. 引用在c++里面可以说是一把利器，引用用的好的话可以写出非常精妙的程序。



引用的本质：

> 1. 引用在C++中的内部实现是一个**常指针**。
>
>    `Type& name  <=> Type* const name`
>
> 2. C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。
>
> 3. 从使用的角度，引用会让人误会其只是一个别名，没有自己的存储空间。这是C++为了实用性而做出的细节隐藏。



我们在写操作符重载的时候都是用引用作为函数的返回值，我们来看一段代码：

``` c++

int temp;
int fun1()
{
    temp = 10;
    return temp;
}

int& fun2()
{
    temp = 10;
    return temp;
}

int main() 
{
    int a = 0, b = 0;
    // 1. 返回函数的普通类型
    a = fun1();
    // 2. 返回函数的引用
    b = fun2();
    // 3. 返回函数的引用去初始化一个新的引用
    int &c = fun2();

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;

    return 0;
}
// 编译结果：a = 10   b = 10   c = 10
```

1. **返回函数的普通类型**

   返回普通类型对象其实是返回这个对象的拷贝，c++其实会创建一个临时变量，这个临时变量被隐藏了，它会把temp的值拷贝给这个临时变量，当执行语句“a = fun1()；”的时候就会把临时变量的值再拷贝给a，假设这个临时变量是t，相当于做了这两个赋值的步骤：t = temp; a = t; 

2. **返回函数的引用**

   返回引用实际返回的是一个指向返回值的隐式指针，在内存中不会产生副本，是直接将temp拷贝给a，这样就避免产生临时变量，相比返回普通类型的执行效率更高，而且这个返回引用的函数也可以作为赋值运算符的左操作数，但是这时候需要**注意以下两个问题**：

   

   ​	1). 千万别返回局部对象的引用，当函数执行完局部对象也就被销毁，栈空间被释放，从而返回的地址已经不存在，导致后面执行出错。

   

   ​	2).  返回堆区对象的引用，这种情况要特别注意，这时候返回函数的引用是作为一个临时变量出现，没有将它赋值给一个实际存在的变量，那么这个堆区对象的内存空间就没有释放，可能造成内存泄漏。有人说这样做是非法的？其实不是绝对的，只能说这种编程习惯很不好，这样做只是容易造成内存泄漏，只是我们要记住，我们在申请堆内存以后必须记得去释放这块内存。

3. **返回函数的引用去初始化一个新的引用**

   这个和前面一样，都是不会产生副本，但是现在是用返回值去初始化一个引用声明c，也就是说这时候变成了变量temp的别名，在c的生命周期内temp是一直有效的，这样做完全可以。

## 114. 对常量成员函数的误解

const 修饰的成员函数就是常量成员函数。

> 误认为，const 对象只能调用普通成员函数；非 const 对象只能调用 const 成员函数。

当你定义一个 `const` 成员函数时，编译器保证该函数**不会修改**对象的成员变量（除非它们被标记为 `mutable`），并且它可以被任何对象调用，无论是 `const` 还是非 `const` 对象。

* 对于非`const`对象，既可以调用`const`成员函数，也可以调用非`const`成员函数。
* 对于`const`对象，只能调用`const`成员函数，因为它们保证不会修改对象的状态。

例如对于下面的类和函数调用：

``` c++
class Foo {
public:
    void func() const {
        std::cout << "const" << std::endl;
    }
    void func() {
        std::cout << "non-const" << std::endl;
    }
};

void test()
{
    Foo f;
    const Foo cf;
    f.func(); 
    cf.func();  
}
```

（1）当 const 成员函数和非 const 成员函数都存在时：

* const 对象调用 const 成员函数
* 非 const 对象调用非 const 成员函数。

（2）当只有 const 成员函数时：

* const 对象调用 const 成员函数
* 非 const 对象调用 const 成员函数。

（3）当只有非 const 成员函数时：

* 非 const 对象调用非 const 成员函数
* const 对象调用失败

虽然通过**非`const`对象调用`const`成员函数**可能看起来“不安全”，但实际上，在 C++ 的设计中，这是有其合理性和安全性的。

> 核心原理是，const修饰于函数只保证在该函数体中不会修改类成员。至于你通过其它形式修改了类成员，这就与const无关了。
>
> 例如我们可以通过返回引用这种形式来间接修改对象的值，但我们并没有在该函数内修改，const 的修饰依然有效。

1. **`const`成员函数的核心作用**：

   * `const`成员函数的定义是**不会修改对象的成员变量**（除非这些变量是 `mutable`）。因此，即使从非`const`对象调用了`const`成员函数，编译器也会确保这个函数**不会改变对象的状态**。这是它的安全保障。

   例如：

   ```
   cpp复制代码class Foo {
   public:
       int getVal() const {
           return val;
       }
   private:
       int val = 10;
   };
   ```

   在这里，`getVal()` 是一个 `const` 成员函数，不管你是在 `const` 还是非`const`对象上调用它，它都**无法修改**对象的内部状态。这是由 `const` 成员函数的性质决定的。因此它是安全的。

2. **非`const`对象调用`const`成员函数的合理性**：

   * 对于非`const`对象，你可以调用任何成员函数，包括 `const` 和非 `const` 成员函数。因为非`const`对象的状态是可以修改的，调用 `const` 成员函数是安全的——即使你不打算修改对象状态，还是可以访问它的属性。

   **示例**：

   ```
   cpp复制代码class Foo {
   public:
       int getVal() const { return val; }
       void setVal(int v) { val = v; }
   private:
       int val;
   };
   
   int main() {
       Foo f;
       f.getVal();  // 调用 const 成员函数，没有修改对象
       f.setVal(20); // 调用非 const 成员函数，修改了对象
   }
   ```

   在这个例子中，`f` 是非`const`对象。你可以调用 `getVal()` 来读取对象的值，调用 `setVal()` 来修改对象的状态。这完全是安全的，因为 C++ 保证 `getVal()` 不会改变 `f` 的状态。

为什么不能反过来：**`const`对象不能调用非`const`成员函数**？

* `const`对象的状态应该保持不可变。允许它调用非`const`成员函数会破坏这个语义，因为非`const`成员函数可能会改变对象的状态。这就是为什么 C++ 明确规定：**`const`对象只能调用`const`成员函数**。

  ```
  cpp复制代码const Foo cf;
  cf.setVal(20);  // 错误：不能在 const 对象上调用非 const 成员函数
  ```

  如果允许 `const`对象调用非`const`成员函数，那就意味着对象状态有可能被修改，这将导致不安全的行为。因此，C++ 编译器会阻止这种情况发生。

## 115. 指针的比较

由于指针保存的是地址，因此在 C++ 中，比较指针，即两个地址是无意义的，产生的行为是未定义的。

如果我们确实想比较指针，可以通过标注库定义的函数对象例如 `less<int>()`，这些类模板对指针的比较是定义良好的。

## 116. static成员

为什么类外定义静态成员时不需要再次使用 `static`？

1. **类内部的声明已经表明是静态的**： 当你在类内部声明成员时，`static` 关键字已经告知编译器这是一个静态成员。静态成员在整个类中是唯一的，并且在所有实例中共享。由于你已经通过类内声明指定它是静态的，在类外定义时不需要再次告知编译器它是静态的。编译器会根据类内的声明来处理。
2. **类外定义的重点是完成初始化**： 类外定义静态成员的目的是对静态变量进行**初始化**，而不是再次声明它的属性。在类内声明的静态成员只是在类的范围内声明了存在性，但它并未被真正分配空间或初始化。类外的定义就是完成这些操作，所以无需再使用 `static` 关键字。

## 117. 定义时使用inline

在编程中，`inline` 关键字用于提示编译器将函数体内联（即在调用点展开函数代码，而不是进行常规的函数调用）。在 C++ 中，`inline` 通常只能在函数的定义时使用，原因可以归结为以下几点：

1. **编译器需要看到函数的完整定义**：为了将函数进行内联，编译器必须看到函数的完整定义（即函数体）。如果仅在函数声明处指定 `inline`，编译器无法对其进行展开操作，因为它不知道函数的具体实现。
2. **内联的目的是减少函数调用的开销**：内联的目标是减少函数调用的开销，通过直接展开函数体的代码来实现。函数声明本身只是函数的接口，没有具体的实现细节，因此无法进行内联优化。
3. **避免重复定义问题**：如果在多个文件中都内联同一个函数，且没有在定义时声明为 `inline`，就可能导致链接时的重复定义错误。`inline` 函数的定义通常会放在头文件中，并在多个编译单元中使用，因此 `inline` 的含义不仅是内联优化，同时也允许函数在多个编译单元中定义而不会导致重复定义错误。
4. **内联的指示作用**：`inline` 只是对编译器的建议，编译器可以选择忽略它。为了内联优化，编译器需要尽早获取函数的完整实现，这样它可以决定是否执行内联。而在声明时指定 `inline` 并没有实质作用，因为函数实现还没有被提供。

因此，`inline` 只能在函数定义时指定，而不能在声明时单独使用，这是因为编译器需要完整的实现来做内联展开和相关优化。

### 1. **普通函数的重复定义问题**

通常，函数的定义放在某个源文件中（例如 `myfile.cpp`），而函数的声明则可以放在头文件中（例如 `myfile.h`）。如果其他源文件（如 `main.cpp`）需要使用这个函数，它们可以通过 `#include "myfile.h"` 来获取声明，而链接器在链接阶段将会把 `myfile.cpp` 中的函数定义与 `main.cpp` 中的调用链接起来。

```C++
// myfile.h
void myFunction();  // 声明

// myfile.cpp
void myFunction() { // 定义
    // 函数体
}

// main.cpp
#include "myfile.h"

int main() {
    myFunction();  // 调用
    return 0;
}
```

在上面的例子中，函数定义仅出现在一个源文件中 (`myfile.cpp`)，因此不会有重复定义的问题。但如果我们把函数的定义放在头文件中，并且这个头文件在多个源文件中被包含，问题就出现了。

例如：

```C++
// myfile.h
void myFunction() {  // 函数定义
    // 函数体
}

// main.cpp
#include "myfile.h"  // 包含函数定义
int main() {
    myFunction();  // 调用
    return 0;
}

// other.cpp
#include "myfile.h"  // 另一个源文件也包含了相同的定义
```

在这种情况下，`myFunction` 在 `main.cpp` 和 `other.cpp` 中都被定义了一次。当编译器分别编译这两个源文件时，它们都会生成 `myFunction` 的定义。而在链接阶段，链接器会检测到 `myFunction` 的多个定义，从而报错，通常称为“重复定义错误”：

```C++
multiple definition of `myFunction`
```

### 2. **内联函数的重复定义处理**

`inline` 函数的定义通常放在头文件中，并且可以被多个源文件包含和使用。内联函数的一个特殊性在于，尽管它可能在多个源文件中定义，但在链接时不会引发重复定义错误。之所以如此，是因为 C++ 对 `inline` 函数有一个特别的处理机制。

* **定义可以出现在多个编译单元中**：当一个函数被声明为 `inline` 时，它的定义可以出现在多个编译单元中，而不会引发重复定义问题。编译器会确保即使多个编译单元都包含了相同的 `inline` 函数定义，链接器也只会在最终生成的可执行文件中保留一个定义。

  例如：

  ```C++
  // myfile.h
  inline void myFunction() {  // inline 函数定义
      // 函数体
  }
  
  // main.cpp
  #include "myfile.h"
  int main() {
      myFunction();  // 调用
      return 0;
  }
  
  // other.cpp
  #include "myfile.h"  // 同样包含
  ```

* **链接器的特别处理**：编译器在处理 `inline` 函数时，会在每个包含该函数定义的编译单元中生成其定义，但链接器在最终链接阶段会把这些重复的定义合并为一个。这是 C++ 的 `inline` 关键字的特殊语义，使得你可以在头文件中定义内联函数而不会担心重复定义错误。

## 118. 释放空指针

注意释放空指针和释放一块已经被释放了的内存的区别：一块内存已经被释放，但其它仍然指向它的指针不是空指针，它们仍然指向该内存。

C++ 可以delete 空指针，因为 delete 会对指针进行检查，当发现指针为 NULL 时什么也不做。同样的，在 C 中，我们也可以 free 空指针。

``` C++
int *p = new int(10);
int *q = p;
delete p;
// q不是空指针,因此这里 double delete
delete q;

/////////////////////////////////////////////////////////
	
int *p = new int(10);
int *q = p;
delete p;
// q是空指针,可以delete空指针
q = nullptr;
delete q;
```

delete 和 free 设计成对空指针安全有很多好处：

1. 不用程序员手动检查指针是否为空
2. 与构造函数对称：构造函数可以返回一个 nullptr 指针
3. 提供程序的健壮性：当我们将指针置为 NULL 之后，delete 它是没有效果的
4. 标准库的要求：C++ 标准要求 delete 一个空指针是没有任何效果的

## 119. unique_ptr传入删除器为什么要指定类型

### 引言

在回答这个问题之前，先看一段代码：
``` C++
template<typename T>
void deletor(T *p)
{
    delete p;
}

template<typename T>
void test()
{
    unique_ptr<T> up(new T(10));
    cout << sizeof(up) << endl; // 8
    unique_ptr<T, decltype(&deletor<T>)> up2(new T(10), deletor<T>);
    cout << sizeof(up2) << endl; // 16

    shared_ptr<T> sp(new T(10));
    cout << sizeof(sp) << endl; // 16
    shared_ptr<T> sp2(new T(10), deletor<T>);
    cout << sizeof(sp2) << endl; // 16
}

int main() 
{ 
    test<double>();
    test<int>();  
    test<char>();
    return 0;
}
```

无论我们指定底层数据是 char、int 还是 double 类型，上面四个 sizeof 的结果都是一样的。

在不指定删除器的情况下，unique_ptr 的大小为 8，而 shared_ptr 的大小为 16；指定了删除器之后，unique_ptr 的大小为 16，shared_ptr 的大小为 16。可以发现，在不指定删除器时，unique_ptr 的大小和原始的大小一样大。之所以会有这种差异，主要是因为 C++ 针对 unique_ptr 和 shared_ptr 的设计哲学（理念）不同：**unique_ptr 是轻量级的智能指针，而 shared_ptr 是为共享而设计的一个较为复杂的智能指针。**

### 参考

https://www.cnblogs.com/fuzhe1989/p/7763623.html

* [Why does unique_ptr take two template parameters when shared_ptr only takes one?](http://stackoverflow.com/questions/21355037/why-does-unique-ptr-take-two-template-parameters-when-shared-ptr-only-takes-one)
* [Why does unique_ptr have the deleter as a type parameter while shared_ptr doesn't?](http://stackoverflow.com/questions/6829576/why-does-unique-ptr-have-the-deleter-as-a-type-parameter-while-shared-ptr-doesn)

### 总结

总而言之，unique_ptr 出于时间和空间的考虑，默认在它的内部是没有成员变量来保存构造器对象的。unique_ptr 的默认构造器对象是一个空基类，它的大小被优化为 0。如果我们想自己指定构造器对象，就需要修改 unique_ptr 继承的这个基类，看代码：

``` c++
template <class _Tp, class _Dp = default_delete<_Tp> >
class unique_ptr
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;
    ...
};
/////////////////////////////////////////////////////
template <class _T1, class _T2>
class __compressed_pair
    : private __libcpp_compressed_pair_imp<_T1, _T2> {
    ...
};
///////////////////////////////////////////////////////
// 特化版本
// _T1就是pointer
// _T2就是deleter_type
template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 0>
{
/*该版本没有做任何优化直接将 _T1 和 _T2 作为私有成员变量 __first_ 和 __second_。这种情况适用于 _T1 和 _T2 都是非空对象时，它们正常存储在类的成员变量中。
*/
private:
    _T1 __first_;
    _T2 __second_;
    ...
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 1>
    : private _T1
{
/*
这个版本通过私有继承 _T1 来优化存储。这里利用了空基类优化（EBO）：如果 _T1 是一个空类，那么它在类的对象实例中将不会占用额外的空间，因为 C++ 允许空基类不占空间。因此，这个版本可以减少存储的空间开销。

这种特化会在 _T1 是一个空类型（如 std::allocator 这样的空类）时被使用，使得 _T1 不占用空间，从而节省内存。
*/
private:
    _T2 __second_;
    ...
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 2>
    : private _T2
{
/*
这个版本与前一个类似，但反过来继承了 _T2。如果 _T2 是一个空类，它将不会占用额外的内存空间，而 _T1 则作为成员变量存储。这种特化通常用于 _T2 是空类的情况。
*/
private:
    _T1 __first_;
    ...
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 3>
    : private _T1,
      private _T2
{
/*
这个版本通过同时私有继承 _T1 和 _T2，如果这两个类型都是空类，那么它们都不会占用任何空间。即使只有其中一个是空类，继承的机制仍能减少空间开销。

这是最优化的版本，适用于 _T1 和 _T2 均为空类的情况，通过空基类优化，可以让整个类在内存中占用零空间。
*/
    ...
};
```

unique_ptr 只有一个成员函数 `__ptr__`，它的类型 `__compressed_pair` 继承自 `__libcpp_compressed_pair_imp<_T1, _T2>`，而最终 `__ptr__` 的大小就是由这个类的特化版本决定的。

当我们没有显式指定删除器的类型 `_T2` 时，它是默认的空类，此时我们会 private 继承它，它的大小就被优化为 0 了。但如果我们显式指定它，那么此时继承的 `_T1` 就不是空基类了。它内部需要为删除器分配空间，所以我们在引言中发现在指定删除器之后，unique_ptr 的大小变了。

总而言之：unique_ptr 指定删除的直接原因是，我们需要通过传入的删除器类型去替换空基类类型，由此为删除器对象分配内存空间。而之所以 unique_ptr 默认没有为删除器分配空间，是因为它的设计哲学（理念）—— 在性能上和内置类型的指针相当！对于 shared_ptr，由于我们本身在其内部为删除器对象分配了空间，不需要传入删除器类型来告诉它需要为删除其对象分配空间，所以也就不需要在它的类模板中传入删除器的类型了，不过由于我们没有显式指定删除器类型，所以我们需要在构造函数中进行推导。

``` C++
template <class T> 
class shared_ptr {
public:
    ...
    template <class U, class D> 	
    // 编译器自动推导删除器的类型D
    shared_ptr (U* p, D del);
    ...
};

// 自行传入删除器的类型，默认为default_delete<T>是一个空基类
template <class T, class D = default_delete<T>>
class unique_ptr {
public:
    ...
    unique_ptr (pointer p,
        typename conditional<is_reference<D>::value,D,const D&> del) noexcept;
    ...
};
```

## 120. 为什么shared_ptr不支持管理动态数组

### 1. **`std::shared_ptr` 设计的初衷是管理单个对象**

`std::shared_ptr` 的设计主要是为了管理 **单个对象**，而不是数组。其核心机制基于引用计数，以确保当没有 `std::shared_ptr` 实例再指向托管对象时，才会释放该对象。

管理数组引入了额外的复杂性，果多个 `shared_ptr` 指向同一个数组，引用计数只针对整个数组，而不是单独的数组元素。这种设计会导致一些不便，因为无法对数组的某个元素进行独立管理，只能对整个数组做引用计数管理。

此外，引用计数机制本身在数组场景下需要确保数组的所有元素在引用计数归零时能正确销毁。数组元素类型可能包含复杂的析构逻辑，这也给引用计数带来了额外的复杂性。

### 2. **C++ 提供了其他更合适的工具来管理数组**

对于管理动态数组，C++ 标准库提供了更合适的工具，如 `std::unique_ptr<T[]>` 和 `std::vector<T>`：

* **`std::unique_ptr<T[]>`**：它专门设计用于管理动态分配的数组，并会自动使用 `delete[]` 来释放内存。
* **`std::vector<T>`**：是一个更加灵活的数组替代方案，自动管理内存，并且还提供了许多额外的功能，如动态调整大小、迭代器等。

相比之下，`std::shared_ptr` 主要用于管理需要引用计数的单个对象，而不是数组。

### 3. 标准库的设计意图

C++ 标准库的设计原则之一是尽量保证类型和行为的统一性、直观性。`std::shared_ptr` 本质上是为管理单个对象设计的，而不是为动态数组设计。如果直接允许 `shared_ptr` 管理数组，会导致接口设计和使用上的不一致，破坏了 `shared_ptr` 管理单对象的语义。

为了解决这些问题，C++11 引入了 `std::shared_ptr<T[]>`，这是一个特化版本，专门用于动态数组的管理，并支持正确的内存释放机制（使用 `delete[]`）和数组元素访问接口。这种分开处理的设计避免了统一接口引入的复杂性，也让用户的意图更加明确。

## 121. Zero-cost exception handling

**Zero-cost exception handling** 是一种异常处理策略，旨在让程序在正常执行期间不因异常机制引入额外的运行时开销，即“零成本”。这种方法特别适用于 C++，因为 C++ 是一门重视性能的语言，零开销的异常处理设计符合其高性能需求。Zero-cost exception handling 的核心思想是：在没有异常的正常执行路径上不会引入额外开销，而仅在真正抛出和处理异常时才会有额外的代价。

### 关键特性

1. **常规代码无开销**
   在没有发生异常的情况下，zero-cost exception handling 保证异常处理不会影响程序的正常性能。这是通过避免为每个可能抛出异常的函数进行额外检查来实现的。只有在真正抛出异常时，才会引发额外的处理开销。
2. **分离异常处理代码**
   使用该机制时，异常处理代码通常与主代码流分离。例如，在 C++ 中，通过编译器生成的额外数据结构（如栈展开表）来支持异常抛出和处理，而不影响主代码流。常见的实现方式有使用 *表驱动的栈展开* 或 *DWARF（Debugging With Attributed Record Formats）表*。
3. **只在异常发生时支付成本**
   在出现异常时，才会使用异常处理表进行栈展开（stack unwinding），这会引发额外的开销。这种方式可以在异常出现的过程中，通过异常处理表进行逐步匹配和捕获。

### 实现原理

在现代 C++ 实现中，zero-cost exception handling 主要通过表驱动的栈展开机制来实现。该机制分为两部分：

1. **异常处理表**
   编译器在编译时会为程序中的每个函数生成异常处理表。这些表记录了函数调用的栈帧信息、异常处理位置以及捕获的类型等信息。表存储在程序的额外段中，仅在出现异常时使用，因此不会影响正常执行的性能。
2. **栈展开（Stack Unwinding）**
   当抛出异常时，系统会根据异常处理表回溯栈帧，即“展开栈”。栈展开会逐层检查调用栈中的函数，找到合适的 `catch` 块来处理异常。这个过程通常由操作系统或运行时支持。

例如，GNU 的 C++ 编译器（GCC）使用的 *DWARF 异常处理表* 在抛出异常时，通过栈展开表来找到适当的异常处理代码，这样异常处理的开销仅在真正抛出异常时才会发生。

### 优缺点

* 优点
  * 正常执行路径上几乎没有额外开销。
  * 避免了在普通代码中添加异常处理所需的检查，从而提高了性能。
* 缺点
  * 当异常被抛出时，栈展开的过程可能比较耗时。
  * 生成异常处理表会增加程序的二进制大小。

### Zero-cost Exception Handling 的使用情景

Zero-cost exception handling 非常适合低延迟、高性能要求的场景，例如实时系统、游戏开发和嵌入式系统。在这些环境中，程序大多数时间都不会抛出异常，但仍需要健壮的异常处理能力。在这种情况下，Zero-cost exception handling 的设计可以让程序在正常操作时达到最高效率。

总之，zero-cost exception handling 在 C++ 中确保了异常处理机制在正常代码执行时不带来开销，仅在异常发生时引入额外的成本。

## 122. 在class外部定义类时可见作用域扩大了

``` C++
struct Foo {
    void f();
};

int val = 10;

void Foo::f() {
    cout << "val: " << val << endl;
}

int main() 
{  
    Foo().f(); // val: 10
    return 0;
}
```

对于类外定义的 `Foo::f` 来说，在类定义之后，该函数定义之前的作用域都是可见的。

## 123. 继承体系中基于指针和引用的查找

无论是单继承还是多继承，对象、指针和引用的静态类型决定了我们能够使用那些成员。不要误认为，指针和引用可以和虚函数结合进行动态绑定，从而调用派生类的成员，就觉得只要是指针和引用类型就可以调用派生类的成员了。

``` C++
struct Foo {
    void f() {puts("Foo::f");}
    void g() {puts("Foo::g");}
    virtual void v() {puts("Foo::v");}
};

struct Bar : public Foo {
    void f() {puts("Bar::f");} // 隐藏Foo中的同名函数
    void h() {puts("Bar::h");} // 派生类特有的成员函数
    virtual void v() {puts("Bar::v");} // 覆盖Foo中的虚函数
};

void func(Foo &f)
{
    f.v(); // Bar::v
    f.f(); // Foo::f
    f.g(); // Foo::g
    f.h(); // class "Foo" has no member "h"
}

int main()
{
    Bar b;
    func(b);
    return 0;
}
```

在函数 func 中，可以发现，除了虚函数外，调用的都是其静态类型 Foo 的版本。对于派生类的成员函数 h，基类不可见。

## 124. 域运算符与typename

对于模板类型，当我们使用域（`::`）运算符来访问模板的类型成员时，需要在类型前面加上 typename。

因为对模板来说，编译器不像内置模板类类型（例如 string）一样可以获取类的定义，因此他不知道对于 `T::mem` 来说，mem 到底是一个静态数据成员，还是一个类型成员。

默认情况下，C++ 语言假定通过作用域运算符访问的是名字而不是类型。例如：

``` C++
template<typename It>
auto func(It beg, It end) -> remove_reference<decltype(*beg)>::type
{
    auto start = beg;
    while(beg != end) {
        cout << *beg << ' ';
        ++ beg;
    }
    cout << endl;
    return *start;
}
```

会报错：

``` c++
main.cpp:9:30: error: need ‘typename’ before ‘std::remove_reference<decltype (* beg)>::type’ because ‘std::remove_reference<decltype (* beg)>’ is a dependent scope
    9 | auto func(It beg, It end) -> remove_reference<decltype(*beg)>::type
      |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                              typename 

```

只要加上 typename 即可：

``` c++
template<typename It>
auto func(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    auto start = beg;
    while(beg != end) {
        cout << *beg << ' ';
        ++ beg;
    }
    cout << endl;
    return *start;
}
```

## 125. vector无法保存引用类型元素

一般来说，标准库的容器(包括 vector)都要求元素类型是可复制和可移动的，以便在调整容量时能重新排列内部的元素。而引用不可以复制和移动。

其次，容器一般使用动态空间，我们需要一个指针指向分配的动态空间，指针的类型就是元素类型。然而引用只是一个别名，它没有地址，因此不能定义指向引用的指针。

如果我们将 vector 的元素类型设置为引用，语法上是没有错误的，这就导致我们无法立即察觉错误。并且编译报错由于涉及模板，也是完全看不懂。

## 126. 类内成员的解析规则

在 C++ 中，类的成员变量和成员函数都可以在类的内部任意顺序地引用。编译器在解析类时，会首先了解整个类的成员（包括函数和变量）。

即，**类的成员变量和成员函数都在类的作用域中隐式声明**，不要求按顺序定义。所以，在成员函数中引用成员变量时，不需要成员变量的前置声明。

但是对于类型变量，这个规则稍有不同，类型变量的声明必须出现在其使用之前。因为编译器在处理类时本质上依然是按**顺序解析**的：

* 它先了解到成员变量和成员函数的隐式声明
* 依次解析函数和变量

如果函数或者变量用到了某个类型变量，而该类型变量的声明没有出现，那么编译器就会报错，因为他不知道该类型变量的确切含义。

也因此，**类型变量的声明要放在类体的开头位置**。



























# C++ Prime

## 一、IO库

### 1. 宽字符

一般来说，我们使用的 IO 类型和对象都是操纵 char 字符的，不过为了支持宽字符的语言，标准库定义了一组类型和对象来操纵 wchar_t 类型的数据。宽字符版本的类型和函数以 w 开头，例如 wcin、wcout 和 wcerr 分别对应 cin、cout 和 cerr 的宽字符版本。wchar_t 版本的类型和对象与其对应的普通 char 类型的版本定义在同一个头文件中，例如头文件 fstream 定义了 ifstream 和 wifstream 类型。

### 2. IO 类的继承关系

``` C++
iostream: 基本IO（控制台IO），基本流
    -istream, wistream
    -ostream, wostream
    -iostream, wiostream

fstream: 文件IO，文件流
    -ifstream, wifstream
    -ofstream, wostream
    -fstream, wfstream

sstream: 内存IO(通过string实现)，string流
    -istringstream, wistringstream
    -ostringstream, wostringstream
    -stringstream, wstringstream
```

从概念上，设备类型（文件 or 终端 or 内存中的字符串）和字符大小（char or wchar_t）都不会影响我们要执行的 IO 操作。例如我们可以通过 >> 读取数据，而不管是从一个控制台窗口还是从一个磁盘文件读取，也不必关心读取的字符是要存入一个 char 对象内还是 wchar_t 对象内。

标准库之所以能使我们忽略这些差异是通过继承机制实现的，通过继承机制，我们可以将一个派生类对象当作基类对象使用。

它们的继承关系如下图所示：

![IO class](https://images0.cnblogs.com/blog/378920/201405/082149512609442.png)

> 其中istream和ostream直接从ios中继承，iostream多重继承了istream和otream。

### 3. IO 对象是 noncopable 类型

因此我们不能拷贝 IO 对象或者为其赋值。也不能将其作为形参或者返回类型。不过我们可以以引用的形式传递和返回 IO 对象。读写一个 IO 对象会改变流的状态，因此我们也不能使用常量引用。

### 4. 条件状态

IO 库提供了一些标志以及与标志有关的函数，可以帮助我们访问和操纵流的条件状态。

在 `<ios/ios_base.h>` 里面有这样一段内容：

``` C++
enum _Ios_Iostate
{ 
    _S_goodbit 		= 0,		// 0
    _S_badbit 		= 1L << 0,  // 1
    _S_eofbit 		= 1L << 1,  // 2
    _S_failbit		= 1L << 2,  // 4
    _S_ios_iostate_end = 1L << 16,
    _S_ios_iostate_max = __INT_MAX__,
    _S_ios_iostate_min = ~__INT_MAX__
};

typedef _Ios_Iostate iostate;

/// Indicates a loss of integrity in an input or output sequence (such as an irrecoverable read error from a file).
static const iostate badbit =	_S_badbit;

/// Indicates that an input operation reached the end of an input sequence.
static const iostate eofbit =	_S_eofbit;

/// Indicates that an input operation failed to read the expected characters, or that an output operation failed to generate the desired characters.
static const iostate failbit =	_S_failbit;

/// Indicates all is well.
static const iostate goodbit =	_S_goodbit;
```

在 C++ 中，输入输出流的状态就是通过 `ios_bast.h` 里定义的 4 个枚举类型管理的：

* strm::goodbit：流未处于错误状态，此值保证为0
* strm::badbit：不可恢复错误，通常情况下流不可继续使用
* strm::eofbit：流到达了文件结束位置，此时eofbit和failbit都为置位
* strm::failbit：可恢复错误，流还可以继续使用

另外，`strm::iostate` 是上面 4 中状态的集合，相当于：`iostate = goodbit | badbit | eodbit | failbit`。以及一些操作这些标志的函数：

``` C++
// 非标准库实现，但含义是一样的
bool eof() {
    return eofbit;
}
bool bad() {
    return badbit;
}
bool fail() {
    return failbit | badbit;
}
bool good() {
    return !fail() && !eof();
}
void clear() {
    iostate = goodbit;
} 
void setstate(iostate state = goodbit) {
    iostate = state;
}
iostate rdstate() const {
    return iostate;
}
```

对于下面的代码，如果我们输出 `CTRL+D`（文件结束符），那么程序输出为：

``` C++
int x;
cin >> x;
auto cur_state = cin.rdstate();
cout << cur_state << endl;	// 6
cin.clear(cur_state & ~cin.eofbit & ~cin.failbit);
cout << cin.rdstate() << endl; // 0
```

编写一个函数，接受一个 istream&对象，返回值也是 istream&。此函数需从流中读取数据并输出，直至遇到 EOF 停止。完成这些操作后，在返回流之前，对流进行复位：

``` c++
constexpr auto max_size = numeric_limits<streamsize>::max();

template<typename T>
istream& read(istream& is) 
{
    T x;
    while(cin >> x, !is.eof()) 
    {
        if(is.bad()) 
        {
            throw(runtime_error("IO stream error"));
        }
        if(is.fail())
        {
            cerr << "Data error, pls retry: " << endl;
            is.clear();
            // 在流中忽略最多max_size个字符直到遇到'\n'
            // 如果max_size==streamsize的最大值
            // 那么该数将被忽略，即可以忽略无限个字符直到遇到'\n'
            is.ignore(max_size, '\n');
            continue;
        }
        cout << "data: " << x << endl;
    }
    is.clear();
    return is;
}

int main() 
{
    read<int>(cin);
    return 0;
}
```

### 5. 管理输出缓冲

导致缓冲刷新（即，数据从内存中的缓冲区真正写道输出设备或文件）的原因有很多：

* 程序正常结束

* 缓冲区满

* 显示刷新缓冲区：例如使用操作符 `endl`

* 一个输出流可能被关联到另一个流：在这种情况下，当读写被关联的流时，关联到的流的缓冲区也会被刷新。例如默认情况下 cin 和 cerr 都关联到 cout，因此读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。

  > 这也很显然，因为它们是公用缓冲区的，如果不刷新的话，那么一个缓冲区就保存了不同流的数据，显然不合理

* 在输出操作之后，可以用操纵符 `unitbutf` 设置流的内部状态，来清空缓冲区。默认情况下，对 cerr 时设置 `unitbuf` 的，因此 cerr 的内容会立即刷新。

对当前输出刷新缓冲区：

* endl：换行并刷新缓冲区
* ends：输出空字符并刷新缓冲区（注意空字符不是空格）
* flush：刷新缓冲区

对每次输出都刷新缓冲区：

* unitbuf：放在输出的开头，在他之后的输出都会刷新缓冲区
* nounitbuf：回到正常的缓冲方式

通过组合 unitbuf 和 nounitbuf 可以实现 flush 的效果：

``` c++
cout << "4" << flush;
cout << unitbuf << "4" << nounitbuf;
```

如果从程序崩溃或异常终止，输出缓冲区不会被刷新。因此在使用输出语句调式代码时，确保每次都刷新缓冲区。

----

关联输入和输出流：当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新输出流。

交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。我们可以通过 `tie()` 修改流的关联关系和查看当前输入流绑定的输出流。

### 6. 文件流

当我们使用文件 IO 时，和普通 IO 并无什么区别，我们依然是通过 `>>`，`<<`，或者 `getline` 等函数进行输入输出，只不过输入输出的设备发生了变化。

fstream 特有的操作：（fstream 表示文件 IO 类型）

``` c++
fstream fstrm;    // 创建一个未绑定的文件流
fstream fstrm(s); // 创建一个文件流并打开文件s
				  //mode依赖于fstream的类型
				  //此时open自动被调用
fstream fstrm(s, mode);
fstrm.open(s);	  // 如果定义了一个未绑定的文件流
				  // 可以调用open来将它与文件绑定
fstrm.close();    // 当一个对象被销毁时，close会被自动调用
fstrm.is_open();
```

> 注意 open() 可能失败，此时 failbit 会被置位。当我们打开文件时，检查文件是否成功被打开是一个好习惯。
>
> 对一个已经绑定文件的流执行 open() 会失败，并且 failbit 会置位。随后的试图使用该文件流的操作都会失败。如果我们想换绑文件，需要先 close() 再重新 open()

----

文件模式：

``` c++
in      // read
out     // write
app		// append
ate		// 打开文件后定位到文件末尾
trunc
binary
```

注定文件模式有一些限制：

* 必须指定了 out 才能 trunc
* 只要 trunc 没被设定，就可以设定 app 模式；设置 app 时无需也设置 out
* 默认情况下，即使没有指定 trunc，以 out 打开的文件也会被截断。我们可以使用 app 或者同时以 in 的方式打开文件来保留文件（也只有这两种方法）
* ate 和 binary 模式可以用于任何类型的文件流对象，并且可以与其它任何文件模式组合使用
* 当我们以 out 模式打开文件时，即使指定 ate 也会截断文件

每个文件流类型都定义了默认的文件模式：

* ifstream：in
* ofstream：out
* fstream：in & out

### 7. 内存流（string流）

在 C++ 中，内存 IO 以 string 作为 IO 对象，因此一般称内存流为 string 流。

sstringstream 特有的操作：（sstream 表示内存 IO 类型）

``` c++
sstream strm;	 // 定义一个未绑定的stringstream对象
sstream strm(s); // 定义一个绑定到字符串s的strignstream对象
strm.str();		 // 返回strm保存的string的拷贝
strm.str(s);	 // 更换strm的绑定为s
```

## 二、顺序容器

### 1. 顺序容器概述

顺序容器指的是元素在内存中的位置与元素加入容器的顺序有关。所有顺序容器都提供了快速顺序访问元素的能力。但是，容器在以下方面都有不同的性能折中：

* 向容器添加或从容器中删除元素的代价
* 随机访问容器中元素的代价

``` c++
array;
vector;
string;
list;
forward_list;
deque;
```

容易忽略的是 deque，它是顺序容器并且支持随机访问。

list 和 forward_list 在内部需要为每个元素额外保存两个或一个指针，因此它们的额外内存开销比较大。指针的使用也体现了顺序容器中的元素在内存中未必连续。

forward_list 的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此 forward_list 没有 size 操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size 保证是一个快速的常量时间的操作。

由于 array 的大小固定，因为 array 的大小也是类型的一部分：`std::array<Type,Size> arr;`

当我们在输入阶段需要在容器中间位置插入元素，输入完成后又需要随机访问元素，该如何选择容器呢？

* 如果我们在中间位置插入元素是为了确保数据的有序性，那么可以追加到 vector 末尾再排序
* 如果必须在中间位置插入元素，可以先用 list 保存元素，最后再将 list 中的内容拷贝到 vector

### 2. 容器库概览

所有容器都适用的操作：

``` c++
// 类型别名
iterator;
const_iterator;
size_type; // 无符号整数，足够保存此容器类型最大可能容器的大小
difference_type; // 带符号整数，足够保存两个迭代器之间的距离
value_type;
reference; // value_type&
const_reference; // const value_type&
// 构造函数
C c;
C c1(c2);
C c(b, e);	// array不支持
C c{a, b, c, ...};
// 赋值与swap
c1 = c2;
c1 = {a, b, c, ...};
a.swap(b);
swap(a, b);
// 大小 
c.size(); // forward_list不支持
c.max_size(); // c可保存的最大元素数目
c.empty();
// 添加或删除元素（array除外）
c.insert(args);
c.emplace(inits); // 使用inits构造c中的一个元素
c.erase(args);
c.clear();
// 关系运算符
==, !=;
<, <=, >, >=;
// 获取迭代器
c.begin(), c.end();
c.cbegin(), c.cend();
// 反向容器的额外成员
reverse_iterator;
const_reverse_iterator;
c.rbegin(), c.rend();
c.crbegin(), c.crend();
```

### 3. 迭代器

我们对构成范围的迭代器（begin，end）有以下要求（保证）：

* 它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置
* 我们可以通过返回递增 begin 达到 end。换言之，end 不在 begin 之前

有时我们会将尾后迭代器 end 称为 last，虽然 last 具有一定的歧义，因为 end 所指向元素并不是容器的最后一个（last）元素。

在遍历迭代器时，使用 `!=,==` 作为判断条件而不是 `<,<=`，因为有些容器的迭代器并不支持 `<,<=,>=,>` 运算。

对于反向迭代器来说，各种操作的含义也发生了颠倒。例如 `++` 操作会得到上一个元素，这是合理的。因为在逻辑上，上一个元素就是我们要迭代的下一个元素。

### 4. begin和end

不以 c 开头的函数都是被重载过的。这就是说，实际上有两个名为 begin 的成员。一个是非常量成员，返回 iterator；一个是常量成员，返回 const_iterator。因此说当我们使用 begin 时，它并不总是返回 iterator。

begin 为空时返回 end。

### 5. 容器定义和初始化

``` c++
C c;	// 默认初始化

C c1(c2); // c1和c2必须是相同类型：容器类型相同，保存的元素类型相同
C c1=c2; // 对于array类型，还要求大小相同

C c{a,b,c...}; // 元素类型相容即可，对于array要求元素个数必须<=
C c={a,b,c...}; // array的大小，遗漏元素值初始化

C c(b,e); // 元素类型相容即可

// 只有顺序容器(不包括array)的ctor才能接受大小参数
c seq(n);	// 值初始化
c seq(n,val);
```

对于 array，如果我们没有指定初始值，容器元素会被默认初始化，就像一个内置数组一样：

``` c++
array<int, 10> a; // 默认初始化: 垃圾值
for(int i = 0; i < 10; i ++ )
    cout << a[i] << ' ';    
cout << endl;

vector<int> b(10); // 值初始化
for(int i = 0; i < 10; i ++ )
    cout << b[i] << ' ';
cout << endl;


int c[10]; // 默认初始化: 垃圾值
for(int i = 0; i < 10; i ++ )
    cout << c[i] << ' ';
cout << endl;
```

### 6. assign

顺序容器（array 除外）还定义了 assign 成员函数，允许我们从一个不同但相容的类型赋值。

``` c++
seq.assign(b,e);
seq.assign(n,val);
seq.assign(initializer_list);
```

注意当我们使用初始值列表进行赋值时，不允许我们 narrowing conversion

``` C++
vector<int> a(10, 1);
//a.assign({1, 3.14}); // error: narrowing conversion
a.assign({5, 'a' - '0', 'a', '0'});
for(auto &x : a)    cout << x << ' ';
cout << endl;
cout << a.size() << ' ' << a.capacity() << endl;

vector<string> s(2, "hello");
s.assign({"hello", "world!"});
```

### 7. 迭代器失效

迭代器失效就是迭代器底层对应指针所指向的空间被销毁了，导致使用了一块已经被释放了的空间。

容器操作可能使迭代器失效，一个失效的迭代器将不再表示任何元素。使用失效的迭代器是一个严重的程序设计错误，很可能产生与使用未初始化化指针一样的问题。

### 8. swap

swap 用于交换两个相同类型容器的内容。除了 array 外，交换两个容器内容的操作保证会很快 —— 元素本身并未交换，swap 只是交换了两个容器的内部数据结构。也即，**swap 方法的原理是交换两个容器的内部指针以达到“交换整个容器”的效果。**

> 之所以 swap 用于交换 array 很慢是因为 array 保存数组使用的不是动态内存，因此没有一个指向容器数据的指针。所以在交换元素时只能一个一个元素的交换，而不能直接交换指向元素的指针。

这也意味着，除 array 外，swap 不会对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。并且元素不会移动的事实意味着，除 string 外，指向容器的迭代器、引用和指针在 swap 操作后不会失效。

> swap 会导致指向 array 和 string 的迭代器、指针和引用失效。对于 array 好理解，它移动了元素。但对于 string 是为什么呢？
>
> 原因在于：SSO（Short String Optimization），指 C++ 针对短字符串的优化。
>
> 默认情况下，C++ 的 std::string 都是存储在 heap 中，导致访问std::string 需要经过一次寻址过程，速度较慢，并且这种实现的空间局部性不好，对 cache 的利用较低。
>
> 很多 string 的字符串长度很小，这个时候，我们可以把字符串存储到栈上，从而不需要进行内存分配，优化创建速度，并且访问栈上数据的局部性很好，速度比较快。
>
> 即 C++ 会自动把较短的字符串放到对象内部，较长的字符串放到动态内存。假如 std::string 用 SSO 实现，而待交换的两个对象中的字符串恰好一长一短，则原先指向短字符串中的迭代器会全部失效。

例如：

``` c++
vector<int> a{1, 2, 3, 4, 5};
vector<int> b{11, 12, 13};
int *p = &a[1];
cout << *p << endl;	// 2
cout << *(p + 1) << endl; // 3
swap(a, b);
// 指针p未失效
cout << *p << endl;	// 2
cout << *(p + 1) << endl; // 3
```



----

对于 vector 来说，swap 还交换了 capacity 的大小。

``` c++
vector<int> a(10, 1);
vector<int> b(20, 3);
swap(a, b);
cout << a.size() << ' ' << a.capacity() << endl; // 20, 20
cout << b.size() << ' ' << b.capacity() << endl; // 10, 10
```

通过这个性质，可以得到 swap 对于 vector 还有一个重要用途，先来看下面的代码：

``` C++
vector<int> a(10000);
cout << a.size() << endl;   // 10000
cout << a.capacity() << endl; // 10000
a.resize(10);
cout << a.size() << endl; // 10
cout << a.capacity() << endl; // 10000 
```

一开始我们希望创建一个很大的 vector，有 10000 个元素。但后来我们不需要这么多元素了，于是通过 resize 将元素数量调整到 10。此时 vector 虽然通过删除元素缩减了 vector 的大小（size），但是并没有减小它的容量（capacity），即实际在 heap 中分配的内存空间。另外对于 clear 也是同样的情况。

那么有没有什么办法既减少 size，又减少 capacity 呢？答案是 swap，通过将当前 vector 与一个局部 vector 进行 swap：

``` c++
vector<int> a(10000);
cout << a.size() << endl;   // 10000
cout << a.capacity() << endl; // 10000
vector<int>(10).swap(a);
cout << a.size() << endl;   // 10
cout << a.capacity() << endl; // 10
```

通过创建一个匿名局部对象 `vector<int>(10)` 与 a 交换，来缩减 a 的 capacity。又因为匿名对象使用完就会被自动释放，所以交换之后的局部 vector，也就是之前的 a 便销毁了。

----

统一使用非成员版本的 swap 是一个好习惯，因为它更适用于泛型编程。

### 9. 容器的比较

容器的比较和 string 比较类似。都是先比较容器内元素再比较容器大小。

所有容器都支持 `==,!=` 运算符；无序关联式容器不支持 `<=,>=,<,>` 运算符。

注意不要把容器的比较与迭代器的比较搞混了。容器支持 `<` 运算符不代表该容器的迭代器支持 `<` 运算符，例如 `list`。

### 10. 添加元素

``` c++
c.push_back(t);			// copy
c.emplace_back(args);	// construct

c.push_front(t);
c.emplace_front(t);

c.insert(p,t);
c.emplace(p,args);
c.insert(p,n,t);
c.insert(p,b,e);
c.insert(p,il);
```

forward_list 不支持 push_back 和 emplace_back，这也显然，因为它没有指向尾元素的指针。vector 和 string 不支持 push_front 和 emplace_front。

forward_list 有自己专有版本的 insert 和 emplace。

所有 insert 都是在迭代器 p **之前**插入元素，返回值都是指向**新添加的第一个元素**的迭代器。如果我们传入的是 il 或一对迭代器并且范围为空，那么将直接返回 p。迭代器 p 可以指向容器中的任何位置，包括容器尾部之后的下一个位置。注意指针并不等价于迭代器，我们不可以将一个指针作为第一参数。

push 和 insert 传递的是元素类型的对象，这些对象被拷贝到容器中。emplace 传递的是构造函数所需的参数，从而直接在容器管理的动态内存中构造元素。不过 push 和 insert 实际上也可以传递构造函数所需的参数，只不过参数个数必须为1，此时本质上是通过转换构造函数创建了一个临时匿名对象，然后将其拷贝到容器中。特别的，当我们希望传递一个调用默认构造函数的对象或构造函数需要多个参数时，push 和 emplace 在形式上有所不同：

``` C++
struct Foo {
    Foo() {
        cout << "Foo" << endl;
    }
    Foo(int x) {
        cout << "FooI" << endl;
    }
    Foo(double x) {
        cout << "FooD" << endl;
    }
    Foo(int x, int y) {
        cout << "FooII" << endl;
    }
};

int main() 
{
    vector<Foo> c;
    c.push_back({});        // 花括号
    c.push_back(1);
    c.push_back(3.14);
    c.push_back({1, 2});    // 花括号
    
    
    c.emplace_back();
    c.emplace_back(1);
    c.emplace_back(3.14);
    c.emplace_back(1, 2);

    return 0;
}
```

### 11. 访问元素

``` C++
c.front();	// 返回引用，如果c为空，UB
c.back();	// 返回引用，如果c为空，UB
c[n];	    // 返回引用，n是无符号数，如果越界，UB
c.at(n);	// 如果越界，抛出out_of_range异常
```

包括 array 在内的每一个顺序容器都有一个 front 成员函数，而除了 forward_list 之外的所有顺序容器都有一个 back 成员函数。在使用 front 和 back 获取容器元素之前，要确保容器非空。如果容器为空，那么 front 和 back 的行为是未定义的。

在容器中访问元素的成员函数返回的都是引用，如果容器是一个 const 对象，则返回值是 const 的引用。

### 12. 删除元素

``` C++
c.pop_back(); // 若c未空，UB。返回void
c.pop_front(); // 若c为空，UB，返回void
c.earse(p);	// 删除迭代器p所指定的元素，若p是尾后迭代器，UB
            // 返回一个指向被删元素之后元素的迭代器
            // 若p是尾元素，返回尾后迭代器
c.erase(b,e);// 删除迭代器b和e所指定范围内的元素
			 // 返回一个指向最后一个被删除元素之后元素的迭代器
			 // 若e本身就是尾后迭代器，则返回尾后迭代器
			 // 若b==e，返回b
c.clear(); // 删除所有元素，返回void
```

forward_list 有特殊版本的 erase，不支持 pop_back。

vector 和 string 不支持 pop_front。

删除 deque 中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向 vector 或 string 中删除点之后位置的迭代器、引用和指针都会失效。

删除元素的成员函数并不会检查其参数。在删除元素之前，程序员必须保证它们是存在的。

### 13. 特殊的forward_list操作

``` C++
l.before_begin();	// 返回首前迭代器，不能解引用
l.cbefore_begin();

l.insert_after(p,t);	// 在p之后插入元素
l.insert_after(p,n,t);	// 返回一个指向最后一个插入元素的迭代器
l.insert_after(p,b,e);  // 若p为尾后迭代器，UB
l.insert_after(p,il);

emplace_after(p,args);	// 若p为尾后迭代器，UB

l.erase_after(p);	// 删除p之后的元素
                    // 返回一个指向被删除元素之后的迭代器
                    // 若不存在则返回尾后迭代器
					// 如果p指向尾元素或尾后元素，UB
l.erase_after(b,e); // 删除(b,e]内的元素
```

我们在前面提到过，forward_list 有自己特殊版本的插入（insert, emplace）和删除（erase）操作，但是为什么呢？

我们先考虑从一个单向链表中删除某个元素 p 会发生什么。我们需要修改 p 的前驱，让它的指针指向 p 的后继。但是 forward_list 是一个单向链表，我们没有简单的办法从一个单向链表中获取前驱。因此 forward_list 的做法是我们直接给出前驱，然后去操作它的后继。

由于这种操作与其它容器上的操作的实现方式不同， forward_list 并未定义 insert、emplace 和 erase，而是定义了名为 insert_after、emplace_after 和 erase_after 的操作。并且为了支持这些操作，forward_list 还定义了 before_begin，它返回一个首前迭代器。这个迭代器允许我们在首前元素之后增删元素，即在首元素之前增删元素。

另外，和 insert 返回指向第一个插入的元素的迭代器不同，forward_list 的 insert_after 返回的是指向最后一个插入元素的迭代器。

### 14. 改变容器的大小

``` c++
c.resize(n);
c.resize(n,t);
```

显然的，array 不支持 resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于所要求的大小，会将新元素（值初始化）添加到容器后部。当然也可以通过其重载函数指定新元素的值。

### 15. 迭代器失效问题

向容器中添加元素或从容器中删除元素的操作可能导致指向容器的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素（原本指向的元素已经被销毁了）。使用失效的指针、引用和迭代器是一种严重的程序设计错误，因可能引起与使用未初始化的指针一样的问题。

在向容器添加元素后：

* list，forward_list：不影响
* vector，string：
  * 如果存储空间重新分配，全都指引迭失效
  * 否则，插入位置之后的全部指引迭失效
* deque：
  * 在首尾插入：迭代器失效，指针和引用不会
  * 否则，全部指引迭失效

当我们删除一个元素后，指向被删除元素的指针、引用和迭代器会失效。对于其它指针、引用和迭代器来说：

* list，forward_list：不影响
* vector，string：被删除元素之后的全部指引迭失效
* deque：
  * 在首删除：不受影响
  * 在尾删除：尾后迭代器会失效，其余不受影响
  * 否则，全部指引迭失效

建议：管理迭代器

* 当使用（指针、引用）迭代器时，最小化要求迭代器必须保持有效的程序片段是一个好方法
* 由于向增删元素可能导致迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器
* 不要保存 end 返回的迭代器，因为 end 在绝大部分增删的情况下都会失效。通常 C++ 标准库的实现中 end 操作都很快，部分也是因为我们需要频繁调用 end。

### 16.  deque 的底层细节

deque 是一个双端队列，可以实现在头尾两端的相关操作，并且在头尾两端的操作十分高效。

* 与 vector 相比，vector 虽然也可以实现在头部的操作，但实现起来比较复杂，要挪动后面的所有元素
* 与 list 相比，由于其底层空间是连续空间，所以空间利用率要高于list，并且 list 不支持下标的随机访问，而 deque 则支持。

因此，可以说 deque 是集合了 list 与 vector 各自的优点（头尾高效操作+随机访问元素），但是自古以来鱼与熊掌不可兼得，deque 虽集合了各自的优点，但是却做不到 vector 与 list 那么极致。deque 的数据结构较为复杂，尤其是其迭代器。

#### deque 的内存结构

这一点在前面介绍迭代器失效案例时可以发现，如果我们在 deque 的首位插入元素，迭代器会失效，而指针和引用则不会。

![img](https://developer.qcloudimg.com/http-save/yehe-10181992/fba1ff96195245bcce753133ac72faad.png)

 如上图所示，deque 采用 map 作为主控，这里的 map 并非 STL 容器中的map，这里的 map 是一小块连续的空间，每个元素都是一个指针（数组指针），该指针指向了一块缓冲区，这里的缓冲区用来存储数据。（有点像二维数组）当 map 已经全部被使用，便需要再找一块更大的空间来作为 map。

另外，deque 要求 map 前后各预留一个 node 节点，以便扩充可用。

#### deque 的迭代器

deque的迭代器设计十分复杂，如下所示：

![img](https://developer.qcloudimg.com/http-save/yehe-10181992/9f6c75f6ee56ce3c1bb7a280f63d2242.png)

通过右下角的迭代器结构可以发现，实现一个迭代器需要 4 个指针。除了指向元素地址的指针 cur，还需要：

* node：元素所处缓冲区在map中的位置
* first：元素所处缓冲区的头
* last：元素所处缓冲区的尾

由于 deque 的元素在底层并不是全部连续的，它实际上 buffer 内部连续，buffer 之间不连续。因此我们需要一个迭代器 node 来指向当前所在 buffer。当 cur 处于 last 时在执行 `++` 或当 cur 指向 first 时在执行`--`，就需要修改 node 指向的 buffer。而无法得知当前 cur 到底是 first 还是 last 还是处于中间，因此每次 `++` 和 `--` 操作都需要检测迭代器是否指向 buffer 的两端。这显然是一个费时的操作，因此 deque 随机访问的能力不如 vector 高效。

另外，关于 deque 在首尾插入元素导致迭代器失效的问题。因为在首尾插入元素可能导致 map 重新分配，因此 node 会失效，迭代器也就失效了。但是指针和引用并不会，因为元素本身地址并未变化。

#### deque 的扩容机制

deque 的空间不够用时，只需要在增加一个 buffer 用来保存数据就好了。但如果 map 无法存放更多指向 buffer 的指针，就需要重新分配 map。不同于 vector 的重新分配，vector 的重新分配可能涉及深拷贝的问题，而 deque 则不会，因为 map 中存放的都是指向 buffer 的指针，重新分配时元素本身并不发生任何变化。

由于 deque 每次重新分配只是分配指向元素的指针，并且不涉及深拷贝问题，所以说扩容效率比 vector 更高。

#### deque 的随机访问

deque虽然支持随机访问，但是其效率也是不如 vector 的，这里假如我们第一个缓冲区已经存在了 3 个数据，且每一个缓冲区的大小固定为 10，这里我们要想实现访问第 25 个数据，在 vector 中则只需要 vector[24] 即可访问到该数据，而在deque 中则需要：

1. 先找到其所在的缓冲区
2. 再找到在缓冲区的第几个位置

可以看到，缓冲区的大小实际上影响了访问效率。如果缓冲区大小固定，那么第一步就很快，可以通过数学运算直接找到该缓冲区在 map 中的位置；而如果缓冲区大小不固定，那么实现上可能就比较麻烦了，可能需要保存每个缓冲区的大小，然后一个接一个缓冲区的判断。

#### 为什么stack和queue的默认容器是deque

1. deque 首位两端的插入和删除都非常高效
2. deque 的扩容比 vector 高效
3. deque 的空间利用率比 list 高效

最后，虽然 deque 的随机访问能力不如 vector，但 stack 和 queue 不需要随机访问呀。









### 17. 管理容量的成员函数

* shrink_to_fit 只适用于 vector，string 和 deque
* capacity 和 reserve 只适用于 vector 和 string

``` C++
c.shrink_to_fit();	// 将capacity减少为与size大小相同
c.capacity();	// c可以保存的元素的数量
c.reserve(n);	// 分配至少能容纳n个元素的内存空间
				// 注意n是指容器中的元素个数
```

只有当需要的内存空间超过当前容量（capacity）时，reserve 才会改变 vector 的大，并且分配至少与需求一样大的空间（可能更大）。如果需要的内存空间小于等于当前容量，reserve 什么也不做（这意味着它不会缩小空间）。

在前面我们介绍过通过创建临时对象和 swap 来收缩内存，实际上 C++ 库提供了 shrink_to_fit 来收缩内存。

### 18. string的额外操作

string 的专门函数除了可以接受迭代器之外，还可以接受下标。

``` c++
// (1) 构造函数
	// n,len2,pos2都是无符号值
	// 如果以char*构造string，相当于substr(0,len)
	// 如果以string构造string，相当于substr(pos,len)
string s(cp,n);	// s是cp指向的数组中前n个字符的拷贝
				// 此数组应至少包含n个字符
string s(s2,pos2); // s是string s2从下标pos2开始的字符的拷贝
				   // 若pos2>s2.size()，UB
string s(s2,pos2,len2);	// 若pos2>s2.size()，UB	
						// 如果pos2+len2>s2.size，
						// 会自动调整到字符串的末尾

// (2) 修改string
s.insert(pos,args); // 在pos之前插入args指定的字符
					// 如果args是下标，返回指向s的引用
					// 如果args是迭代器，返回第一个插入字符的迭代器
s.erase(pos,len);	// 删除从pos开始的len个字符
					// len可以省略，表示一直删除到结尾
					// 返回指向s的引用
s.assign(args);		// 将s替换为args指定的字符
					// 返回一个指向s的引用
s.append(args);		// 返回指向s的引用
s.replace(range,args);	// 删除s中range范围内的字符
						// 替换为args指定的字符
						// 返回指向s的引用
	// args可以是下列形式之一：
str;	// 字符串str
str,pos,len;	// str.substr(pos,len);
cp,len; // char*的前len个字符
cp;		// char*
n,c;	// n个字符c
b,e;	// [b,e)
il;		// initializer_list

// (3) 搜索string
	// 如果搜索成功，返回字符所在下标：
		// string::size_type类型值（无符号）
	// 否则，返回名为string::npos的static成员对象：
		// 标准库将npos定义为一个const string::size_type类型
		// 并初始化为-1，即size_type类型的最大可能值
s.find(args);          	  // 在s中查找第一个出现的args
s.rfind(args);			  // 在s中查找最后一个出现的args
s.find_first_of(args);    // 在s中查找第一个在args中的字符
s.find_last_of(args);	  // 在s中查找最后一个在args中的字符
s.find_first_not_of(args);// 在s中查找第一个不在args中的字符
s.find_last_not_of(args); // 在s中查找最后一个不在args中的字符
	// args 可以是下列形式之一：
c,pos;		// pos默认为0，字符c
s2,pos;		// pos默认为0，字符串s2
cp,pos;		// pos默认为0，字符数组c
cp,pos,n;	// pos无默认值



// (4) 子串
s.substr(pos,n); // 如果开始位置pos超过了string的大小，
				 // 抛出 out_of_range 异常；
				 // 如果开始位置加上长度n超过数组大小，
                 // substr会调整长度n，只拷贝到string的末尾。

// (5)数值转换
	// 数值转换时，不需要保证整个string是一个合法的数值形式
	// 只需要保证string中的一个子串是合法的数值形式
	// 如果我们不显示的指定第一个合法数值子串的位置
	// 需要保证字符串的第一个非空白字符必须是符号（+，-）或数字
	// 它可以是0x或0X表示的十六进制数
	// 若是浮点数，也可以以小数点（.）开头，可以包含e/E表示指数部分
	// 对于十六进制，也可以包含字母字符，对应大于9的数
to_string(val);	// 一组重载函数
				// val可以是任何算数类型，小整数会自动提升
stoi(s,p,b);  // b表示转换的基数，默认是10进制
stol(s,p,b);  // p是size_t指针,用来保存s中第一个非数值字符的下标
stoul(s,p,b); // 默认为0
stoll(s,p,b);
stoull(s,p,b);
stof(s,p);
stod(s,p);
stold(s,p);
```

## `[*]`三、适配器

**适配器（adaptor）**是标准库中的一个通用概念。容器、迭代器和函数都有适配器：

* 改变容器的接口，称为容器适配器；
* 改变迭代器的接口，称为迭代器适配器；
* 改变仿函数的接口，称为仿函数适配器。

本质上，适配器是一种机制（设计模式），使一种事物的行为类似于另外一种事物行为。以便以一种更符合特定场景的方式提供数据存储和检索功能。

例如我们可以通过修改 vector 或者 deque 的接口，使他们的行为看起来像 stack（一个先进后出的容器）。也可以修改 vector 和 list 的接口，使他们的行为看起来像一个 queue（一个先进先出的容器）。例如将 vector 的 push_back 修改为 push，将 pop_back 修改为 pop。由此，我们并没有修改 vector，却使他的行为既能看起像 stack，又能看起来像 queue。从而更符合特定场景的应用。所以说，通过适配器，开发者可以在不改变底层对象的情况下拓展和改变其接口和行为。

### 1. 容器适配器

除了顺序容器外，标准库还定义了三个顺序容器适配器。注意容器适配器并不是容器，它们不具有容器的某些特点（例如：有迭代器）。

* stack：先进后出，对 deque 的包装，也可以是 vector
* queue：先进先出对 deque 的包装，也可以是 list
* priority_queue：对 vctor 的包装

``` c++
// stack
s.pop();
s.push(item);
s.emplace(args);
s.top();
// queue, priority_queue
q.pop();
q.front();	// only queue
q.back();	// only queue
q.top();	// onlt priority_queue
q.push(item);
q.emplace(args);
```

底层容器是作为适配器类模板的第二参数出现的（第一参数是元素类型），因此我们可以显示指定底层容器的类型。并且可以通过 `container_type` 查看适配器的底层容器类型，它是一个类型别名。

``` c++
stack<int, vector<int>> s;
stack<int, vector<int>>::container_type v;
cout << typeid(v).name() << endl; // St6vectorIiSaIiEE
```

priority_queue 按照优先级从高到低排序。默认情况下使用标准库的 `operator <` 确定相对优先级。这也解释了，对于 `priority_queue<int> q;` 如果我们取 `q.top()` 会输出最大的元素，因为在 `operator <` 下，值越小的元素优先级越小。

### 2. 迭代器适配器

STL 提供了很多应用于迭代器的适配器，我们可以通过头文件 `iterator` 使用它们：

* back_insert_iterator
* front_insert_iterator
* insert_iterator：
* reverse_iterator：rbegin 和 rend 返回的迭代器
* istream_iterator
* ostream_iterator
* istreambuf_iterator
* ostreambuf_iterator
* 等等

### 3. 仿函数适配器

仿函数适配器是数量最庞大的适配器族群，使用也是最灵活的，可以嵌套使用。我们可以头文件 `functional` 使用它们：

* bind
* negate
* compose

## 四、泛型算法

很大程序上，容器只定义了**极少**的操作。比如构造函数，添加和删除元素，确定容器大小以及返回指向特定元素的迭代器的操作。其它一些有用的操作，如排序和搜索，并不是由容器定义的，而是由标准库算法实现的。

### 1. 概述

大多数算法都定义在头文件 `<algorithm>` 中。标准库还在头文件 `<numeric>` 中定义了一组数值泛型算法。

一般情况下，这些算法并不直接操纵容器，而是遍历由两个**迭代器**指定的一个元素范围。因此不能直接向容器中添加或删除元素。泛型算法运行在迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：<font color=blue>算法永远不会改变底层容器的大小</font>。

如果迭代器是 insert_iterator，是可以改变容器大小的。这是因为泛型算法是通过迭代器来操纵容器的，<font  color=blue>迭代器的能力决定了泛型算法的能力</font>。这也解释了为啥泛型算法无法执行容器的操作，因为迭代器并不是容器的对象。

泛型算法的一大优点是“泛型”，这就是一个算法可以用于多种不同的数据类型，算法与所操作的数据结构分离。而做法就是将迭代器作为算法和容器之间的桥梁，算法从不操作具体的容器，也就不存在与特殊容器绑定，不适用于其他容器的问题。也可以说，<font color=blue>算法根本不知道容器的存在</font>，算法只不过是通过迭代器操作某种类型的元素。

### 2. 泛型算法举例

#### （1）accumulate

accumulate 的第三个参数的类型决定了函数中使用那个加法运算以及返回值的类型。这有时会导致一些难以察觉的错误：

``` c++
vector<double> a{1.7, 2.8, 3.9};
auto s = accumulate(a.begin(), a.end(), 0); // 6
```

由于我们将第三个元素指定为 0，它会被视为 int 类型，因此这里求和时会将 double 元素视为 int 元素。

####（2）equal

equal 接受三个迭代器，前两个表示第一个序列的元素范围，第三个表示第二个序列的首元素。

注意对于这种接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少和第一个序列一样长。

和数组一样，编译器并不能检查出越界错误，此时产生的行为是未定义的。

#### （3）fill_n

``` c++
vector<int> v;
v.reserve(10);
fill_n(v.begin(), 10, 1024);
//cout << v.size() << ' ' << v.capacity() << endl;
for(auto &x : v)    
    cout << x << endl;
```

对于上面的代码，你以为会输出 10 个 1024？错误的，实际上代码的行为是未定义的。因为 reserve 只是为 vector 预留了空间（capacity），但实际上并没有在这个空间中创建对象（size）。因此 fill_n 是在没有任何元素的容器中执行初始化的，它的行为是未定义的。

实质上，泛型算法对容器的要求并不是有足够的空间，而是有足够的元素。

### 3. 定制操作

可以通过谓词来自定义泛型算法的一些条件判断。

谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。根据接受参数的不同，标准库算法所使用的谓词分为两类：一元谓词（unary predict）和二元谓词（binary predict）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。

不过有时候，我们希望进行的操作需要更多参数，超出了算法对谓词的限制（只能接受一个或两个参数）。这时我们可以向算法传递任意类别的可调用对象。对于一个对象或一个表达式,如果可以对其使用调用运算符，则称其为可调用的。例如函数，函数指针，lambda 表达式。

### 4. lambda

当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的匿名类类型。当我们向函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个匿名对象：传递的参数就是该匿名对象。类似的，当使用 auto 定义一个  lambda 初始化的变量时，定义了一个从 lambda 生成的类型的对象。

当我们使用值捕获时，必须保证被捕获对象可拷贝。拷贝发生在 lambda 创建时，因此在 lambda 创建之后，修改被拷贝对象的值不会影响 lambda：

``` c++
int val = 123;
auto it = [val]() {
    cout << "val: " << val << endl;
};
val = 456;
it();   // 123
```

当我们使用引用捕获时，必须确保被引用对象不会销毁。

lambda 的捕获列表只适用于局部非 static 变量，lambda 可以直接使用并修改局部 static 变量和在它所在函数之外的声明。

``` C++
int gi = 1024;

int main() 
{
    static int si = 666;

    []() {
        cout << gi << endl;
        cout << si << endl;
        gi = 11;
        si = 22;
    }();

    cout << gi << endl;
    cout << si << endl;

    return 0;
}
```

### 5. bind

尽管 lambda 很好用，但是如果我们需要在不同函数中使用 lambda 的话，唯一的办法就是在每个函数中写一遍 lambda，这显然不如直接定义一个函数来的好。但是函数很多情况下无法作为谓词，因为函数中的参数个数可能与算法的要求不匹配，通过 bind 可以解决这个问题。

bind 是一个仿函数适配器，它定义在头文件 `functional` 中。它接受一个可调用对象，生成一个新的可调用对象来“使用”原对象的参数列表。调用 bind 的一般形式为：

``` c++
auto newCallable = bind(callable, arg_list);
```

其中，arg_list 是一个逗号分隔的参数列表，对应给定的 callable 的参数。即，当我们调用 newCallable 时，newCallable 会调用 callable，并传入 arg_list。

arg_list 中的参数可能包含形如 `_n` 的名字，其中 n 是一个整数。这些参数是“占位符”，`_n` 就表示我们传递给 newCallable 的第 n 个参数。这些明明都定义在一个名为 `placeholders` 的命名空间中。而 `placeholders` 又定义在 `std` 中：`std::placeholders::_n`。

默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用对象中。但是，与 lambda 类似，有时我们希望以引用的形式传递参数。此时我们可以通过标准库的 `ref` 或者 `cref` 来解决这个问题，它们定义在头文件 `functional` 中，分别返回对象的引用和 const 引用。

``` C++
using namespace std;

using namespace placeholders;

void f(const int &a, int &b, int &c, int &d, const int &e)
{
    cout << a << endl;
    cout << b << endl;
    cout << c << endl;
    cout << d << endl;
    cout << e << endl;
    b >>= 1;
    c >>= 1;
    d >>= 1;
}

int global_val = 10;

int main() 
{
    static int static_val = 20;
    int local_val = 30;
    auto newf = bind(f, _2, ref(local_val), ref(static_val), global_val, _1);
    newf(40, 50);
    cout << local_val << endl;
    cout << static_val << endl;
    cout << global_val << endl;
    return 0;
}
```

### 6. 迭代器

除了为每个容器定义的迭代器之外，标准库在头文件 `iterator` 中还定义了额外几种迭代器模板：

* insert iterator
  * insert_iterator
  * front_insert_iterator
  * back_insert_iterator
* stream iterator
  * istream_iterator
  * ostream_iterator

* reverse iterator：除了 forward_list 之外的标准库容器都有反向迭代器
* move iterator

#### （1）insert iterator

``` C++
it = t;	// 在it指定的当前位置插入值t。
	    // 插入的方式依赖于it绑定的容器c，可能是：
		// c.push_back(t); 
		// c.push_front(t);
		// c.insert(t,p); 在p的之前位置插入元素t
*it, ++it, it++;
```

插入迭代器是一种迭代器适配器，用于将元素插入到容器中的特定位置。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。

插入迭代器有三种类型，差异在于元素插入的位置：

* `back_inserter(container)`：创建一个使用 `push_back `的 `back_insert_iterator` 类型的对象
* `front_inserter(container)`：创建一个使用 `push_front `的 `front_insert_iterator` 类型的对象
* `inserter(container, iter)`：创建一个使用 `insert `的 `insert_iterator` 类型的对象，在 iter 之前插入元素

`std::inserter`，`std::back_inserter` 和 `std::front_inserter` 都是**函数**，它们的作用是创建不同类型的**插入迭代器**。

`std::insert_iterator`，`std::back_insert_iterator` 和 `std::front_insert_iterator` 是类模板，我们可以直接定义并初始化它们的对象：

``` c++
vector<int> v = {1, 1, 2, 2, 3, 5, 6 ,7 ,8 ,8 ,9};
vector<int> p = {11, 22, 33, 44, 55};
insert_iterator<vector<int>> insertIter(p, p.begin() + 1);
unique_copy(v.begin(), v.end(), insertIter);
```

#### （2）stream iterator

istream_iterator 读取输入流，ostream_iterator 向一个输出流写数据。这两个迭代器将它们对应的流当作一个特定类型的**元素序列**来处理。通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。

##### istream_iterator 操作

istream_iterator 使用 >> 来读取流，因此 istream_iterator 要读取的对象必须定义了输入运算符。

``` c++
istream_iterator<T> in(is); // in从输入流is读取类型为T的值
istream_iterator<T> end;	// 表示尾后位置（EOF或IO错误）
							// 相当于end迭代器

in1 = in2;	// in1和in2必须是相同类型
in1 != in2; // 如果它们都是尾后迭代器或绑定到同一个输入对象则相等

*in;		// 返回从流中读取的值
in->mem;	// <=>(*in).mem
++in, in++; // 调用元素类型所定义的>>运算符从输入流中读取下一个值
```

<font color=blue>istream_iterator 允许使用**懒惰求值**</font>。当我们将一个 istream_iterator 绑定到一个流时，标准库并不保证迭代器立即从流中读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取数据。

标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取和推迟读取没什么差别。但是，如果我们创建了一个 istream_iterator 对象，没有使用就立即销毁了，或者我们正在从两个不同的对象同步读取一个流，那么何时读取可能就很重要了。

``` c++
istream_iterator<int> in(cin), eof;
// 计算我们读取的整型元素之和
cout << accumulate(in, eof, 0) << endl;
```

##### ostream_iterator 操作

``` c++
ostream_iterator<T> out(os);
ostream_iterator<T> out(os, d);	// d起分隔符的作用

out = val; // 用<<运算符将val写入到out所绑定的ostream中

*out, ++out, out++; // 这些运算符是存在的，但不对out做任何事情
					// 每个运算符都返回out
```

ostream_iterator 使用 << 来写入流，因此 ostream_iterator 要写入的对象必须定义了输出运算符。当创建一个 ostream_iterator 时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素之后都会打印此字符串。此字符串必须是一个 C 风格字符串（即，一个字符串字面值常量 `const char*` 或一个只想空字符结尾的字符数组的指针`char ch[]`）。必须将 ostream_iterator 绑定到一个流，不允许空的或表示尾后位置的 ostream_iterator。

``` c++
vector<int> v{1, 2, 3, 4, 5};
ostream_iterator<int> out(cout, " ");   // 用空格作为分隔符
for(auto &e : v)
    *out ++  = e; // 等价于 out=e;
cout << endl;
```

```C++
vector<int> v{1, 2, 3, 4, 5};
ostream_iterator<int> out(cout, ",");  
copy(v.begin(), v.end(), out);
```

虽然 `*out ++ =e` 与 `out = e` 在效果上是一样的，但是仍然推荐第一种形式。在这种写法中，流迭代器的使用和其他迭代器的使用形式保持一致。对于读者来说，行为也更加清晰。

#### （3）reverse iterator

反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增和递减的含义会颠倒过来：递增一个反向迭代器会向前移动元素，递减一个反向迭代器会向后移动元素。

除了 forward_list ，其它容器都有反向迭代器。我们可以通过 rbegin()，rend()，crbegin()，crend() 来获取反向迭代器。其中 rbegin() 指向最后一个元素，rend() 指向第一个元素的前一个位置（）。

通过反向迭代器可以方便的实现逆序 sort：

``` c++
sort(v.rbegin(), v.rend());
```

反向迭代器与正向迭代器可以相互转换：

``` c++
vector<int> v{0, 1, 2, 3, 4, 5};

vector<int>::iterator it = v.begin() + 1;
vector<int>::reverse_iterator rit(it);
vector<int>::iterator rrit = rit.base();
cout << *it << ' ' << *rit << endl; // 1,0
cout << *rit << ' ' << *rrit << endl; // 0,1  
```

其中，我们可以将一个正向迭代器直接赋值给反向迭代器；由反向迭代器得到正向迭代器必须通过反向迭代器的 base 成员函数。其中，从正向迭代器得到的反向迭代器指向前一个位置；从反向迭代器得到的正向迭代器指向下一个位置。也即，正向迭代器和反向迭代器相互转换得到的是相邻位置而不是相同位置。

这种设计主要是为了确保在相互转换时，正向迭代器和反向迭代器指向相同的元素范围，从而保证对某些元素，无论是正向处理还是逆向处理都是相同的。

* 对于逆向迭代器 [c.rbegin(), comma)，相应的正向迭代器范围为 [comma.next(), c.end())。`逆向转正向 -> next`
* 对于正向迭代器 [c.begin(), comma)，相应的反向迭代器范围为 [comma.prev(), c.rend())。`正向转逆向 -> prev`

这其实也反映了左闭右开的区间特性。

### 7. 泛型算法结构

#### （1）5 类迭代器

泛型算法是通过迭代器操纵容器的，因此任何算符的最基本的特性就是它要求其迭代器提供哪些操作。不同的泛型算法对迭代器提出了不同的要求。例如 find 要求迭代器有可以访问元素、递增和比较迭代器是否相等这些能力；sort 要求迭代器有读写和随机访问的能力。根据这些要求，泛型算法所要求的迭代器可以分为 5 种类别。每个泛型算法都会对它的每个迭代器参数指明须提供哪类迭代器（实际上是最小能力要求的迭代器）：

``` c++
input iterator;			// 只读，不写；单遍扫描，只能递增
output iterator;		// 只写，不读；单遍扫描，只能递增
forward iterator;	    // 可读写；多遍扫描，只能递增
bidirectional iterator; // 可读写；多遍扫描，可递增递减
random-access iterator; // 可读写；多遍扫描，支持全部迭代器运算
```

迭代器是按照它们所提供别的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的的迭代器支持底层类别迭代器的所有操作。

* 输入迭代器只用于顺序访问。对于一个输入迭代器，`*it++` 保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用于访问元素。因此，输入迭代器只能用于单遍扫描算法。例如 find 和 accumulate 函数；而 istream_iterator 是一种输入迭代器。
* 输出迭代器可以看作输入迭代器功能上的补集——只写而不读元素。我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如 copy 函数的第三个参数。ostream_iterator 是输出迭代器。
* 向前迭代器可以多次读写同一个元素，因此我们可以保存向前迭代器状态，从而多次扫描元素。forward_list 上的迭代器就是向前迭代器。
* 双向迭代器除了支持向前迭代器的操作之外，还支持递减运算符。算法 reverse_iterator 要求双向迭代器。
* 随机访问迭代器支持在常量时间内随机访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能。下标运算符 `iter[n]` 与 `*(iter[n])` 等价。算法 sort 要求随机访问迭代器。

#### （2）算法形参模式

大多数算法具有如下 4 种形式之一：
``` c+
func(beg, end, other args);
func(beg, end, dest, other args);
func(beg, end, beg2, other args);
func(beg, end, beg2, end2, other args);
```

* 几乎所有算法都接受一个输入范围 `[beg，end)` 来指定算法所操作的输入元素序列。
* 此外算法还可以指定一个目标位置（`dest`）或者第二个元素序列（`beg2` 或 `[beg2,end2)`）。
* 除了这些迭代器参数，一些算法还接受额外的，非迭代器的特定参数。例如接受一个函数指针来替代内置的 `operator <` 运算符。

对于第三个参数是一个目标位置（dest）或者是用一个首迭代器（beg2）表示一个元素范围的情况，算法会基于以下假设：

* dest 参数是一个表示算法可以写入的目的位置的迭代器。算法假定：按其需要写入数据，不管写入多少个元素都是安全的。
* 算法假定从 beg2 开始的范围与 beg 和 end 所表示的范围至少一样大。

如果 dest 是一个直接指向容器的迭代器，那么算法将输出数据写入到容器中已存在元素内。更常见的情况是，dest 被绑定到一个插入迭代器或一个输出迭代器，这两种情况下，不管要写入多少个元素都没问题。

#### （3）算法命名和重载规范

除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如：

* 如何提供一个操作代替默认的 < 或 == 运算符
* 算法是否将输出数据写入输入序列还是一个分离的目的位置
* 等等

##### 一些算法使用重载形式传递一个谓词

接受谓词参数来代替 `<` 或 `==` 运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。例如：

``` c++
unique(beg,end);		// 使用 == 运算符比较元素
unique(beg,end,comp);	// 使用copm比较元素
```

由于这两个版本在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义。

##### _if 版本的算法

接受一个元素值的算法通常有一个不同命的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的 `_if` 前缀：

``` c++
find(beg,end,val);		// 查找输入范围中val第一次出现的位置
find_if(beg,end,pred);  // 查找输入范围中第一个令pred为真的位置
```

因为两个版本接受相同数量的参数，可能产生重载歧义，虽然很罕见，毕竟类型不相同。但为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。

##### 区分拷贝元素的版本和不拷贝的版本

默认情况下，重排元素的算法将重排后的元素写回给定的输入序列种。这些算法还提供另一个版本，将元素写到一个指定的输出目标位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个 `_copy`：

``` c++
reverse(beg,end);
reverse_copy(beg,end,dest);
```

一些算法还同时提供 `_copy` 和 `_if` 版本。这些版本接受一个目的位置迭代器和一个谓词：
``` c++
// 去掉容器中的奇数元素
remove_if(v1.begin(), v1.end(), [](int i){
    return i & 1;
});
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i){ 
    return i&1;
});
```

### 8. 特定容器操作

与其他容器不同，容器类型 list 和 forward_list 定义了几个成员函数形式的算法。特别是，他们定义了独有的 sort、merge、remove、reverse 和 unique。通用版本的 sort 要求随机访问迭代器，因此不能用于 list 和 forward_list。

链表类型定义的其他算法的某些通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。

**对于 list 和 forward_list，应该优先使用成员函数版本的算法而不是通用的算法。**这很显然，既然它们额外定义了成员版本的算法，而不是使用泛型算法，就说明标准库定义的泛型算法要么不适用，要么性能不好。

* list 和 forward_list 成员函数版本的算法（这些操作都返回void）：

``` C++
// 标准库也有的
lst.merge(lst2);      // 排序合并，lst和lst2都必须是有序的
lst.merge(lst2,comp); // 合并之后，lst2的元素会被删除
					  // 第一版本使用<，第二个版本使用comp

lst.remove(val);     // 调用erase删除掉与给定值相等(==)
lst.remove_if(pred); // 或pred为真的元素

lst.reverse();

lst.sort();          // 使用<或comp比较元素
lst.sort(comp);

lst.unique();        // 调用erase删除同一个值的连续拷贝，使用==
lst.unique(pred);    // 使用pred代替==

// 链表特有的splice操作：
	// 将另一个链表的一部分移动到当前链表的特定位置
	// 时间复杂度为 O(1)，因为它不需要复制或重新分配节点内存
	// 它是导致链表 size() 慢的直接原因
	// p：当前链表中的迭代器,表示插入的具体位置
	// other_list：被移到的另一个链表，可以是当前链表，但p不能指向给定范围中的元素
	// args用于指定other_list移动元素的范围
	// 如果没有指定args，移动整个other_list
	// 被移动的元素将从other_list种删除
lst.splice(p,other_list, args);
forward_lst.splice_after(p,other_list, args);
	// args 的形式：
(b,e); // 移动 [b,e)
(p2);  // 对于list，将移动p2；对于forward_list，移动p2之后的元素

```

我们前面提到过，泛型算法并不直接改变他们所操作的容器的大小。他们会将元素从一个位置拷贝到另一个位置，但不会直接添加或删除元素。其实为什么不能改变容器大小的原因也很简单，因为它们不是成员函数，无法直接访问容器封装的底层数据。但是对于链表的成员函数来说，它们有权限访问链表的底层数据，因此链表的操作往往会改变底层数据来提高操作效率。

诸如 splice，merge，unique 都会改变底层容器，例如 merge 和 splice 会销毁参数。这是需要注意的点。这种实现可以让链表的操作效率更高。

### 9. 针对迭代器的泛型算法

对于链表类型，由于它的迭代器不是访问迭代器，我们不能通过递增和递减运算符移动迭代器，也不能对迭代器进行加减运算。这导致如果我们想获取一个元素中间位置的迭代器比较麻烦。例如我们想获取第三个位置的迭代器，我们不能 `c.begin() + 2`，而是要通过一个 for 循环将迭代器从 `c.begin()` 移动两步。这简直太麻烦了！

C++ 11 新标准引入了一些针对迭代器的算法：

``` c++
// C++11 之前就有的算法
	// n可正可负，负数表示向后移动（仅对双向迭代器适用）
template< class InputIt, class Distance >
void advance( InputIt& it, Distance n );

	// 适用于所有类型的迭代器。
template< class InputIt >
typename std::iterator_traits<InputIt>::difference_type
distance( InputIt first, InputIt last );

// C++11 之后引入的算法
	// 相当于advance的n为负数（仅对双向迭代器适用）
template< class BidirIt >
constexpr BidirIt prev( BidirIt it, typename std::iterator_traits<BidirIt>::difference_type n = 1 );

	// 相当于advance的n为整数
template< class InputIt >
constexpr InputIt next( InputIt it, typename std::iterator_traits<InputIt>::difference_type n = 1 );
```

上面这些针对移动迭代器或计算两个迭代器之间距离的操作，对于随机访问迭代器的时间复杂度是 O(1)；对于其他可行迭代器的时间复杂度为 O(N)。



















































































## 五、关联容器

``` c++
// ordered
map
set
multimap
multiset
// unordered
unordered_map
unordered_set
unordered_multimap
unordered_multiset
```

### 1. 迭代器

对关联容器解引用得到的是一个 value_type 类型的迭代器：

* 对于 map 来说，value_type 是一个 `pair<const Key, Value>`，因此我们不能修改 map 的关键字；
* 对于 set 来说，虽然 value_type 是 `Key`，并且 set 同时定义了 iterator 和 const_iterator，但两种类型都只允许访问 set 中的元素。

事实上，我们没有任何办法修改 set 中的元素。除非先删除它再插入我们想要的元素。

关联容器也有 `begin` 和 `end` 成员函数，并且可以像顺序容器一样遍历容器元素。而且关联容器的迭代器都是双向的，这意味着它支持 `++` 和 `–-` 操作。 

### 2. 构造函数

关联容器的构造函数类型是比较丰富的。我们可以用范围迭代器来初始化关联容器，只要元素类型可以转换。也可以通过 initializer_list 进行初始化。并且可以指定 Compare 和 Alloc。具体的可以见 $cppreference$。

### 3. 关键字类型的要求

#### （1）有序容器

对于有序容器，关键字类型必须提供元素比较的方法。默认情况下，标准库通过关键字类型的 `operator<` 运算符来比较两个元素。

有两种自定义比较函数的方法：

* 在 class 内部定义比较函数，此时定义 set 时无需显示指定比较函数

``` C++
struct Node {
    int val;
    bool operator<(const Node &x) const {
        return val < x.val;
    }
};

set<Node> s;
```

* 在 class 外部定义比较函数，此时定义 set 时需要显示的指定比较函数。

 ``` C++
 struct Node {
     int val;
 };
 
 bool cmp(int a, int b) 
 {
     return a < b;
 }
 
 // set<int, decltype(&cmp)> s(cmp);
 set<int, decltype(cmp)*> s(cmp);
 ```

在解释第二种方法之前，先来看一下 STL 中 map 和 set 的定义：

``` c++
// map
template<typename Key, typename T, typename Compare = less<Key>, typename Alloc = alloc>
class map {
    typedef Key key_type;
    typedef Value mapped_type;
    typedef pair<const Key, T> value_type;	// const key
private:
    typedef rb_tree<key_type, value_type,
                    select1st<value_type>, key_compare, Alloc> rep_type;
    rep_type t;
};

// set
template<typename Key, typename Compare = less<Key>, typename Alloc = alloc>
class set {
    typedef Key key_type;
    typedef Key value_type;
private:
    typedef rb_tree<key_type, identity<value_typem>,
                    key_compare, Aloc> rep_type;
    rep_type t;
};
```

<font color=blue>《C++ Prime》中说：用来组织一个容器中元素的操作的类型也是该容器类型的一部分，因此说一般来说，用于比较的 Compare 和用于分配的 Alloc 都是容器类型的一部分。</font>

因此说，`decltype(cmp)*` 就是在指定比较函数的类型，注意这个类型应该是一个函数指针，因此这里需要加上一个 `*`，也可以直接对函数取地址：`decltype(&cmp)`。

另外这里仅仅是指定了比较函数的类型，我们还需要将比较函数的对象（函数指针）传入容器的构造函数当中：`s(cmp)`。

#### （2）无序容器

对于无序容器，关键字类型必须哈希函数和 `operator==`。我们可以看一下具体的 class 定义：

``` c++
// unordered_set
template<
    class Key,
    class Hash = std::hash<Key>,		  // 哈希函数
    class KeyEqual = std::equal_to<Key>,  // operator==
    class Allocator = std::allocator<Key> // Alloc
> class unordered_set;
explicit unordered_set( 
    size_type bucket_count, // 桶的最少数量,初始化为0将由容器自动管理
	const Hash& hash = Hash(),
	const key_equal& equal = key_equal(),
	const Allocator& alloc = Allocator() 
);

// unordered_multiset
template<
    class Key,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator<Key>
> class unordered_multiset;
explicit unordered_map( 
    size_type bucket_count,
    const Hash& hash = Hash(),
    const key_equal& equal = key_equal(),
    const Allocator& alloc = Allocator() 
);

// unordered_map
template<
    class Key,
    class T,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator<std::pair<const Key, T>>
> class unordered_map;
explicit unordered_multimap( 
    size_type bucket_count,
    const Hash& hash = Hash(),
    const key_equal& equal = key_equal(),
    const Allocator& alloc = Allocator() 
);

// unordered_multimap
template<
    class Key,
    class T,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator<std::pair<const Key, T>>
> class unordered_multimap;
explicit unordered_multiset( 
    size_type bucket_count,
    const Hash& hash = Hash(),
    const key_equal& equal = key_equal(),
    const Allocator& alloc = Allocator() 
);
```

和有序容器一样，我们也有多种方法来实现自定义类型的哈希函数和 `operator==`。

对于比较函数，我们可以在 class 内部定义，也可以在 class 外部定义。当在 class 外部定义时，我们也需要指定函数指针的类型并传入该对象。

对于哈希函数（哈希仿函数模板），我们可以在 `std` 命名空间中偏特化 `hash` 模板，也可以在外部定义一个哈希函数。

* class 内的 `operator==` 函数和偏特化 `hash` 模板

``` c++
struct Node {
    int val;
    bool operator==(const Node &x) const {
        return val == x.val;
    }
};

// 偏特化的hash模板需要放在std命名空间
namespace std {
    template<>
    struct hash<Node> {
        size_t operator()(const Node &x) const {
            return hash<int>()(x.val);
        }
    };
}

void way1()
{
    unordered_set<Node> ass;
    for(int i = 0; i < 10; i ++ )
        ass.insert({i});
    cout << ass.bucket_count() << endl;    
}
```

* class 外部的 `operator==` 和哈希函数

``` c++
struct Node {
    int val;
};

bool is_equal(const Node &lhs, const Node &rhs)
{
    return lhs.val == rhs.val;
}

size_t hasher(const Node &x)
{
    return std::hash<int>()(x.val);
}

void way2()
{
    using node_unordered_set = unordered_set<Node, 
                decltype(&hasher), 
                decltype(&is_equal)>; 
    // unordered_set第一个参数是桶的数量,传入0让容器自动管理
    node_unordered_set ass(0, hasher, is_equal);

    for(int i = 0; i < 10; i ++ )
        ass.insert({i});
    cout << ass.bucket_count();
    return 0;
}
```







### 5. 泛型算法

我们通常不对关联容器使用泛型算法。关键字是 const 意味着不能将关联容器传递给修改或重排容器元素的算法。

关联容器可用于只读元素的算法。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行快速查找，因此对其使用泛型搜索算法总是个坏主意。不过关联容器一般是实现了自己的搜索成员函数，例如关联容器专用的 find 成员函数就比泛型的 find 函数快得多，泛型 find 函数会进行顺序搜索。

在实际编程中，如果我们真要对一个关联容器使用算法，要么是把他当作一个源序列，要么是把它当作一个目的位置。例如 copy 算法。

### 6. 添加元素

``` c++
c.insert(v);
c.emplace(args);

c.insert(b,e);	// 返回void
c.insert(il);	// 返回void

c.insert(p,v);	   // 迭代器p作为一个提示，
c.emplace(p,args); // 指出从哪里开始搜索元素应该存储的位置。
```

由于 map 和 set（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。

insert（or emplace）返回的值依赖于容器类型和参数，对于传入一个迭代器或者一个 initializer_list 的 insert 版本，返回 void。否则：

* 如果容器类型是 non-multi 版本：返回 `pair<iterator,bool>`，其中 iterator 是指向插入元素的迭代器；bool 是标志插入是否成功
* 如果容器类型是 multi 版本：返回指向插入元素的迭代器。multi 版本可以插入重复的关键字，因此总是插入成功，无需返回 bool 值

### 7. 删除元素

``` C++
c.erase(key); // 根据关键字key删除，返回实际删除的元素数量
c.erase(p);	  // 返回一个指向迭代器p之后元素的迭代器，p不能为end	
c.erase(b,e); // 删除[b,e)，返回e
```

### 8. map的下标操作

map 又称为关联数组，即通过关键字而不是位置来索引的数组。

map 和 unordered_map 容器提供了下标运算符和一个对应的 at 成员函数。set 不支持下标，因为下标是“获取与一个关键字相关联的值”的操作，而 set 中关键字就是值。

与其它下标运算符不同的是，如果关键字不在 map 中，会为它创建一个元素并插入到 map 中，关联值会进行值初始化。

例如，如果我们编写下面代码：

``` c++
map<string, int> word_count;
word_count["hello"] = 1;
```

对于第二条语句，将会执行如下操作：

* 在 word_count 中搜索关键字为 hello 的元素，未找到
* 将 `pair<string,int>{"hello",int()}` 插入到 word_count
* 提取出新插入的元素，并将值 1 赋予它

由于下标运算符会自动插入元素，因此对于 const 类型的 map，无法使用下标运算符。

我们可以使用 at 成员函数来避免下标运算符自动插入元素的问题，当关键字不存在时，at 会抛出 out_of_range 异常。也可以使用 find 成员函数。

另外一个与其它下标运算符不同的点就是。map 的下标运算符和迭代器解引用返回类型不执行。下标返回 mapped_type；迭代器解引用返回 value_type。

``` C++
// 打印map中所有值为key的元素的value 
multimap<string, int> ass = {
    {"a1", 1}, {"a2", 2}, {"b1", 3},
    {"b1", 4}, {"b1", 5}, {"b2", 6},     
};

int main() 
{
    // (1) find + count
    {
        auto start = ass.find("b1");
        auto count = ass.count("b1");
        while(count -- ) 
        {
            cout << start ++ ->second << ' ';
        }
        cout << endl;
    }
    // (2) lower_bound + upper_bound
    {
        for(auto begin = ass.lower_bound("b1"), 
            end = ass.upper_bound("b1"); begin != end; ++ begin)
        {
            cout << begin->second << ' ';
        }
        cout << endl;
    }
    // (3) equal_range
    {
        for(auto pos = ass.equal_range("b1"); 
            pos.first != pos.second; pos.first ++ )
        {
            cout << pos.first->second << ' ';
        }
        cout << endl;
    }
    return 0;
}
```

### 9. 访问元素

``` C++
// []只适用于非const的map和unordered_map
// at只适用于map和unordered_map
c[key];
c.at(key);

c.find(key);// 返回迭代器，若找不到返回end
			// 对于multi版本，返回第一个关键字为key的元素的迭代器
c.count(key);

// lower_bound和upper_bound不适用于无序容器
c.lower_bound(key); // 第一个>=key的元素
c.upper_bound(key);	// 第一个>key的元素
c.equal_range(key);	// 返回一个迭代器对，表示关键字等于key的元素的范围（前闭后开）。若key不存在，返回两个end
```

其中，equal_range 返回的迭代器对就等价于 `pair{c.lower_bound(key), c.upper_bound(key)}`。

### 10. 小练习

``` C++
map<string, string> buildMap(ifstream &mapped)
{
    map<string, string> word_map;
    string line;
    while(getline(mapped, line))
    {
        string key, value;
        istringstream s(line);
        s >> key;
        getline(s, value);
        // cout << "size: " << value.size() << endl;
        // cout << "value: " << value << endl;
        if(value.size() > 1)
            word_map.insert({key, value.substr(1)});
        else 
            throw(runtime_error("no rule for " + key));
    }
    return word_map;
}

string transform(string word, const map<string,string>& word_map)
{
    auto it = word_map.find(word);
    if(it == word_map.end())
        return word;
    return it->second;
}

// mapped储存了K-V形式的映射关系
// input是输入
void word_transform(ifstream &mapped, ifstream &input)
{
    auto word_map = buildMap(mapped);
    
    string line;
    while(getline(input, line))
    {
        istringstream s(line);
        string word;
        bool firstword = true;
        while(s >> word)
        {
            if(firstword)
                firstword = false;
            else 
                cout << " ";
            cout << transform(word, word_map);
        }
        cout << endl;
    }
}

int main()
{
    ifstream mapped_file("mapped.txt");
    ifstream input("input.txt");
    word_transform(mapped_file, input);
    return 0;
}
```

### 12. 无序容器

无序容器不再使用比较运算符组织元素，而是使用一个哈希函数（将给定类型的值映射到整形 size_t 值的函数）和关键字类型的 `==` 运算符来比较元素。对于关键字可重复的无序容器，相同关键字被组织在同一个桶中。

无序容器还用一个 `hash<key_type>` 类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了 `hash` 模板。还为一些标准库类型（string、智能指针）定义了 `hash` 模板。如果我们关键字的类型是未提供 `hash` 模板的类型或自定义类型，则必须提供我们自己的 `hash` 模板版本。

> C++ 中，`hash` 是一个仿函数模板。我们可以通过模板偏特化来为自定义类型定义 `hash` 函数。不过要注意 `std::hash` 是定义在 `std` 命名空间中的，因此要特化它时，需要使用 **嵌套命名规范**。
>
> 在哈希模板中定义 `size_t operaotr()() const;` 即可自定义我们的哈希函数了。

除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作。这意味我们可以在无需容器和有序容器可以相互替换。

哈希表的底层数据结构是哈希桶数组（拉链法），C++ 提供了一组管理桶的函数。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组：

``` c++
// 桶接口
c.bucket_count();	
c.max_bucket_count(); // 容器能容纳的最多的桶的数量
c.bucket_size(n); // 第n个桶有多少元素
c.bucket(k);	  // 关键字为k的元素在那个桶

// 桶迭代
local_iterator;	// 访问桶中元素
const_local_iterator;
c.begin(n), c.end(n);	// 桶n的begin和end迭代器
c.cbegin(n), c.cend(n);

// 哈希策略
c.load_factor();	// 每个桶的平均元素数量，返回float值
c.max_load_factor();// c试图维护的平均桶大小，返回float值
					// c会在需要时添加新的桶
					// 使load_factor<=max_load_factor
c.rehash(n);	// 重新存储，使bucket_count>=n
				// 且bucket_count>size/max_load_factor
c.reserve(n);   // 重组存储，使得c可以保存n个元素而不必rehash
```

## 六、动态内存

标准库在头文件 `memory` 中定义了两种类型的智能指针模板，它们对底层指针采取不同的管理方式：shared_ptr 共享底层指针，unique_ptr 独占底层指针。此外，标准库还定义了一个名为 weak_ptr 的伴随类，它是一种弱引用，指向 shared_ptr 所管理的对象。

### 1. 成员函数

shared_ptr 和 unique_ptr 都支持的操作：

``` c++
shared_ptr<T> sp; // 空智能指针，指向nullptr
unique_ptr<T> up;
p;	// 将p作为一个条件判断，若p指向一个对象则为true
*p;
p->mem;
p.get(); // 返回p中保存的指针。要小心使用，若智能指针释放了其对象
		 // 返回的指针所指向的对象也就消失了
swap(p, q);
p.swap(q);
```

shared_ptr 独有的操作：

```c++
make_shared<T>(args);
shared_ptr<T> p(q);
p = q;
p.unique(); // 若p.use_count()为1，返回true
p.use_count(); // 速度可能比较慢
```

### 2. 引用计数

到底是用一个计数器还是其它数据结构来记录有多少指针共享对象，完全取决于标准库的具体实现。但这不重要，重要的是智能指针类能记录有多少个 shared_ptr 指向相同的对象，并能在恰当的时候自动释放对象。

一种简单的设计方法是将引用计数设计为类内一个指向整型的指针成员，通过浅拷贝指针，不同的类实例就可以共享引用计数。

### 3. 直接管理内存

相较于使用智能指针，当我们直接使用管理内存的类时，不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。

默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值是未定义的，而类类型对象使用默认构造函数进行初始化。因此，出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是个好主意。

类似于其它任何 const 对象，一个动态分配的 const 对象必须进行初始化。对于有默认构造函数的类类型来说，可以隐式初始化。

``` c++
const int *p = new const int(10);
```

通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。当我们 delete 掉一个指向静态对象或重复 delete 时，编译器并不会报错。

> 使用 new 和 delete 管理动态内存存在三个常见问题：
>
> 1. 忘记 delete 内存
> 2. 同一块内存释放两次
> 3. 使用已经释放掉的对象

当我们 delete 掉一个指针之后，指针值就变得无效了，但在很多机器上指针仍然保存着已经释放了的动态内存的地址。此时的指针就是所谓的空悬指针（dangling pointer），即，只想一块已经被释放了的内存的指针。

未初始化指针的所有缺点空悬指针也有。有一种办法可以避免空悬指针，那就是在 delete 掉动态内存之后，将指针的值设为 NULL。但这也只是提供了有限的保护，因为实际应用中可能有多个指针指向同一块动态内存，那么我们在 delete 掉这个动态内存之后，总不能手动将所有指针的值置位 NULL 吧。查找所有指向同一块动态内存的指针可不是一件容易的事情。

### 4. shared_ptr 

``` c++
shared_ptr<T> p(q);	   // q可以是shared_ptr和内置指针
shared_ptr<T> p(q, d); // d是我们指定的delete函数

p.reset();	   // p置位空
p.reset(q);    // p置位q
p.reset(q,d);  // p置位q，并指定delete函数

make_shared<T>();
```

前面提到过，如果我们不初始化一个智能指针，它就会被初始化为空指针。除了使用 make_shared 初始化外，还可以使用 new 来初始化。

``` C++
shared_ptr<int> p(new int(10));
shared_ptr<int> p = new int(10);	// wrong
```

不过要注意上面第二种写法是错误的，因为我们不能进行内置指针到智能指针间的隐式转换。

注意不能直接将 unique_ptr 赋值给 shared_ptr，应该使用 move：

``` C++
unique_ptr<Foo> u(new Foo(10));
shared_ptr<Foo> s = move(u);
if(u == nullptr)    
    cout << "yes";	// yes
```

尽管 shared_ptr 可以自动销毁，但这并不意味着它就可以避免内存浪费。例如我们将 shared_ptr 存放于一个容器中，而后不再需要全部元素，只使用其中的一部分，要记得用 erase 删除不需要的元素。

### 5. 不要混合使用普通指针和智能指针

对于下面的代码：

``` c++
int *p = new int(10);
int *q = new int(20);
shared_ptr<int> sq(p);
shared_ptr<int> uq(q);
cout << sq.use_count() << endl; // 1
cout << uq.use_count() << endl; // 1
```

我们说这是一种不好的写法：

* 对于 shared_ptr 来说，如果它被销毁了，那么 p 就成了一个悬空指针，而且我们无法得知何时对象会被 delete 掉，因为在某些机器中，即使对象被 delete 掉，指针也仍然指向原来对象所处地址。
* 对于 unique_ptr 来说，就更糟糕了，因为 unique_ptr 的本意是独占对象，但实际上我们可以通过 q 来修改对象。同样的，unique_ptr 也存在空悬指针的问题。

并且如果我们无意中 delete 掉了底层指针（p 和 q），那么智能指针再 delete 时就会两次 delete 错误。

例如下面的代码，我们会在不经意间创造空悬指针：

``` c++
void process(shared_ptr<int> q) {}

int main()
{
    int *p = new int(10);
    process(shared_ptr<int>(p)); // p所指向对象被释放
    delete p; // double delete
    return 0;
}
```

在上面的代码中，由于我们无法将 int* 转换为 shared_ptr 类型，因此我们传入一个匿名 shared_ptr 对象，但这将导致 p 称为一个空悬指针。

因此说，不要用内置指针初始化智能指针，这是一种很不好的写法。推荐的写法是通过工厂函数 make_shared 和 make_unique 来初始化智能指针，或者直接用 new 来初始化。

### 6. get

不要使用 get 初始化另一个智能指针或为智能指针赋值。**get 的设计只为针对一种情况：向不能使用智能指针的代码传递一个内置指针。**并且使用 get 返回的指针的代码不能 delete 此指针。

### 7. 异常

前面我们提到过异常安全的代码可以确保异常发生后资源能被正确的释放，而一个简单的确保资源被正确释放的方法就是使用智能指针。智能指针默认执行 delete 操作，对于类通过析构函数清理对象使用的资源。

但是并不是所有的类都定义了析构函数，特别是那些为 C 和 C++ 两种语言设计的类，通常都要求用户显示的释放所使用的任何资源。这个时候我们可以在智能指针中显式指定删除器（删除函数）。要注意删除器的格式有要求：

``` c++
// 返回类型为void
// 参数类型为指向对象类型的指针
// 实际上就等价于类的析构函数，这个指针就是this指针
void deleter(T *ptr) {
    // ...
}
```

例如下面的例子，假设我们有一个网络库，通过 connect 返回连接对象，最后需要调用 disconnect 来清理资源，我们把清理资源的步骤托管给智能指针：

``` c++
class connection {};

connection connect()
{  
    connection c;
    // ...
    return c;
}

void disconnect(connection c)
{
    // ...
    cout << "disconnect" << endl;
}

// 包装disconnect适配deleter的格式
void end_connection(connection *c)
{
    disconnect(*c);
}

void process()
{
    connection c = connect();

    // (1) lambda
    shared_ptr<connection> p(&c, [](connection *c){
        disconnect(*c);
    });

    // (2) function
    // shared_ptr<connection> q(&c, end_connection);
}
```

### 8. 智能指针使用规范

1. 不使用相同的内置指针初始化（或 reset）多个智能指针
2. 不 delete get() 返回的指针
3. 当你使用 get() 返回的指针时，注意最后一个智能指针被销毁后，该内置指针变为无效
4. 如果你使用的智能指针管理的资源不是 new 分配的内存，记得传递给他一个删除器
5. 不要混合使用智能指针和内置指针。如果不得不需要先定义内置指针再用智能指针管理内置指针，那么内置指针往后便不要再使用了

对于第一点，有一个可能忽视的错误：

``` c++
struct Foo {
    ~Foo() {
        cout << "~Foo" << endl;
    }
};

Foo *f = new Foo();

void f1()
{
    shared_ptr<Foo> sp1(f);
    shared_ptr<Foo> sp2(f);
    cout << sp1.use_count() << ',' << sp2.use_count() << endl; // 1,1 
}
```

对于上面的代码，使用 f 分别初始化了 sp1 和 sp2 两个智能指针，但要注意虽然这两个智能指针都以 f 初始化，但它们并不共享引用计数。这意味着他们的引用计数都是 1，因此在函数结束之后都会执行 delete，所以此时 f 会被 double delete。

### 9. unique_ptr

``` C++
unique_ptr<T> u;
unique_ptr<T,D> u;
unique_ptr<T,D> u(d);

u = nullptr;
u;
*u;
u->mem;

u.release()； // 返回底层指针并释放对底层对象的所有权（u置为空）
u.get();
    
u.reset();
u.reset(q);
u.reset(nullptr);

p.swap(q);
swap(p, q);
```

可以发现一个与 shared_ptr 显著不同的点，那就是如果我们想要指定删除器，需要同时在模板中指定删除器的类型。

``` c++
void deleter(int *p)
{
    cout << "delete int" << endl;
    delete p;
}

unique_ptr<int, decltype(&deleter)> q(new int(10), deleter);
```

另外就是 release 和 get 本质上都是返回底层指针，但 release 还会释放对底层指针的所有权。

虽然我们不能拷贝或赋值 unique_ptr，但可以通过调用 release 或 reset 将指针的所有权从一个（非 const）unique_ptr 转移给另一个 unique_ptr。

不过不能拷贝 unique_ptr 的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 unique_ptr。最常见的例子是从函数返回一个 unique_ptr：

``` C++
// way1
template<typename T>
unique_ptr<T> ret_unique(const T &val)
{
    return unique_ptr<T>(new T(val));
}

// way2
template<typename T>
unique_ptr<T> ret_unique(const T &val)
{
    unique_ptr<T> p(new T(val));
    return p;
}
```

### 10. weak_ptr

``` C++
weak_ptr<T> w;     // 空指针
weak_ptr<T> w(sp); // 绑定到shared_ptr
w = p;	           // p可以是shared_ptr也可以是weak_ptr

w.reset();         // 将w置为空
w.use_count();
w.expired(); // 若use_count为0返回true，否则返回false
w.lock();	 // 如果expired为true，返回空shared_ptr
			 // 否则返回一个指向w的对象的shared_ptr
```

weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向一个 shared_ptr 管理的对象。**将一个 weak_ptr 绑定到一个 weak_ptr 不会改变 shared_ptr 的引用计数。**

由于 weak_ptr 指向的对象可能被不知不觉的释放，因此我们不能使用 weak_ptr 直接访问对象，而必须调用 lock，此函数会检查 weak_ptr 指向的对象是否仍然存在：

``` c++
shared_ptr<int> sp(new int(10));
weak_ptr<int> wp(sp);
if(wp.lock())
{
    // ....
    cout << *wp.lock() << endl;
}
```

### 11. 动态数组

大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。

#### （1）array new

所谓的动态数组，实际上就是 _array new_：`T *p = new T[size];` 其中方括号中的 size 必须是个整数，但不必是常量。

虽然我们通常称 `new T[]` 分配的内存为“动态数组”，但这种叫法某种程度上有些误导。<font color=blue>当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针（指向数组首元素的指针）。</font>由于分配的内存并不是一个数组类型，所以我们不能对动态数组调用 `begin` 或 `end`，也不能用范围 `for` 循环来处理所谓动态数组中的元素：

``` c++
// 数组可以调用begin、end和范围for循环
int a[] = {1, 2, 3, 4, 5};
for(auto &x : a)
    cout << x << ' ';
cout << endl;
for(auto b = begin(a), e = end(a); b != e; b ++ )
    cout << *b << ' ';
cout << endl;
```

#### （2）动态数组初始化

默认情况下，new 分配的对象，无论是单个分配还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在方括号之后跟一对圆括号或一对花括号：

``` c++
int *p = new int[5]{1, 2, 3, 4, 5};      // 1,2,3,4,5
int *q = new int[4]{1}; // 1,0,0,0,0
vector<int> *v = new vector<int>(3, 1);  // 1,1,1
vector<int> *v2 = new vector<int>{3, 1}; // 3,1
```

与内置数组对象的初始化一样，如果初始化列表元素个数少于数组大小，剩余元素会值初始化。

#### （3）动态分配空数组

动态分配一个空数组是合法的。虽然我们不能创建一个大小为 0 的静态数组对象，但当 size 为 0 时，调用 new T[size] 是合法的：

``` c++
int *p = new int[0];	
if(p == nullptr)    puts("yes");
else    puts("no");
// no
delete[] p;
```

并且我们可以发现，new 返回的指针不指向 nullptr，也即，此时 new T[0] 返回一个合法的**非空指针**。

此指针与 new 返回的其他任何指针都不相同。它就像一个尾后指针一样，我们可以像尾后迭代器一样使用这个指针，例如加 0 或者减去 0、进行比较操作或与自身相减从而得到 0 。但不能对该指针解引用——毕竟他不指向任何元素。另外，指针非空意味着我们可以对它执行 delete[] 操作。

这种行为的设计是为了保证一致性和可预测性。即使数组大小为 0，返回一个有效指针可以简化代码中的一些逻辑检查，比如在动态数组的使用中无需特别判断大小是否为 0，从而减少特殊情况的处理。

#### （4）array delete

_array new_ 正序构造元素，_array delete_ 逆序销毁元素：

``` C++
struct Foo {
    Foo(int _val = 0) : val(_val) { cout << "ctor: " << _val << endl; }
    ~Foo() { cout << "dtor: " << val << endl; }
    int val;
};

int main() 
{ 
    Foo *p = new Foo[3]{1, 2, 3};
    delete[] p;
    return 0;
}
// ctor: 1
// ctor: 2
// ctor: 3
// dtor: 3
// dtor: 2
// dtor: 1
```

对于 *array new* 分配的元素，如果我们没有使用 *array delete* 进行销毁而是使用普通的 *delete*，其行为是未定义的。

#### （5）智能指针和动态数组

##### unique_ptr

标准库提供了一个可以管理 new 分配的数组的 unique_ptr 版本。为了使用一个 unique_ptr 管理动态数组，我们必须在对象类型后面跟一对空方括号：

``` c++
unique_ptr<int[]> p(new int[5]{1,2,3,4,5});
for(int i = 0; i < 5; i ++ )    cout << p[i] << endl;
p.release(); // 自动用delete[]销毁其指针
```

指向数组的 unique_ptr 提供的操作与指向单个对象的 unique_ptr 有些不同。例如我们不能使用点和箭头成员运算符，毕竟 unique_ptr 指向的是一个数组而不是单个对象，因此这些运算符是无意义的。另一方面，当一个 unique_ptr 指向一个数组时，我们可以使用下标运算符来访问数组中的元素：

``` c++
// 指向数组的 unique_ptr 不支持成员访问运算符（点和箭头运算符）
// 其它 unique_ptr 操作不变
unique_ptr<T[]> u;
unique_ptr<T[]> u(p);
u[i];

u.release();
// ....
```

##### shared_ptr

与 unique_ptr 不同，shared_ptr 不直接支持管理动态数组。如果希望使用 shared_ptr 管理一个动态数组，必须提供自己的删除器，因为 shared_ptr 默认使用 delete 而不是 delete[] 销毁元素：

``` c++
// 注意元素类型是Foo，不是 Foo[]
shared_ptr<Foo> sp(new Foo[3]{1,2,3}, [](Foo *p){
    delete[] p;
});
```

另外 shared_ptr 不直接支持管理动态数组的特性也会影响我们如何访问数组中的元素：

``` C++
// shared_ptr未定义下标运算符。并且不支持指针的算数运算
shared_ptr<int> sp(new int[3]{1,2,3}, [](int *p){delete[] p;});
for(int i = 0; i < 3; i ++ ) 
    // 先获取内置类型的指针，再进行指针加法来移动指针
    cout << *(sp.get() + i) << endl;
```

由于 shared_ptr 未定义下标运算符，并且智能指针不支持指针算数运算。因此，为了访问数组中的元素，必须使用 get 获取内置指针，然后用它来访问数组元素。

### 12. class allocator

#### （1）new的局限性

new 和 delete 有一些局限性：这体现在 new 将分配内存和构造函数绑定在了一起，而 delete 将释放内存和析构函数绑定在了一起。但有些时候，我们只想分配一块大内存，然后在这块内存上按需构造对象，即，我们希望将内存分配与对象构造分离，从而在真正需要时才创建对象。

而且，一般情况下将内存分配与对象构造绑定在一起可能会导致不需要的浪费：

``` c++
string *const p = new string[n];
string s;
string *q = p;
while(cin >> s && q != p + n)
    *q ++ = s;	// 默认初始化之后就赋值了
const size_t size = q - p;
cout << "size: " << size << endl;
delete[] p;   
```

咋还上面的代码中，我们分配并初始化了 n 个 string 对象。但是，我们可能不需要 n 个 string，少量 string 可能就足够了。这样，我们就可能创建了一些永远也用不到的对象。而且，对于那些确实要用到的对象，我们也在初始化之后立即赋予了它们信的值。每个对象被赋值了两次：第一次是在默认初始化时，随后是在赋值时。

更重要的是，那些没有默认构造函数的类可能就不能动态分配内存了。

#### （2）allocator类

标准库 allocator 类定义在头文件 `<memory>` 中，它帮助我们将内存分配与对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。

类似 vector，allocator 是一个模板。为了定义一个 allocator 对象，我们必须指明这个 allocator 可以分配的对象类型。当一个 allocator 对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：

``` c++
allocator<T> a;		// 定义一个allocator对象
				    // 它可以为类型为T的对象分配内存

a.allocate(n);		// 分配一端原始的、未构造的内存
					// 这段内存可以保存n和T类型的对象
a.deallocate(p,n);  // 释放T*指针p中地址开始的内存
		// p必须是一个由allocate(n)返回的指针，
		// 且分配与销毁时的n必须一致
	    // 在销毁之前用户必须对每个在这块内存中的对象调用destory

a.construct(p,args); // p为T*类型的指针，只想一块原始内存
					 // 以args为参数调用类型为T的构造函数
a.destory(p);	// p为T*类型的指针，对p指向的对象执行析构函数
				// 只能为真正构造了的对象执行destory
				// 被销毁后的对象做出内存可以重新构造来储存新对象
```

简而言之，allocator 的使用步骤大致为：

1. 创建一个类型为 T 的allocator 对象
2. 调用 allocate 函数分配原始内存
3. 调用 construct 函数执行构造函数
4. 调用 destory 函数执行析构函数
5. 调用 deallocate 函数销毁内存

实际上就是把 new 的分配内存和调用构造函数的操作分开了。

``` c++
allocator<Foo> alloc;
auto *p = alloc.allocate(3); 
cout << "allocate done" << endl;
for(int i = 0; i < 3; i ++ )
    alloc.construct(p + i, i);
for(int i = 0; i < 3; i ++ ) 
    cout << p[i].val << endl;
for(int i = 0; i < 3; i ++ )
    alloc.destroy(p + i);
cout << "destory done" << endl;
alloc.deallocate(p, 3);
cout << "deallocate done" << endl;
```

#### （3）拷贝和填充未初始化内存的算法

标准库还为 allocator 类定义了两个伴随算法，可以在未初始化的内存中创建对象：
``` c++
// 以下所有操作都假定目标位置内存足够
	// 从[b,e)中拷贝元素到原始内存b2
	// 返回指向最后一个已构造元素之后位置的迭代器
iter = uninitialized_copy(b,e,b2);  
	// 从b开始的n个元素拷贝到原始内存b2
	// 返回指向最后一个已构造元素之后位置的迭代器
iter = uninitialized_copy_n(b,n,b2);
	// 在迭代器[b,e]指定的原始内存范围内填充对象t
void uninitialized_fill(b,e,t);   
	// 在迭代器b开始的n个原始内存中填充对象t
void uninitialized_fill_n(b,n,t);
```

#### （4）我们很少使用allocator

`allocator` 是一种底层内存管理工具，适用于分配和释放内存，但使用起来相对较复杂。C++ 的 `std::vector` 和其他容器类已经很好的封装了内存管理，通常不需要手动使用 `allocator`。

在现代 C++ 中，直接使用 `allocator` 的场景较少，因为 STL 容器已经默认处理了这些细节。

## 七、拷贝控制

当我们定义一个类时，我们显式或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊类型的成员函数来控制这些操作：

1. copy constructor
2. copy-assignment operator
3. move constructor
4. move-assignment operator
5. destructor

如果一个类没有定义这些拷贝控制成员，编译器会自动为它定义默认的操作。但有时候，依赖这些操作的默认定义会导致灾难。通常，拷贝控制最难的地方是首先认识到什么时候需要定义这些操作。

### 1. 拷贝初始化

当我们使用 `operator=` 来初始化对象的时候，会通过拷贝构造函数或移动构造函数来完成“拷贝初始化”。

拷贝初始化不仅会在我们使用 `operator=` 时发生，在下列情况下也会发生：

* 将一个对象作为实参传递给非引用类型的形参
* 从一个返回类型为非引用类型的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类中的成员，数组元素或者聚合类中的成员会执行拷贝初始化
* 某些类类型还会对它们所分配的对象使用拷贝初始化。例如 insert 或 push 成员。与之相对的是 emplace 直接初始化。

不过编译器有时会绕过拷贝初始化，即将拷贝初始化改写为直接初始化：

``` c++
string s = "hello";
// 改写为：
string s("hello");
```

但是，即便是这样，拷贝构造/移动构造也必须是存在且可访问的。

### 2. 拷贝构造函数

如果一个构造函数的第一个参数是自身的引用，且其余参数都有默认值，则此构造函数是拷贝构造函数。拷贝构造函数单纯的拷贝所有非 static 数据成员，对于数组成员会逐个拷贝数组元素。

``` c++
class Foo {
public:
    Foo() {}
    Foo(const Foo &x);
private:
    int i;
    double d;
    string s;
    class Bar b;
};

// 与合成的拷贝构造函数等价
Foo::Foo(const Foo &x) : 
    i(x.i), d(x.d), s(x.s), b(x.b)	// 单纯的拷贝
    {}
```

一般来说，我们会把自身的引用声明为 const。出于隐式初始化的需要，一般也不会把拷贝构造函数声明为 explicit。将引用声明为 const 有一个额外的好处，那就是如果我们传入的是一个匿名（临时）对象，也是可以执行拷贝初始化的：

``` c++
class Foo {
public:
    Foo(int _val = 0) : val(_val) { cout << "ctor" << endl; }
    Foo(const Foo &x) { cout << "copy ctor" << endl; }
private:
    int val;
};

Foo f = 10;	// copy ctor
```

如果我们将上面代码中拷贝构造函数中的 const 去掉，那么编译器会报错：

``` shell
error: cannot bind non-const lvalue reference of type ‘Foo&’ to an rvalue of type ‘Foo’
   13 | Foo f = 10;
```

即，我们将一个 rvalue 绑定到了一个 non-const lvalue referece，这是不合法的。

----

拷贝构造函数可以用来初始化非引用类类型参数，这一特性解释了为何拷贝构造函数自己的参数必须是引用类型：如果其参数不是引用类型，那么调用构造函数就必须拷贝它的实参，而拷贝实参又需要调用拷贝构造函数，如此无限循环。

``` C++
class Foo {
public:
    Foo() {}
    Foo(Foo x) {  }
};

int main()
{
    Foo f1;
    Foo f2 = f1;
}
```

* f2 想要以 f1 为实参进行拷贝初始化，就必须先把 f1 拷贝到 x
* 而 x 如果想以 f1 为实参进行拷贝初始化，就必须先把 f1 拷贝到 x'
* 而 x' 如果想以 f1 为实参进行拷贝初始化，就必须先把 f1 拷贝到 x''
* 无限循环

### 3. 拷贝赋值运算符

拷贝赋值运算符需要返回指向他自己的引用，这是与内置的 `operator=` 保持一致。第一个参数不必须是自身的引用。

``` C++
class Foo {
public:
    Foo() {}
    Foo(const Foo &x);
    Foo& operator=(const Foo &x);
private:
    int i;
    double d;
    string s;
    class Bar b;
};

// 与合成的拷贝赋值运算符等价
Foo& Foo::operator=(const Foo &x) 
{
    i = x.i;
    d = x.d;
    s = x.s;
    b = x.b;
}
```

当类需要资源管理并且其的行为像值时，在定义拷贝赋值时需要注意自我赋值的问题。另外就是异常安全的问题。

> 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

### 4. 析构函数

析构函数无返回值，不接受参数。正因为析构函数不接受参数，因此它也不允许重载。

对于编译器合成的默认析构函数，对象销毁的顺序和对象初始化的顺序相反。这是因为在初始化对象时，如果先初始化 a 在初始化 b，那么 a 是有可能作为 b 的一部分的，此时如果我们先析构 a，那么 b 就被破坏了。

内置类型没有析构函数，因此什么也不需要做。销毁一个内置类型指针或引用时，不会 delete 掉它指向的对象。

> 注意，对于 `Type *ptr = new Type(args);` 来说，ptr 是一个内置指针类型，它指向 Type 类型的对象。
>
> 销毁 ptr 时什么都不会发生，不会调用 Type 的析构函数。

**值得注意的是，析构函数的函数体并不直接销毁成员，成员在析构函数体执行完毕后自动销毁。**

### 5. 三/五法则

拷贝构造、拷贝赋值和析构称为 Big Three，加上移动构造和移动赋值就是 Big Five。通常我们应该把 Big Three 或 Big Five 当作一个整体看待，只要定义了一个函数就应该定义其它几个。这也是所谓的**“三/五法则”**。

而是否应该定义其中某个函数，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求比拷贝构造和拷贝赋值的需求更明显（例如动态内存的 delete）。**如果一个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造和一个拷贝赋值。**

**需要拷贝操作的类也需要赋值操作，反之亦然。**凡事总有例外，有时候有些类的工作只需要拷贝或赋值操作，并不需要析构函数。例如，我们需要为每个类分配一个独有的、独一无二的 id。这个类需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的 id。也需要一个自定义拷贝赋值运算符来避免将 id 赋予目的对象。但是这个类不需要析构函数。

### 6. 阻止拷贝

有两种方式阻止拷贝的发生：

* 链接时错误：将拷贝函数声明为 private 且不定义。因为友元函数依然可以访问 private 成员，所以只声明为 private 还不行，还需要不实现
* 编译时错误：将拷贝函数指定为 `=delete`

与 default 的一个不同之处是，我们可以对任何函数指定 `=delete`，但我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用 `=default`。虽然理论上我们可以将析构函数指定为 `=delete`，但应用上我们不可以这样做 ，否则我们不能定义该类型的变量或释放指向该类型动态分配对象的指针。

> 当析构函数被删除时，我们可以创建动态对象。

除了我们自行指定为 private 或 `=delete` 外，在某些情况下合成的拷贝控制成员可能是删除的：**简而言之，本质上就是如果一个类有数据成员不能被默认构造、析构、拷贝或赋值，那么该类的成员函数将被定义为删除的。**

* 如果类的某个成员的默认构造函数或析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个 const 成员，他没有类内初始化器且其类型未显式定义默认构造函数，则该类的【默认 constructor 函数】是被删除的

> 我们必须对没有类内初始化的 const 成员和引用成员进行初始化。
>
> 当析构函数被删除时，我们无法通过构造函数构造静态对象。

* 如果类的某个成员的拷贝构造函数或析构函数是删除的或不可访问的，则类的【合成 copy ctor 函数】被定义为删除的。

> 如果析构函数被删除，我们无法通过构造函数创建静态对象。

* 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个 const 的或引用成员。则类的【合成 copy-assignment 运算符】被定义为删除的

> 对引用成员赋值只是修改被引用对象的值，而不是修改引用的对象。这种行为并不是我们想要的，因此对于有引用成员的类，合成的拷贝赋值运算符被定义为删除的。
>
> 对于 const 成员，显然的，我们不能对其进行赋值。

* 如果类的某个成员的析构函数是删除的或不可访问的（例如是 private），则类的【合成 destructor 函数】被定义为删除的

### 7. 拷贝语义

通常，管理类外资源的类必须定义拷贝控制成员。为了定义这些成员，我们首先必须确定此类对象的拷贝语义。一般来说有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或一个指针。

* 类的行为像一个值：string
* 类的行为像一个指针：shared_ptr

### 8. swap 函数

与拷贝控制成员不同，swap 并不是必要的，因为 swap 的实现借助了拷贝成员。但是对于分配了资源的类，定义 swap 可能是一种很重要的**优化手段**。

#### （1）性能优化

例如对于我们自定义的 `String` 类，swap(s1, s2) 的行为类似：

``` c++
String tmp = s1; // 构造tmp
s1 = s2;		 // 拷贝赋值
s2 = tmp;		 // 拷贝赋值
```

我们需要先通过拷贝构造，将 s1 拷贝给一个临时对象 tmp，然后进行两次赋值操作。而我们知道，对于行为像值的类，赋值操作会涉及到构造与析构（底层对象的 new 和 delete）。这意味着，一个 swap 操作共进行了三次构造，两次析构操作，这开销也太大了。并且每次构造都会分配内存，析构会销毁内存。

理论上，这些内存分配 都是不必要的，我们更希望 s1 和 s2 直接交换底层指针，而不是分配 String 的新副本。即：

``` c++
char* tmp = s1.sp;
s1.sp = s2.sp;
s2.sp = data;
// <==>
swap(s1.sp, s2.sp);
```

#### （2）无限定

我们在调用 swap 时，不应该加上 `std::` 限定，即类似 `std::swap` 。每个调用都应该是 `swap`，如果存在类型特定的 swap 版本，其匹配程度会优先于 std 中定义的版本。即，优先调用类型特定的 swap 版本；如果不存在类型特定的版本，则会调用 std 中的版本。

#### （3）在赋值运算符中使用swap

定义 swap 的类通常用 swap 来定义它们的赋值运算符。这些运算符使用一种名为<font color=blue>拷贝并交换（copy and swap）</font>的技术，这种技术将左侧对象与右侧对象的一份拷贝副本进行交换：

``` c++
// 注意rhs是按值传递的，意味着HasPtr的拷贝构造函数
// 将右侧运算对象中的string拷贝到rhs
HasPtr& HasPtr::operaotr=(HasPtr rhs)
{
    swap(*this, rhs);
    return *this;
}
```

这种技术的有趣之处在于，它既能保证<font color=blue>自我赋值下的安全性</font>，又能保证<font color=blue>异常安全</font>。这两种保证都是通过在修改左侧对象前，完成可能出问题的操作 —— 如果左侧对象修改了一半，但是有异常抛出，由于左侧对象被修改且无法恢复，所以说不是异常安全的；自我赋值也是同样的道理。

* 异常安全：赋值运算符唯一可能异常的就是 new 语句，而这里 new 语句用来构造局部对象 rhs。如果真的发生异常，函数体还未执行，左侧对象没有改变，因此是异常安全的
* 自我赋值：提前通过 rhs 拷贝自己，也发生在函数体执行之前（即左侧对象改变之前）

### 9.  对象移动

对象移动的需求不仅仅是性能上的考虑，也源于 IO 类或 unique_ptr 这样包含不能被共享资源（如指针或 IO 缓冲）的类。这些类型的对象不能拷贝但可以移动。

#### （1）右值引用

右值引用是为了支持移动操作而引入的，一个右值引用只能绑定到一个将要销毁的对象。因此，我们可以将一个右值引用的资源“移动”到另一个对象中。

对象将要销毁意味着没有其它用户使用它，因此我们可以自由的接管所引用的对象的资源。一个将要销毁的对象可以是一个右值，也可以是一个左值。但我们不可以直接将一个右值引用绑定到左值上，我们需要使用 `std::move` 来显式的将一个左值绑定到右值引用上。调用 `move` 就意味着承诺：除了对该左值赋值或销毁之外，我们不再使用它。

> 左值和右值是表达式的属性。一般而言，一个左值表达式表示的是对象的身份，一个右值表达式表示的是对象的值。

一个好的编程规范是通过 `std::move` 来调用 `move`，以避免潜在的歧义或命名冲突。

#### （2）保证销毁是无害的

从一个对象移动数据不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，移动操作除了完成资源移动，还必须确保移动后源对象处于这样一个状态 —— 销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。

``` C++
// 移动操作不应该抛出任何异常
// 由于我们需要修改源对象，因此rhs不应该是cosnt的
Smart_Pointer(Smart_Pointer &&rhs) noexcept 
: ptr(x.ptr) // 接管源对象资源
{ 
    // 令源对象处于这样的状态 -- 对其运行析构函数是安全的
    // 因此不能让源对象还指向被移动的资源
    rhs.ptr = nullptr; 
}
```

如果我们不修改源对象的 ptr 指针指向 NULL，它会仍然指向被移动的资源，此时对它调用析构函数（delete ptr）会导致 double delete。

另外我们也可以发现，**“移动”行为本身是我们自己通过代码实现的**，例如上面的 `ptr(x.ptr)`，我们通过浅拷贝接管了 `x.ptr`，然后将 `x.ptr` 置位 NULL。右值引用相当于一种约定，对于右值引用，我们可以随意接管引用的对象。

#### （3）移动操作、标准库容器和异常

由于移动操作“窃取”资源，它通产不分配任何资源。因此，移动操作通常不应该抛出任何异常。而我们编写的移动操作不会抛出任何异常时，我们应该事先通知标准库（例如 `noexcept`）。否则标准库会认为移动我们的类对象时可能抛出异常，并且为了处理这种可能性而做出一些“额外的操作”（通常是为了确保异常安全）。

在不抛出异常时，将移动函数指定为 noexcept 基于两个相互关联的事实：

1. 虽然移动操作通常不抛出异常，但抛出异常也是允许的。
2. 标准库容器能对异常发生时其自身的行为提供保障。例如，vector 保证，如果我们调用 push_back 时发生异常，vector 自身不会发生改变。

对于第二点，例如，当我们调用 push_back 时，可能需要扩容 vector 并且将容器元素从旧空间移动到新空间。此时如果我们使用移动构造函数加速扩容时的元素迁移，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空间的移动源元素已经被改变了，而在新空间中为构造的元素可能尚不存在。在此情况下，vector 不能满足自身保持不变的要求，也即此时不是异常安全的。

另一方面，如果 vector 使用拷贝构造函数且发生了异常，它可以保持 vector 自身不会发生改变。在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生了异常，vector 可以直接释放新分配的内存并返回。vector 原有的元素仍然存在。

为了避免这种潜在错误，除非 vector 知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，他就必须使用拷贝构造函数而不是移动构造函数。如果希望在 vector 重新分配内存这类型下对我们自定义类型的对象进行移动而不是拷贝，就必须显示的告诉标准库我们的移动构造函数可以安全使用。我们可以通过将移动构造函数（及移动赋值运算符）标记为 noexcept 来做到这一点。

#### （4）移动后源对象仍然有效

这意味着我们可以对其重新赋值，不过在此之前，我们不能对其值做任何假设。

#### （5）合成的移动操作

与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造和移动赋值运算符了。

<font color=blue>如果一个类没有移动操作，通过正常的函数匹配，类会使用相应的拷贝操作来代替移动操作：</font>

``` c++
class Foo {
public:
    Foo() { puts("ctor"); }
    Foo(const Foo&) { puts("copy ctor"); }
private:
};

Foo a;
Foo b = std::move(a);   // copy ctor
```

只有一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数和移动赋值运算符。

**与拷贝操作不同，移动操作永远不会隐式定义为删除的函数**。但是，如果我们显式的要求编译器生成 `=default` 移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。

``` C++

struct Bar {
    Bar() = default;
    Bar(Bar&&) = delete;
};

struct Foo {
    Foo() = default;
    Foo(Foo&& x) = default;
    Bar b;
};

int main() 
{ 
    Foo a;
    Foo b = std::move(a);  
     // function "Foo::Foo(const Foo &)" (declared implicitly) 
     // cannot be referenced
     // it is a deleted functionC/C++
    return 0;
}

```

在上面的代码中，我们希望 Foo 生成一个默认的移动构造函数，但编译器报告该函数已被删除。

除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则：

* 类似拷贝赋值运算符，如果有类成员是 const 的或引用，则类的移动赋值运算符被定义为删除的。
* 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的
* 类似拷贝构造和拷贝赋值，如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的
* _与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。_

<font color=blue>注意，这里的删除，不是真正意义上的删除（即我们自行通过 `=delete` 指定的删除函数）。我们是可以重新定义编译器默认“删除”的函数的。</font>

例如，对于上面代码中的 class Foo，它的移动赋值运算符是默认删除的，不过我们可以自定义我们自己的移动赋值运算符，但要注意解决例如 const 和引用不能拷贝等问题：

``` c++
struct Bar {
    Bar() = default;
    Bar(Bar&&) { puts("move"); }
};

struct Foo {
    Foo() = default;
    Foo(Foo&& x) = default;
    Foo& operator=(Foo&&) {
        puts("operator==");
        return *this;
    }

    const int val = 10;
    Bar b;
};

int main() 
{ 
    Foo a;
    Foo b;
    b = std::move(a);  // operator==
    return 0;
}
```

**移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果一个类定义了一个移动构造或移动赋值运算符，则类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。**

因此，定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认的被定义为删除的。

#### （6）移动操作的实现在函数内部

并不是说，我们执行了移动构造函数或移动赋值运算符，编译器就自动帮我们“移动”元素，我们仍然需要手动移动一些元素：

```  C++
class Bar {
public:
    Bar() = default;
    Bar(const Bar &x) { puts("Bar::copy"); }
    Bar(Bar &&x) { puts("Bar::move"); }
private:
    const int val = 10;
};

class Foo {
public:
    Foo() { puts("ctor"); }
    Foo(const Foo &f) { puts("copy ctor"); }
    // 移动 f.mem
    // Foo(Foo&& f) : mem(std::move(f.mem)) // Bar::move
    // { puts("move ctor"); } 
    
    // 拷贝 f.mem
    Foo(Foo&& f) : mem(f.mem) // Bar::copy 
    { puts("move ctor"); } 
private:
    Bar mem;
};

int main() 
{ 
    Foo a;
    Foo b = std::move(a); 
    return 0;
}
```

在上面 Foo 的移动构造函数中，对于成员变量 mem，如果我们不显示指定 `std::move`，它调用的依然是 Bar 的拷贝构造函数，虽然我们调用的是 Foo 的移动构造函数。

不过对于内置类型则不需要显式指定 move，因为内置类型本身并没有复杂的内存管理。所以内置类型直接拷贝即可，毕竟其拷贝操作的开销也不大，编译器还能从中进行各种优化。

#### （7）右值引用和成员函数

除了构造和赋值，一个普通成员函数也可以同时提供拷贝和移动版本，它的参数模式一般都是相同的 —— 拷贝版本接受一个 const 的左值引用，移动版本接受一个非 const 的右值引用。其中，左值版本可以接受左值引用和右值引用，右值版本只能接受右值引用。

### 10. 更新三/五法则

在加入了移动操作之后，所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，他就应该定义所有五个操作。

* 拷贝构造
* 拷贝赋值
* 移动构造
* 移动赋值
* 析构

### 11. 移动迭代器

前面我们介绍过 `uninitialized_copy(b,e,b2)` 函数，他将迭代器 `[b,e)` 指定的元素拷贝到 b2 指定的未构造内存当中。不过，标准库中并没有类似的函数将对象“移动”到未构造的内存中。

新标准库定义看了一种**移动迭代器（move iterator）适配器**。一个移动迭代器适配器通过改变给定迭代器的解引用运算符的行为来适配次迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值引用。与其他迭代器不同，移动迭代器的解引用运算符返回一个右值引用。

我们通过标准库的 `make_move_iterator` 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。

``` C++
auto last = uninitialized_copy(
    make_move_iterator(begin())),
	make_move_iterator(end()),
	first);
```

### 12. 引用限定符

#### （1）引入

通常，我们在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值。例如：

``` C++
string s1 = "hello,", s2 = "world";
auto n = (s1 + s2).find('d');
```

此例中，我们在一个 string 右值上调用 find 成员。看起来也还好，不过还有更令人惊讶的：

``` c++
struct Foo {
    Foo(int _val = 0) : val(_val) {}
    Foo& operator=(const Foo& x)  { 
        val = x.val; 
        return *this;
    }
    int val;
};

Foo operator+(const Foo &a, const Foo &b)
{
    return Foo(a.val + b.val);
}

int main() 
{ 
    Foo a(1), b(2);
    a + b = 3;	// 合法
    return 0;
}
```

此处我们对两个 string 的连接结果 —— 一个右值，进行赋值。

在旧标准中，我们没有办法阻止这种对右值的赋值行为。为了维持向后兼容性，新标准库类仍允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。即，我们希望强制左侧运算对象（即，this 指向的对象）是一个左值。

**我们指定 this 的左值/右值属性**的方式与定义 const 成员函数的形式相同。即，在参数列表后放置一个**引用限定符**：

``` c++
struct Foo {
    Foo(int _val = 0) : val(_val) {}
    Foo& operator=(const Foo& x) & // 指定this必须是一个左值
    {
        val = x.val; 
        return *this;
    }
    int val;
};
```

此时再执行上面的 `a+b=3` 就不合法了，因为 `a+b` 的返回结果是一个右值，所以它无法调用成员函数 `operator=`。

如果引用限定符和 const 限定符同时出现，引用限定符需要放在 const 限定符的后面。

#### （2）重载

除了限定调用对象是左值之外，引用限定符还有更大的作用。同 cosnt限定符 一样，引用限定符也是函数签名的一部分，因此也可以用来重载函数。因此可以根据调用对象是左值还是右值来对函数的行为做出优化。例如，在类中有一个函数 `sorted`，它返回对内部 `vector` 元素的排序：

``` c++
class Foo {
public:
    Foo() = default;
    Foo(const vector<int>& _data) : data(_data) {}
    Foo(vector<int> &&_data) : data(std::move(_data)) {}
    Foo(initializer_list<int> il) : data(il) {}
    Foo(const Foo &f) : data(f.data) {}
    Foo(Foo &&f) : data(std::move(f.data)) {}
public:
    Foo sorted() const &;
    Foo sorted() &&;
private:
    vector<int> data;
};

Foo Foo::sorted() const &
{
    puts("lvalue");
    // 对于左值，需要拷贝其内部数据再修改
    Foo ret(*this);
    sort(ret.data.begin(), ret.data.end());
    return ret;
}

Foo Foo::sorted() &&
{
    puts("rvalue");
    // 对于右值，直接修改内部数据
    sort(data.begin(), data.end());
    return *this;
}

int main() 
{ 
    Foo f = Foo().sorted(); // rvalue
    Foo f2 = f.sorted();    // lvalue
    return 0;
}
```

同 const 一样，引用限定符在声明和定义处都需要指定。

有一点和 const 不同，对于上面的两个 sorted，我们一个指定为 const，一个未指定为 const。但引用限定符则不一样，如果我们定义了两个或两个以上**具有相同名字和相同参数列表**的成员函数，就必须对所有函数都加上引用限定符，或所有都不加：

``` c++
class Foo {
public:
    Foo() = default;
public:
    Foo sorted() const &;
    Foo sorted() const &&;
    Foo sorted(); /* ERROR:
    overloading two member functions with the same parameter types 
    requires that they both have ref-qualifiers or both lack ref-qualifiers
    */
private:
    vector<int> data;
};
```

对面上面的三个 `<Foo(void)> sorted;` 我们要么都加上引用限定符，要么都不加。

## 八、重载运算与类型转换

重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和后其要定义的运算符号共同组成。重载运算符的优先级、结合律和参数个数斗鱼其内置形式一致。

对于一个运算符函数来说，它或者是类的成员函数，或者至少含有一个类类型的参数。这一约定意味着当运算符作用于内置类型时，我们无法改变该运算符的含义。

除了重载的函数调用运算符 operator() 除外，其他重载运算符不能含有默认实参。

有些运算符有多重含义，例如 `+`，``-``，`*`，`&`。可以从参数个数推断运算符的含义。换言之，重载运算符参数的个数是有要求的，因为我们需要据此推断运算符的含义。但是返回类型并无要求，我们可以对 operator+ 返回一个 void 类型。不过并不建议这么做，因为**运算符重载的核心要义应该是与该运算符作用于内置类型时的含义保持一致。**例如逻辑操作应该返回 bool 类型，加法应该返回一个与操作数一样的类型等。

我们只能重载已有的运算符，而不能发明新的运算符。而且不是所有运算符我们都可以重载，不能被重载的运算符：`::`，`.*`，`.`，`?:`。虽然这意味着我们可以重载诸如 `&&`，`||` 和 `,` 等逻辑运算符。但并不建议重载这些运算符，因为重载后运算符无法保留**运算对象求值顺序**。例如当我们重载逻辑与运算符时，在函数中两个运算对象总是被求值，这就破坏了其短路求值的特性。

> 通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。

区别于普通函数，运算符函数有两种调用形式，一种是通过“运算符形式”进行“隐式”调用，另一种是通过普通函数形式进行“显式”调用：

``` c++
struct Foo {
    Foo(int _val = 0) : val(_val) {}
    int val;
    Foo& operator+=(const Foo &x) {
        val += x.val;
        return *this;
    }
};

void operator+(const Foo &a, const Foo &b)
{
    // return Foo(a.val + b.val);
}

int main()
{
    Foo a(3), b(4);
    
    a + b;	// 隐式
    operator+(a, b); // 显式

    a += b; // 隐式
    a.operator+=(b); // 显式
    
    return 0;
}
```

和其它成员函数的设计思想一样：例如如果我们有一个非 const 的成员函数，可能也需要一个 const 的成员函数；如果我们需要自定义拷贝构造函数，那么一般也需要自定义拷贝赋值函数。同理的，如果我们定义了 `operator==`，那么一般来说我们也需要 `operator!=`；如果我们定义了 `operator<`，那么一般也需要其它关系运算符；如果我们定义了 `operator+`，一般也需要定义相应的复合加法 `operator+=`。

最后，不要滥用运算符重载：

* 考虑好某个功能到底使用运算符实现还是普通函数实现

* 尽量明智的使用运算符重载。只有当运算符操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二义性。

### 1. 成员还是非成员

尽管有些运算符只能作为类的成员函数，例如需要使用 this 指针的操作（`->`），但大部分函数还是不容易判断是否应该作为成员函数。下面是一些准则帮助我们判断某个重载运算符是作为成员函数还是非成员函数（或友元函数）：

* 赋值（`=`）、下标（`[]`）、调用（`()`）和成员访问箭头（`->`）运算符必须是【成员函数】
* <font color=blue>复合赋值运算符</font>一般来说是【成员函数】
* <font color=blue>改变对象状态</font>的运算符或者与<font color=blue>给定类型密切相关</font>的运算符，例如递增、递减和解引用运算符，一般应该是【成员函数】
* 具有对称性的运算符（`a op b` 等价于 `b op a`），例如算数、相等性、关系和位运算符等，一般是普通的【非成员函数】
* 输入输出运算符一定是普通的【非成员函数】

对称性运算通常作为非成员是因为它常常含有混合类型的表达式，例如我们能求一个 int 和一个 double 的和，能对 string 对象和 const char* 对象做加法。并且这两个操作数的顺序可以交换：

``` c++
String s = "hello";
String t = s + "world"; // "world"隐式构造
String u = "world" + s;	// 可能不合法
```

如果 `operator+` 是类的成员函数，那么第三条语句的加法运算不合法，因为没有针对 `“hi”.operator+(s);` 的重载形式。

### 2. 输入和输出运算符

输入输出运算符必须是非成员函数。

输出运算符尽量减少格式化操作，这是因为用于内置类型的输出运算符本身就不太考虑格式化操作，尤其不会打印换行符。并且减少格式化操作可以使用户有权控制输出的细节。

输入运算符需要处理输入可能失败的情况，输出运算符则不需要。执行输入运算符时可能发生下列错误：

* 当流含有错误类型的数据时读取操作可能失败。
* 当流读取到文件末尾或者遇到输入流的其它错误时也会失败。

当读取操作发生错误时，输入运算符应该负责从错误中恢复。即重置一些值（当读取错误时这些值可能是未定义的），这样对象可以保持一个合法的状态，从而略微保护使用者免于收到输入错误的影响。

例如：

``` c++
class Person {
public:
    friend std::istream& operator>>(std::istream& is, Person &p);
    friend std::ostream& operator<<(std::ostream& os, const Person &p); 

public:
    Person(std::string _name = std::string(), int _age = 0, bool _isman = 1);
    
private:
    std::string name;
    int age;
    bool isman;
};

std::istream& operator>>(std::istream& is, Person &p)
{
    is >> p.name >> p.age >> p.isman;
    // 当输入发生错误时，重置一些值以确保对象p是合法的
    if(!is) p = {"", 0, 1};
    return is;
}
```

### 3. 算数运算符

通常情况下，我们会把算数定义成非成员函数以允许对左侧和右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。

算术运算符的返回对象常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为结果。

如果同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符来实现算数运算符。

``` C++
Foo operator+(const Foo &lhs, const Foo &rhs) {
    Foo res = lhs;
    lhs += rhs;
    return res;
}
```

> 显而易见的，我们不能通过算数运算符实现复合赋值运算符。
>
> 因为算数运算符会返回一个临时对象，这会带来额外的拷贝和析构消耗。其次体现在代码上也不简洁。

### 4. 关系运算符

和算数运算符一样，我们会把关系运算符定义成非成员函数以允许对左侧和右侧的运算对象进行转换。

关系运算符一般分为两类：

* 相等运算符 `==`，`!=`
* 比较运算符：`<`，`<=`，`>`，`>=`

当我们定义了一类中的某个运算符时，其余运算符一般也需要定义。

从内置类型的关系运算符语义上来说，相等运算符和比较运算符是有联系的：<font color=blue>如果两个对象是 `!=` 的，那么一个对象应该 `<` 另外一个。</font>因此如果我们在类中同时定义了相等运算符和比较运算符，那么就要考虑它们是否保证上面的语义。看下面的例子：

``` c++
class Sales_data {
public:
    friend bool operator==(const Sales_data &lhs, const Sales_data &rhs);
    friend bool operator!=(const Sales_data &lhs, const Sales_data &rhs);
    friend bool operator<(const Sales_data &lhs, const Sales_data &rhs);
public:
    Sales_data(std::string _isbn = std::string(), double _price = 0, int sales_count = 0)
        : isbn(_isbn), price(_price), revenue(sales_count * _price) 
        {}
private:
    std::string isbn;
    double price;
    double revenue;
};

bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn == rhs.isbn && lhs.price == rhs.price && lhs.revenue == rhs.revenue;
}

bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
    return !(lhs == rhs);
}

// 是否合适呢？
bool operator<(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn < rhs.isbn;
}
```

对于上面的类，我们定义的 `operator<` 是否合适呢？显然是不合适的，例如我们有下面两个对象：

``` c++
Foo a('0123', 1, 1);
Foo b('0123', 2, 2);
```

由于 price 和 revenue 不相等，所以这两个对象是不相等的。但由 `operator<` 的定义，可以看出这两个对象哪个都不比另外一个小，则从道理上来说这两个对象应该是相等的。所以说 `operaotr<` 的定义和 `operator==` 的定义就冲突了。

### 5. 赋值运算符

除了拷贝赋值和移动赋值运算符之外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。例如 vector 定义了接受花括号内的元素列表（initializer_list）作为参数的赋值运算符。

``` C++
class Foo {
public:
    Foo(int _a = 0, int _b = 0, int _c = 0) : a(_a), b(_b), c(_c) {}
    Foo& operator=(std::initializer_list<int> il) {
        a = *il.begin();
        b = *(il.begin() + 1);
        c = *(il.begin() + 2);
        return *this;
    }

private:
    int a, b, c;
};
```

赋值运算符必须是类的成员，复合赋值运算符不必是类的成员，但我们还是倾向于把包括复合赋值运算符在内的所有赋值运算都定义在类的内部。

之所以规定赋值运算符必须是类的成员，是因为如果我们没有为类提供一个赋值运算符的话，编译器会为类提供一个合成的默认拷贝赋值运算符，此时如果我们在全局定义了一个赋值运算符，就会发生二义性。

### 6. 下标运算符

下标运算符必须是成员函数。

下标运算符必须以所访问元素的引用作为返回值。进一步，我们最好同时定义下标运算符的常量版本和非常量版本。

### 7. 递增和递减运算符

C++ 并不要求递增和递减运算符是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。

同内置类型的递增和递减运算符一样，我们也需要同时定义递增或递减运算符的前置和后置版本。并且通常借助前置版本来实现后置版本。

后置版本接受一个额外的（不被使用）int 类型参数。当我们使用后置运算符时，编译器为这个形参提供一个值为 0 的实参。尽管从语法上我们可以使用这个额外的参数，但是在实际过程中通常不会这么做。这个形参的唯一作用就是用来区分前置版本和后置版本的函数。

如果我们像显式的调用后置版本，需要指定这个不被使用的 int 类型参数。尽管这个值通常会被运算符函数忽略，但他却必不可少，否则编译器无法得知这是后置版本。

### 8. 成员访问运算符

在迭代器和智能指针类中常常用到解引用运算符（`*`）和箭头运算符（`->`）。它们都必须作为类的成员，并且通常是常量成员函数。

#### （1）解引用运算符

对于 `operator*` 的重载比较简单，返回对象的引用即可。不过实际上，就如我们前面提到的，C++ 并没有强行规定运算符的返回类型，也意味着即使我们返回一个字面量或其他类型也是可以的。但并不推荐这么做，因为这与内置类型的解引用语义不一致。

#### （2）箭头运算符

C++ 对于 `operator->` 的返回类型是有要求的，它永远不能丢掉**“成员访问”**这个最基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永远不变。

对于形如 `point->mem` 的表达式来说，point 必须是指向类对象的指针或一个重载了 `operator->` 的类对象。根据 point 类型的不同，`point->mem` 分别等价于：

``` c++
(*point).mem;			  // point是一个内置的指针类型
point.operator->()->mem;  // point是一个类对象
```

除此之外，代码都将发生错误。point->mem 的执行过程如下所示：

1. 如果 point 是内置指针类型，则我们应用内置的箭头运算符，表达式等价于 `(*point).mem`。首先解引用该指针，然后从所得的对象中获取指定的成员。
2. 如果 point 是定义了 operator-> 的类的一个对象，则我们使用 point.operator->() 的结果来获取 mem。其中，如果该结果是一个指针，则执行第一步；如果该结果是一个重载了 operator-> 的类，则重复当前步骤。

可以发现，对于 operator-> 的解析，是一个**“递归”**的过程，并且最终的工作还是要交给 `operator*`。这本身也符合 `point->mem <==> (*point).mem` 的语义。

> 注意关于内置指针类型，强调的是指针，而不是指针所指向的对象。也就是说，对于 `T *obj;` 无论 T 是什么类型，obj 的类型都是一个内置指针类型。

可以看一个例子，更好的理解 `operator->` 针对内置指针和类对象的解析流程：

``` C++
class A{
public:
    A()    { x = 1;}
    void action(){
        cout << "Action in class A!" << endl;
    }

public:
    int x;
};

class B{
    A a;
public:
    B()    { x =2; }
    A* operator->(){
        return &a;
    }
    void action(){
        cout << "Action in class B!" << endl;
    }
private:
    int x;
};

class C{
    B b;
public:
    C (){ x =3; }
    B operator->(){
        return b;
    }
    void action(){
        cout << "Action in class C!" << endl;
    }
private:
    int x;
};

int main(int argc, char *argv[])
{
    C* pc = new C;
    pc->action(); // 这个调用会被当作内置指针类型的箭头运算符调用
                  // 相当于(*pc).action();
    
    C c;
    c->action();  // 由于c不是内置指针类型,会调用重载了的operator->()
                  // 相当于 c.operator->()->action
                  // 根据C::operator->()的定义
                  // 相当于 b->action,其中b不是内置指针类型
                  // 根据 B::operator->()的定义
                  // 相当于 a->action,其中a是内置指针类型
                  // 故最终解析为 (*a).action()
    
    int x = c->x; // 和 c->action() 的分析一样
                  // 这里最终解析为 (*a).x;  
    std::cout<<x;

    getchar();
    return 0;
}
```

#### （3）为什么箭头运算符特殊

这其实算是一种官方的约定：

> 重载箭头操作符必须返回指向类类型的指针，或者返回定义了自己的箭头操作符的类类型对象。
>
> * 如果返回类型是指针，则内置箭头操作符可用于该指针，编译器对该指针解引用并从结果对象获取指定成员。如果被指向的类型没有定义那个成员，则编译器产生一个错误。
> * 如果返回类型是类类型的其他对象（或是这种对象的引用），则将递归应用该操作符。编译器检查返回对象所属类型是否具有成员箭头，如果有，就应用那个操作符；否则，编译器产生一个错误。这个过程继续下去，直到返回一个指向带有指定成员的的对象的指针，或者返回某些其他值，在后一种情况下，代码出错。

不过，既然箭头运算符是成员访问运算符，那么为什么它不直接返回对象的引用，而是返回对象的指针呢？主要有以下原因：

* **`->` 运算符的语义**

> `->` 运算符通常用于指针对象，表示通过指针访问某个对象的成员，即解引用指针后，再访问该对象的成员。例如，对于 `ptr->member`，它相当于 `(*ptr).member`。因此，`->` 运算符的核心概念是它要**返回一个指针**，然后可以通过该指针继续进行成员访问。
>
> 通过要求 `operator->()` 返回指针而不是引用，保持了与原有指针语法的兼容性。

* **`->` 是递归调用的**：

> C++ 语言的设计允许 `operator->` 返回一个指针后，继续对该指针调用 `->` 以递归地访问更深层次的成员。这意味着重载的 `operator->` 可以返回一个指针指向另一个类对象，那个对象又可以继续调用 `->` 运算符。
>
> 如果 `operator->` 返回的是引用，那么无法继续使用 `->` 进行递归调用，而这与 `->` 运算符的设计相冲突。

### 9. 函数调用运算符

如果类重载了函数调用运算符，则我们可以像使用函数一样使用类的对象，因此这种对象也成为“函数对象”。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。

函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符。

注意对函数调用运算符的调用都是通过调用进行的，并且通常是通过匿名对象来调用。例如：

``` c++
sort(a.begin(), a.end(), greater<int>());
```

通过创建一个标准库函数匿名对象 `greater<int>()` 来调用。

#### （1）lambda是函数对象

当我们编写了一个 lambda  表达式后，编译器将表达式翻译成一个**未命名类的未命名对象**。（注意是通过对象来调用调用运算符的）

* 这个未命名类含有一个重载的函数调用运算符。
* 默认情况下 lambda 不能改变它捕获的变量，因此重载的函数调用运算符是常量成员函数。如果我们为 lambda 指定 mutable 关键字，那么函数调用就不是 const 的了。
* 按值捕获的变量会作为类的私有数据成员。lambda 对按值引用变量的修改不会作用域被捕获的变量；在 lambda 创建后，对值捕获变量的修改于 lambda 是不可见的。
* 按引用捕获的变量不会作为类的数据成员。lambda 对按引用捕获变量的修改会同时作用域被捕获的变量；在 lambda 创建后，对引用捕获变量的修改于 lambda 是可见的。

``` c++
int val = 10;
int r = 10;

// 在lambda创建之前对val的修改于f可见
val = 30, r = 30;
auto f = [val, &r]() mutable ->void {
    cout << "f: " << val << ' ' << r << endl;
    val = 100;
    r = 100;
};
f(); // 30, 30

// 在lambda创建之后对val的修改于f不可见
val = 50, r = 50;
f(); // 30, 50 

// f中对val的修改于外部的val不可见
cout << "main: " << val << ' ' << r << endl; // 50, 10
```

#### （2）标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如 plus 类定义了一个函数调用运算符用于对运算对象执行 `+` 操作。

这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，即运算符的形参类型。例如 `plus<int>`  的运算对象是 int。

``` c++
plus<int> intAdd;
int sum = intAdd(20, 30);
multiplies<int> intMulti;
int mul = intMulti(10, 2);
```

其余的标准库函数对象有：

```c++
// 算数运算
plus<T>;	    // +
minus<T>;       // -
multiplies<T>;  // *
divides<T>;     // /
modulus<T>;	    // %
negate<T>;      // -

// 关系运算
equal_to<T>;		// ==
not_equal_to<T>;	// !=
greater<T>;			// >
greater_equal<T>;	// >=
less<T>;			// <
less_equal<T>;		// <=

// 逻辑运算
logical_and<T>;	// &&
logical_or<T>;	// ||
logical_not<T>;	// !
```

特别需要注意的是，标准库规定其函数对象对于指针同样使用。在 C++ 中，比较两个无关指针将会产生未定义的行为，然而我们有时希望通过比较指针的内存地址来 sort 存放指针的 vector。直接这么做将产生未定义的行为，因此我们可以通过一个标准库对象来实现该目的：

``` c++
vector<string*> vec;

// 错误：指针彼此之间没有关系,所以<将产生未定义的行为
sort(vec.begin(), vec.end(), [](string *a, string *b){
    return a < b;
});

// 正确：标准库规定指针的less是定义良好的
sort(vec.begin(), vec.end(), less<string*>());
```

#### （3）可调用对象与function

C++ 语言中有几种可调用的对象：

* 普通函数
* 函数指针
* 仿函数
* lambda 表达式
* bind 创建的对象

和其他对象一样，可调用的对象也有类型。例如，每个 lambda 都有他自己唯一的（未命名）类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等。

然后，两个不同类型的可调用对象却可能共享同一种<font color=blue>调用形式</font>。调用形式指明了调用返回的类型以及传递给调用的实参类型。实际上，一种调用类型对应一种函数类型，例如：`int(int,int)` 是一个函数类型，它接受两个 int，返回一个 int。

> 注意可调用形式不同于函数指针**！**
>
> 事实上，可调用形式和函数指针的形式非常类似：
>
> ``` c++
> return_type(args);		// 调用形式
> return_type(*)(args);	// 函数指针
> ```

对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看作具有相同的类型。这样我们就可以统一化所有可调用对象，从而实现格式上的同一。例如一个函数指针 `int(*)(int,int)`，它既可以指向函数，也可以指向一个相同调用形式的 lambda 表达式或仿函数。

C++ 提供了一个名为 `function` 的标准库模板类型来解决上述问题，`function` 定义在 `functional` 头文件中：

``` C++
// f接受一个可调用对象，其调用形式必须与T相同
function<T> f;			// 隐式构造一个空function
function<T> f(nullptr); // 显式构造一个空function
function<T> f(obj);		// 在f中存储可调用对象的副本
f;	     // 将f作为条件判断,若f存储可调用对象为真;反之为假
f(args); // 调用f中存储的可调用对象

// 类型成员 
result_type;			// 可调用成员对象的返回类型
argument_type;  		// 如果T中只有一个参数
first_argument_type;	// 如果T中只有两个参数
second_argument_type;
```

注意，不能直接将重载函数的名字存入 function 类型的对象中，即使重载函数之间参数的个数也不相同：

``` c++
int add(int a, int b)        {return a + b;}
int add(int a, int b, int c) {return a + b + c;}

function<int(int,int)> f(add); // 编译错误
```

解决该问题的一条途径是存储函数指针，而非函数的名字：

``` C++
int add(int a, int b)        {return a + b;}
int add(int a, int b, int c) {return a + b + c;}

int (*fp)(int,int) = add; 
function<int(int,int)> f(fp);
```

### 10. 类型转换运算符

转换构造函数（只含有一个实参的 non-explicit 构造函数）和类型转换运算符共同定义了**类类型转换**（用户定义的类型转换）。

类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其它类型。其形式一般为：

``` C++
operator type() const; // type为我们想要转换的类型
```

可以发现类型转换运算符有以下特点：

* 函数名就是我们要转换的类型（和构造函数类型）
* 无返回类型（实际上返回类型就是 type）
* 无参数（需要隐式执行。参数有默认值也不行）
* 必须作为类的成员函数
* 一般要定义为常量成员函数

类型转换运算怒发可以面向任意类型（void 除外）进行定义，只要改类型能作为函数的返回类型。因此，我们不允许转换为数组或函数类型（函数不能返回数组和函数），但可以转换成函数指针、数组指针或引用类型。

例如，我们定义一个只能存放 0~255 之间的整数的类：

``` c++
class SmallInt {
public:
    SmallInt(int _val = 0) : val(_val)
    {
        if(val < 0 || val > 255)
            throw runtime_error("Bad SmallInt value");
    }
    operator int() const { return val; }
public:
    size_t val;
};

int main()
{
    SmallInt a(16);
    a = 3.14;   // 3.14隐式转换为int然后再转换为SmallInt
    auto f = a + 3.14;  // a隐式的转换为int,然后与3.14执行加法,结果为double
    return 0;
}
```

注意编译器一次只能执行一个用户定义的类型转换，但隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。

#### （1）向bool的类型转换问题

在编程实践当中，类很少提供类型转换运算符。因为在大不多情况下，类型转换是隐式的、自动发生的，当它自动发生时，用户可能感觉比较意外，而不是感觉受到了帮助。然而这条法则有一个例外：对于类来说，定义向 bool 的类型转换还是比较普遍且使用的现象。

但是如果类想定义一个向 bool 的类型转换，则它常常会遇到一个问题：因为 bool 是一种算数类型，所以类类型的对象转换成 bool 之后就能被用在任何需要算数类型的上下文中。这样的类型转换可能引发意想不到的结果，特别是当 istream 含有向 bool 的类型转换时，下面的代码在【早期 C++ 版本】中将通过编译：

``` c++
int i = 42;
cin << i; // 如果istream向bool的转换不是显式的,该行代码将编译通过
```

按理来说对输入流执行输出运算符显然是错误的。然而，改代码能使用 istream 的 bool 类型转换将 cin 转换成 bool，而这个 bool 紧接着会被提升为 int 并用作内置的左移运算符的左侧运算对象。这样一来，这一行语句的效果相当于对一个 bool值（0 或 1）左移 42 个位置。这太让人惊讶了！

为了防止这种情况发生，C++11 新标准引入了“显式的类型转换”（explicit conversion operator）：

``` c++
class SmallInt {
public:
    // 编译器不会自动执行这一行类型转换
    explicit operator int() const { return val; }
};
```

此时我们只能使用显式的类型转换： `static_cast<T>(arg)`。不过该规定存在一个例外，即如果表达式被用作“条件”，则编译器会将显式的类型转换自动应用于它。换言之，当表达式出现在下列位置时，显示的类型转换被隐式的自动执行：

* if、while 即 do 语句的条件部分
* for 语句头的条件表达式
* 逻辑非（`!`）、逻辑或（`||`）、逻辑与（`&&`）的运算对象
* 条件运算符（`?:`）的条件表达式

<font color=blue>向 bool 的转换通常用在条件部分，所以 `operator bool` 一般定义成 `explicit` 的。</font>

在早期的 C++ 版本中，标准库通过对 IO 类型定义向 `void*` 的转换规则以避免自动类型转换的问题。在 C++11 新标准下，IO 标准库定义一个向 bool 的显式类型转换实现相同的目的。

#### （2）避免有二义性的类型转换

如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一的一种转换方式。否则的话，我们编写的代码很可能具有二义性。

在两种情况下可能产生多重转换路径：

1. 两个类提供相同的类型转换

例如下面两个类都提供了从 B 到 A 的类型转换：

``` c++
struct B;

struct A {
    A() = default;
    A(const B&) { // 将一个B转换为A
        cout << "A::constructor(B)" << endl;
    }
};

struct B {
    operator A() const { // 将一个B转换为A
        cout << "B::operaotr A()" << endl;
        return A();
    }
};

B b;

void func(A a) {}

int main()
{
    func(b.operator A()); // 显式调用
    func(A(b));           // 显式调用
    
    func(b);  // 二义性错误：到底是 func(B::operator A())
              // 还是 func(A::A(const B&))
    
    return 0;
}
```

值得注意的是，我们无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性。

> 虽然但是，在我的电脑上测试，在 Acwing 网站上测试，输出的都是 `A::constructor(B)` ，也就是优先调用 A 的构造函数。

2. 类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子就是算术运算符。对某个给定的类来说，最好只定义一个与算术类型有关的类型转换。

例如下面的类：

``` c++
struct A {
    A(int _i = 0) : i(_i) { puts("A(int)"); }
    A(double _d = 0) : d(_d) { puts("A(double)"); }
    operator int() const { return i; }
    operator double() const { return d; }

    int i;
    double d;
};

void func(short) {}

void main()
{
    A a1(3.134);    // A::A(double)
    func(a1);       // 二义性错误：含义是 func(A::operator int())
                   // 还是 func(A::operator double())
    
    long long x = 1;    
    A a2(x);       // 二义性错误：含义是 A::A(int)
                   // 还是A::A(double)
    
    short s = 3;
    A a3(s);       // A::A(int)
                   // short提升为int的优先级高于short提升为double
}
```

总而言之，除了显式的向 bool 类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显示构造函数。

#### （3）函数重载与转换构造函数

当调用重载函数时，如果多个用户定义的类型转换都提供了可行匹配，我们认为这些匹配类型**一样好**。在这个过程中，我们不会考虑任何可能出现的标准类型转换的级别。

例如下面的例子，尽管 10 构造类型 B 的对象是精确匹配，依然产生二义性错误：

``` c++
struct A {
    A(double) {}
};

struct B {
    B(int) {}
};


void func(const A&) {}
void func(const B&) {}

int main()
{
    func(10);   // 二义性错误：含义是 func(A::A(double))
                // 还是 func(B::B(int))
    return 0;
}
```

只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换。

例如：

``` c++
struct A {
    operator int() { return 0; }
};

void func(double) { puts("double"); }
void func(int) { puts("int"); }

int main()
{
    A a;
    func(a);    // int
    return 0;
}
```

### 11. 函数匹配与重载运算符

和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数。例如：

``` c++
struct A {
    friend A operator+(const A &a);
    A(int _val) : val(_val) {}
    int val;
};
A operator+(const A &a, const A &b) { // 非成员函数
    A res = a;
    res.val += b.val;
    return res;
}
/*=====================================*/
struct A {
    A(int _val) : val(_val) {}
    A operator+(const A &a) const { // 成员函数
        A res = a;
        res.val += val;
        return res;
    }
    int val;
};
```

对于上面 A 的两种定义，我们都可以通过下面的形式进行调用：

``` C++
int main()
{
    A a(1), b(2);
    A c = a + b;	// 调用 operator+
    cout << c.val << endl;
    return 0;
}
```

可以发现调用的形式是一样的。

----

另外就是注意 class 内部的函数和 class 外部的函数属于两个作用域，类似于下面的形式是编译通过的：

``` c++
struct A {
    void func() { puts("member"); }
};

void func()
{
    puts("non-member");
}
```

不同于运算符调用时，我们不知道调用的到底是成员函数还是非成员函数，对于普通函数，通过类成员调用的就是成员函数，否则就是非成员函数。

> 类成员只能调用成员函数。



## 九、面向对象程序设计

### 1. 多态

C++ 的多态是通过动态绑定实现的，当我们通过基类的指针或引用调用虚函数时，会触发动态绑定（运行时绑定）。引用或指针的静态类型与动态类型不同这一事实正是 C++ 支持多态性的根本所在。

如果使用基类的指针或引用就无法实现动态类型；如果不是虚函数就无法触发动态绑定。非虚函数根据静态类型执行，虚函数根据动态类型执行。

``` C++
class Foo {
public:
    void f() {
        puts("Foo::f");
    }
    virtual void g() {
        puts("Foo::g");
    }
};

class Bar : public Foo {
public:
    void f() {
        puts("Bar::f");
    }
    virtual void g() {
        puts("Bar::g");
    }
    void h() {
        puts("Bar::h");
    }
};

int main()
{
    Bar b;
    Foo &f = b;
    f.f();  // 非虚函数,静态绑定
    f.g();  // 虚函数,动态绑定
    //f.h();  // class "Foo" has no member "h"
    return 0;
}
```

当我们使用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动和赋值，它的派生类部分将被忽略掉。

其原理是因为我们的拷贝、移动和赋值都是通过函数，具体来说是成员函数来进行的，而这些函数接受的参数往往是一个 const 属性的引用，因此我们可以通过动态绑定将一个派生类对象传入基类的构造函数、移动赋值和拷贝赋值函数当中，但是基类的这些函数只会执行基类部分的构造、移动和赋值。派生类部分对基类来说是不可见的。

### 2. 继承

在继承关系下，基类通常都应该定义一个虚析构函数，即使该函数不执行任何操作也是如此。

关键字 virtual 只能出现在类内部的声明语句而不能出现在类外部的函数定义。

在一个对象中，继承自基类的部分和派生类自定义的部分在内存分布上不一定是连续的。

尽管在派生类对象中包含从基类继承而来的成员，但是派生类不可以直接初始化基类的成员，即使这些成员的访问权限是 public：
``` c++
class Base {
public:
    Base(int _a = 0) : a(_a) {}
    int a;
};

class Derived : public Base {
public:
    Derived(int _a = 0, int _b = 0, int _c = 0)
        : a(_a), b(_b), c(_c) {}
    // error: class ‘Derived’ does not have any field named ‘a’
    // "a" is not a nonstatic data member or base class of class "Derived"
    int b, c;
};
```

每个类控制它自己的成员的初始化过程，因此应该将 Derived 的构造函数修改为：

``` C++
class Derived : public Base {
public:
    Derived(int _a = 0, int _b = 0, int _c = 0)
        : Base(_a), b(_b), c(_c) {}
    int b, c;
};
```

另外在初始化时，应该首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

虽然派生类不能直接初始化基类的成员，但是从语法上来说，我们可以在类构造函数体内给它的 public 或 protected 成员赋值。但是最好不要这样做，和使用基类的其他场合一样，派生类应该遵循基类的接口。派生类应该使用基类的构造函数来初始化那些从基类中继承而来的成员。

> <font color=blue>编程规范：遵循类的接口</font>
>
> 每个类负责定义各自的接口。想要与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。

``` c++
class Derived : public Base {
public:
    Derived(int _a = 0, int _b = 0, int _c = 0)
        : b(_b), c(_c) { a = _a; }
    int b, c;
};
```

静态成员也是类的成员，也会被派生类继承。但是无论如何继承，静态成员只会存在唯一的实例。

``` C++
class Foo {
public:
    static void func() {
        cout << "Foo::static function" << endl;
    }
    static int val;
};

int Foo::val = 1024;

class Bar : public Foo {
public:
};

int main()
{
    cout << Bar::val << endl;	// 1024
    Bar::func(); // Foo::static function
    return 0;
}
```

当我们声明一个派生类时，不应该包含它的派生列表。一条声明语句的目的是令程序知晓某个名字的存在以及改名字表示一个什么样的实体，如一个类、一个函数、一个变量等。派生列表以及与定义有关的其它细节必须与类的主体一起出现。

``` C++
class Foo {};
class Bar : public Foo; // class or struct definition is missing
class Bar : public Foo {};
```

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：

``` C++
class Foo;
class Bar : public Foo { // incomplete type "Foo" is not allowed
};
```

这一规定的原因显而易见：当我们指定了派生列表时，实际上就是在定义类了，定义类肯定要确定类的大小，但基类还没定义，大小就不知道。

如果我们想定义一个不能被其它类继承的类，或者不想考虑它是否适合作为一个基类。可以使用 C++11 新标准提供的 final 关键字：
``` c++
class Foo final {};
class Bar : Foo {} // a 'final' class type cannot be used as a base class
```

当我们使用存在继承关系的类型时，必须将一个变量或表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的， 它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才能知道。如果表达式既不是指针也不是引用，则它的静态类型永远与动态类型一致。

### 3. 虚函数

通常情况下，如果我们不使用一个函数，是无需给出定义的。但是虚函数必须给出定义，因为虚函数的绑定可能在运行时发生，因此编译器无法在编译期判断虚函数到底会不会被使用。

``` C++
class Foo {
public:
    virtual void f();
};
Foo f;  // undefined reference to `vtable for Foo'

/*-------------------------------------------------*/

class Foo {
public:
     void f();
};
Foo f;  // 编译通过
```

一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数，因此可以无需再次使用 virtual 关键字声明。

派生类中虚函数的调用形式必须与基类中虚函数的调用形式完全相同。但有一个例外：当虚函数的返回类型是类本身的指针或引用时。例如，D 继承自 B，则基类 B 的虚函数可以返回 `B*` 而派生类可以返回 `D*`，只不过这样的返回类型要求从 D 到 B 的转换是可访问的。

``` c++
class Foo {
public:
    virtual Foo* func() {
        return f;
    }

    Foo *f;
};

class Bar : public Foo {
public:
    virtual Bar* func() override {
        return b;
    }
    Bar *b;
};
```

如果派生类定义了一个与基类中虚函数名字相同但参数列表不同的类，编译器会认定该函数与基类中的虚函数是相互独立的。这时派生类中的函数并没有覆盖掉基类的虚函数，但有时我们的本意是覆盖虚函数，但搞错了参数列表，这样的错误调试起来是比较困难的。不过好在 C++ 新标准提供了 override 关键字，用来告诉编译器我们这个函数是用来覆盖基类中的某个虚函数。

final 除了应用于类的继承，还可以用于虚函数，表示该虚函数不可被覆盖。

**和其它函数一样，虚函数也可以拥有默认实参。但值得注意的是，如果某次函数调用使用了默认实参，则该实参的值由本次调用的静态类型决定。**

其本质这是因为默认参数值是根据**声明类型**（编译时类型）来确定的，而虚函数调用的**函数体**是根据对象的**实际类型**（运行时类型）来确定的。

``` C++
class Foo {
public:
    virtual void f(int val = 100) {
        cout << "Foo: " << val << endl;
    }
};

class Bar : public Foo {
public:
    virtual void f(int val = 200) {
        cout << "Bar: " << val << endl;
    }
};

Foo f;
Bar b;

int main()
{
    Foo &cur = b;
    cur.f(); // Bar: 100
    return 0;
}
```

在上面的例子中，我们通过动态绑定，调用的是 `Bar::f()` ，但输出的 val 的值却是 100，这可能与我们的本意不符。因此为了避免这种反直觉的情况发生，最好将基类和派生类中定义的默认实参值设置为一样的。

在某些情况下，我们可能希望对虚函数的调用不要进行的动态绑定，或是希望其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的：

``` C++
class Foo {
public:
    virtual void f(int val = 100) {
        cout << "Foo: " << val << endl;
    }
};

class Bar : public Foo {
public:
    virtual void f(int val = 200) {
        cout << "Bar: " << val << endl;
    }
};

class Dad : public Bar {
public:
    virtual void f(int val = 300) {
        cout << "Bar: " << val << endl;
    }
};

Foo f;
Bar b;
Dad d;

int main()
{
    Foo &cur = d;
    cur.f();          // Dad: 100
    cur.Foo::f();     // Foo: 100
    // cur.Bar::f();  // error: ‘Bar’ is not a base of ‘Foo’
    return 0;
}
```

在上面的代码中，要注意 cur 不能调用 Bar 版本的虚函数 `f()`，因为 cur 的静态类型是 Foo，而表达式 `cur.Bar::f()` 相当于通过 Foo（基类） 对象调用 Bar（派生类） 的成员函数，而从基类到派生类的转换是不合法的。我们可以这样修改代码：

``` c++
Bar &cur = d;
cur.f();          // Dad: 100
cur.Foo::f();     // Foo: 100
cur.Bar::f();     // Bar: 200
return 0;
```

将引用的类型修改为 Bar 之后，调用就合法了，因为 Bar（派生类）对象可以转换为 Foo（基类）对象。

另外一个值得注意的点就是，当我们显式指定虚函数版本时，参数默认值使用的是我们指定的虚函数版本的默认值，而不是静态类型虚函数版本的默认值。

> 什么时候需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数需要调用他覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要完成的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。

### 4. 抽象基类

和普通的虚函数不同，<font color=blue>纯虚函数</font>无需定义。我们可以在虚函数声明后面加上 `=0` 来标识这是一个纯虚函数。其中 `=0` 只能出现在虚函数声明语句处。另外如果我们确实想为纯虚函数提供定义，只能在类外提供。

含有（或者未经覆盖直接继承）纯虚函数的类称为<font color=blue>抽象基类</font>。抽象基类负责定义接口（纯虚函数），而后续的其它类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。即使我们在类的外部提供了纯虚函数的定义也不行。

### 5. 访问控制与继承

#### （1）protected

protected 访问权限除了可以让派生类访问之外，还有一条重要的性质：派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。**派生类对于一个基类对象中的受保护成员没有任何访问权限。**例如：

``` C++
class Base {
protected:
    int proc_mem;
};

class Derived : public Base {
    friend void func(Derived& d);
    friend void func(Base& b);
public:
    int val;
};

void func(Derived& d) {
    d.proc_mem = d.val = 100;
}

// protected member "Base::proc_mem" is not accessible 
// through a "Base" pointer or objectC/C++(410)
void func(Base& b) {
    b.proc_mem = 100;
}
```

我们不可以通过派生类的友元函数去访问基类对象的受保护成员；只能通过派生类对象去访问基类的受保护成员。

这样做的目的是为了确定基类对象的访问安全（受保护成员对用户应该是不可见的）。如果我们可以通过派生类的友元函数来访问基类对象的受保护成员，那么我们（用户）只需要通过继承就可以规避掉基类的访问控制。

#### （2）派生访问说明符

* `public` 继承**：基类的 `public` 成员在派生类中依然是 `public`，`protected` 成员依然是 `protected`，`private` 成员保持不可访问。**
* `protected` 继承**：基类的 `public` 和 `protected` 成员在派生类中都变为 `protected`，`private` 成员保持不可访问。**
* **`private` 继承**：基类的 `public` 和 `protected` 成员在派生类中都变为 `private`，`private` 成员保持不可访问。

<font color=blue>首先需要说明的一点是，对于派生访问说明符，无论是 public、private 还是 protected 继承，它们对派生类的成员（以及友元）能否访问其直接基类的成员没有任何影响。对基类成员的访问权限只与基类中的访问说明符有关。派生访问说明符的目的是控制派生类用户（派生类以及派生类的派生类）对于基类成员的访问权限。</font>

>  例如，即便类 D 以 private 继承类 B，类 D 依然可以访问类 B 中的 public 和 protected 成员，只不过这些成员在类 D 中的访问级别是 private。
>
> 因此此时如果类 DD 继承自类 D，无论 DD 采取何种方式继承，它都不可以访问类 B 中的任何成员，因为类 B 的成员此时在类 D 中已经变成 private 权限了。

#### （3）派生类向基类转换的可访问性

派生类向基类的转换是否可访问由使用该转换的代码决定（用户还是成员函数或友元），同时派生类的派生访问说明符也会有影响。

* 用户：只有当 D 共有地继承 B 时，用户代码才能使用派生类向基类的转换。

``` c++
class B {};
class PucD : public B {};
class ProtD : protected B {};
class PriD : private B {};

B b;
PucD pucd;
ProtD protd;
PriD prid;

int main()
{
    b = pucd;
    b = protd; // conversion to inaccessible base class "B" is not allowed
    b = prid;  // conversion to inaccessible base class "B" is not allowed
    return 0;
}
```

* D 的成员和友元：无论 D 以什么方式继承 B，D 的成员和友元都能使用派生类到基类的转换。

``` C++
class PucD : public B {
    void f() {
        B b;
        PucD pucd;
        b = pucd;
    }
};
class ProtD : protected B {
    void f() {
        B b;
        ProtD protd;
        b = protd;
    }
};
class PriD : private B {
    void f() {
        B b;
        PriD prid;
        b = prid;
    }
};
```

* D 的派生类的成员函数和友元：如果 D 继承 B 的方式是共有的或受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换。

``` C++
class B {};

class PucD : public B {};
class ProtD : protected B {};
class PriD : private B {};

class PucDD : public PucD {
    void f() {
        B b;
        PucD pucd;
        b = pucd;
    }
};

class ProtDD : protected ProtD {
    void f() {
        B b;
        ProtD protd;
        b = protd;
    }
};

class PriDD : private PriD {
    void f() {
        B b; // type "B::B" (declared at line 5) is inaccessible
        PriD prid;
        b = prid;
    }
};
```

<font color=blue>一言以蔽之，对于代码中的某个节点来说，如果基类的公有成员是可访问的，则派生类想基类的类型转换是可访问的；反之则不行。</font>

#### （4）关于访问权限的理解

在 C++ 中，类的访问权限主要是考虑到以下三种用户：

* 类设计者（成员函数及友元）
* 普通用户
* 派生类

如果我们将 public、protected 和 private 三种权限抽象为是否可以访问，那么对于类设计者来说，三种访问权限都是可访问的；对于派生类来说，public 和 protected 是可访问的；对于普通用户来说，只有 public 权限是可访问的。

#### （5）友元与继承

<font color=blue>友元关系是单向的。</font>

前面提到过，友元关系是不可传递的。例如：B 是 A 的友元类，C 是 B 的友元类，但 C 不是 A 的友元类。

同样的，友元关系也不能继承。例如 A 是类 C 的友元类，但 A 不是 C 的派生类的友元类；A 的派生类也不是了 C 的友元类。

``` C++
class A;

class B{
    friend class A;
protected:
    int b = 20;
};

class D : public B {
protected:
    int d = 30;
};

class A {
public:
    int fc(B b) {
        return b.b;        
    }
    // 这里可能有些疑惑,我们可以访问D中的受保护成员
    // 但确实是合法的
    int fa(D d) {
        return d.b;
    }
    int fd(D d) {
        return d.d; // 不可访问
    }
};

class DA : public A {
public:
    void f(B b) {
        return b.b;	// 不可访问
    }
};
```

对于函数 `fa`，我们可以访问派生类 D 中的基类部分，这着实令我们疑惑。但如果我们尝试访问 D 的对象，例如 `d.d`，就发导致不可访问错误。

其原因在于，在 C++ 中，每个类负责控制自己的成员的访问权限。因为 A 是 B 的友元，所有 A 能够访问 B 对象的成员，这种可访问包括了 B 对象内嵌在其派生类对象中的情况。

#### （6）改变个别成员的可访问性

有时候我们只希望将个别基类成员的可访问性改为 private，其余的可访问性不变或者将基类成员分为不同的访问级别。通过 using 声明可以达到这一目的：
``` c++
class B {
protected:
    int a = 1;
    int b = 2;
public:
    int c = 3;
private:
    int d = 4;
};

class D : public B {
private:
    using B::a;
public:
    using B::b;
private:
    using B::d; // member "B::d" is inaccessible
};

int main()
{
    D d;
    cout << d.a << endl; // member "B::a" is inaccessible
    cout << d.b << endl;
    cout << d.c << endl;
    return 0;
}
```

但要注意，只可以为那些派生类可见的名字提供 using 声明，对于不可兼得名字（private），即使我们将它放在 private 访问级别下也不行。

> 这显然是合理的，不然我们通过一个 using 声明就破坏了基类的成员保护。太可怕了！

#### （7）class和struct

在 C++ 中，struct 和 class 的**唯一区别**就是默认访问权限和默认继承曲权限的不同。

* class 默认 private 继承，成员是 private 属性
* struct 默认 public 继承，成员是 public 属性

虽然有默认权限，但我们在使用时，最好还是显式声明出访问权限而不是依赖于默认的访问权限。

### 6. 继承中的类作用域

前面提到过每个类都是一个单独的作用域，并且这个作用域处于类的外层作用域之中。而在类的继承情况下，派生类的作用域嵌套在基类作用域当中。派生类会隐藏与基类同名的成员，不过如果我们想使用基类中的同名变量或函数，可以使用作用域运算符：

``` c++
struct B {
    int val = 10;
    void f() {
        cout << "B: " << val << endl;
    }
};

struct D : public B {
    int val = 20;
    // 即使函数签名不一致,基类成员的同名函数也会被隐藏掉
    void f(int x) {
        cout << B::val << endl; // 10
        cout << "D: " << val << endl; // D: 20
        f();	// too few arguments in function cal
    }
};
```

**编程规范：除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类的名字。**

对于重载函数，派生类会隐藏基类所有同名的重载函数：

``` c++
struct B {
    void f() { puts("B::f(void)"); }
    void f(int a) { puts("B::f(int)"); }
};

struct D : public B {
    void f(int a, int b) { puts("D::f(int,int)"); }
};

void func()
{   
    D d;
    d.f(1, 1);
    d.f(); // too few arguments in function call
}
```

因此如果我们希望基类的所有重载版本在派生类中都是可见的，那他派生类就需要覆盖所有版本，或者一个因为不覆盖。

不过一种更好的解决办法是使用 using 声明，这样我们就无需覆盖基类中的每一个版本了。另外，由于 using 声明只是指定了一个名字而不指定具体的形参列表，所以一条基类成员函数的 using 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数即可：

``` c++

struct B {
    void f() { puts("B::f(void)"); }
    void f(int a) { puts("B::f(int)"); }
    void f(string s) { puts("B::f(string)"); }
};

struct D : public B {
    // using的位置并无要求
    void f(int a, int b) { puts("D::f(int,int)"); }
    using B::f;
};

void func()
{   
    D d;
    d.f(); 
    d.f(1);
    d.f("hello");
    d.f(1, 1);
}
```

### 7. 名字查找与继承

假定我们调用 `p->mem()` 或 `r.mem()`，则依次执行以下 4 个步骤：

1. 首先确定 p 的静态类型。因为我们调用的是一个成员，因此 p 一定是类类型。
2. 在 p 的静态类型对应的类中查找 mem。如果找不到，在继承链中网上查找。如果最终找不到，报错。
3. 一旦找到了 mem，尽心类型检查。如果调用不合法，报错。
4. 如果 mem 是虚函数，且是通过指针 p 或引用 r 调用，那么编译器产生的代码将在运行时根据动态类型确定到底运行该虚函数的哪个版本；反之，编译器将产生一个常规函数调用。

<font color=blue>一如既往，名字查找先于类型检查。</font>

### 8. 构造函数与拷贝控制

和其它类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和析构。

#### （1）虚析构函数

继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配并销毁继承体系中的对象了。

``` c++
class Base {
public:
    ~Base() { puts("base"); }
};

class Derived : public Base {
public:
    ~Derived() { puts("derived"); }
};

void test()
{
    Base *d = new Derived();
    delete d; // base
}
```

这里我们通过基类指针定义了一个指向派生类的对象，但是当我们 delete 时，调用的是基类的虚构函数，这显然不符合我们的本意。

``` C++
class Base {
public:
    // 虚函数
    virtual ~Base() { puts("base"); }
};

class Derived : public Base {
public:
    ~Derived() { puts("derived"); }
};

class Derived2 : public Derived {
public:
    ~Derived2() { puts("derived2"); }
};

int main() 
{
    Base *d = new Derived();
    delete d; 
    Derived *d2 = new Derived2();
    delete d2;
    return 0;
}

// derived
// base
// derived2
// derived
// base
```

和其他虚函数一样，析构函数的虚属性也会被继承。只要基类的析构函数是虚函数，就能确保当我们 delete 基类指针使将运行正确的析构版本。

而且我们可以发现，调用派生类的析构函数会同时调用基类的析构函数，这和非动态对象的析构函数执行过程是一样的。

``` c++
class Base {
public:
    virtual ~Base() { puts("base"); }
};

class Derived : public Base {
public:
    ~Derived() { puts("derived"); }
};

class Derived2 : public Derived {
public:
    ~Derived2() { puts("derived2"); }
};

int main() 
{
    Derived d;
    Derived2 d2;
    return 0;
}

// derived
// base
// derived2
// derived
// base
```

之前我们曾介绍过一条经验准则，即一个类如果需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。

基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个影响：如果一个类定义了析构函数，即使它通过 =default 的形式使用了合成的版本，编译器也不会为这类合成移动操作。

#### （2）合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其它合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值和销毁的操作。**此外，这些合成成员还负责使用<font color=blue>直接基类</font>中对应的操作对一个对象的直接积累部分进行初始化、赋值和销毁的操作**。例如：
``` c++
class Base {
public:
    Base(int _v1 = 0) : v1(_v1) {}
    Base& operator=(const Base &b) {
        puts("Base::op=");
        v1 = b.v1;
        return *this;
    }
    virtual ~Base() = default;
    int v1;
};

class Derived : public Base {
public:
    Derived(int _v1 = 0, int _v2 = 0)
        : Base(_v1), v2(_v2) {}
    int v2;
};

class Derived2 : public Derived {
public:
    Derived2(int _v1 = 0, int _v2 = 0, int _v3 = 0)
        : Derived(_v1, _v2), v3(_v3) {}
    int v3;
};

Derived2 a(1, 2, 3);
Derived2 b(10, 20, 30);

int main() 
{
    a = b;
    cout << a.v1 << ' ' << a.v2 << ' ' << a.v3 << endl;
    // Base::op=
    // 10 20 30
    return 0;
}
```

这里我们使用 Derived2 的合成的赋值运算符进行赋值，这个合成的赋值运算符会拷贝 Derived2 自己的成员变量 v3，然后调用直接基类 Derived 的赋值运算符。而由于 Derived  没有定义赋值运算符，所以它的默认行为是拷贝它自己的成员变量 v2 然后调用它的直接基类 Base 的赋值运算符。

如果我们定义了 Derived 的赋值运算符：
``` C++
class Base {
public:
    Base(int _v1 = 0) : v1(_v1) {}
    Base& operator=(const Base &b) {
        puts("Base::op=");
        v1 = b.v1;
        return *this;
    }
    virtual ~Base() = default;
    int v1;
};

class Derived : public Base {
public:
    Derived(int _v1 = 0, int _v2 = 0)
        : Base(_v1), v2(_v2) {}
    Derived& operator=(const Derived &b) {
        puts("Derived:op=");
        v2 = b.v2;
        return *this;
    }
    int v2;
};

class Derived2 : public Derived {
public:
    Derived2(int _v1 = 0, int _v2 = 0, int _v3 = 0)
        : Derived(_v1, _v2), v3(_v3) {}
    int v3;
};

Derived2 a(1, 2, 3);
Derived2 b(10, 20, 30);

int main() 
{
    a = b;
    cout << a.v1 << ' ' << a.v2 << ' ' << a.v3 << endl;
    // Derived:op=
    // 1 20 30
    return 0;
}
```

Derived2 的合成赋值运算符依然拷贝自己的成员变量 v3，然后调用它的直接基类 Derived 的赋值运算符。此时由于 Derived 定义了赋值运算符，因此他会执行自定义的赋值运算符的内容，由于我们自定义的赋值运算符只是拷贝了 Derived 的成员变量 v2，所以这里 Derived2 的赋值运算符只能拷贝 v3 和 v2。

那如果我们自定义了 Derived2 的赋值运算符呢？

``` c++
class Base {
public:
    Base(int _v1 = 0) : v1(_v1) {}
    Base& operator=(const Base &b) {
        puts("Base::op=");
        v1 = b.v1;
        return *this;
    }
    virtual ~Base() = default;
    int v1;
};

class Derived : public Base {
public:
    Derived(int _v1 = 0, int _v2 = 0)
        : Base(_v1), v2(_v2) {}
    Derived& operator=(const Derived &b) {
        puts("Derived:op=");
        v2 = b.v2;
        return *this;
    }
    int v2;
};

class Derived2 : public Derived {
public:
    Derived2(int _v1 = 0, int _v2 = 0, int _v3 = 0)
        : Derived(_v1, _v2), v3(_v3) {}
    Derived2& operator=(const Derived2 &b) {
        puts("Derived2::op=");
        v3 = b.v3;
        return *this;
    }
    int v3;
};

Derived2 a(1, 2, 3);
Derived2 b(10, 20, 30);

int main() 
{
    a = b;
    cout << a.v1 << ' ' << a.v2 << ' ' << a.v3 << endl;
    // Derived2::op=
    // 1 2 30
    return 0;
}
```

由于我们自定义了 Derived2 的赋值运算符，所以这里只会执行自定义赋值运算符函数体中的内容 —— 拷贝 v3。**注意此时不会调用其基类的赋值运算符。**

不过注意对于构造和析构函数来说，即使我们自定义了派生类的构造和析构函数，也依然会执行直接基类的构造和析构函数：

``` C++
struct Foo {
    Foo() { puts("Foo::ctor"); }
    ~Foo() { puts("Foo::~"); }
};

struct Bar : public Foo {
    // 自定义了Bar的构造和析构行为
    Bar() { puts("Bar::ctor"); }
    ~Bar() { puts("Bar::~"); }
};

int main() 
{
    Bar b;
    // Foo::ctor
    // Bar::ctor
    // Bar::~
    // Foo::~
    return 0;
}
```

拷贝构造函数也是一样，不过要注意的是，在派生类的拷贝构造函数当中，会调用直接基类的默认构造函数而不是拷贝构造函数。

``` c++
struct Foo {
    Foo() { puts("Foo::ctor"); }
    Foo(const Foo&) { puts("Foo::copy ctor"); }
};

struct Bar : public Foo {
    // 自定义了Bar的构造和析构行为
    Bar() { puts("Bar::ctor"); }
    Bar(const Bar&) { puts("Bar::copy ctor"); }
};

int main() 
{
    Bar b;
    Bar c(b);
// Foo::ctor
// Bar::ctor
// Foo::ctor
// Bar::copy ctor
    return 0;
}
```

如果我们想在派生类的拷贝构造函数当中调用基类的拷贝构造函数，可以用动态绑定来实现，因为拷贝构造函数一般接受的是一个引用：

``` C++
struct Foo {
    Foo(int _v1 = 10) : v1(_v1) { puts("Foo::ctor"); }
    Foo(const Foo&) { puts("Foo::copy ctor"); }
};

struct Bar : public Foo {
    // 自定义了Bar的构造和析构行为
    Bar(int _v2 = 1000) : v2(_v2) { puts("Bar::ctor"); }
    Bar(const Bar& x) : Foo(x) // 调用直接基类的copy ctor
    { puts("Bar::copy ctor"); }
};

int main() 
{
    Bar b(10);
    Bar c(b);
    // Foo::ctor
    // Bar::ctor
    // Foo::copy ctor
    // Bar::copy ctor
    return 0;
}
```

不过，虽然派生类自定义的拷贝构造函数依然可以调用直接基类的构造函数，但派生类自己的拷贝构造行为被我们写死在了函数体当中，也即此时他不会默认拷贝派生类自己的成员变量：

``` c++
struct Foo {
    Foo(int _v1 = 10) : v1(_v1) { puts("Foo::ctor"); }
    Foo(const Foo&) { puts("Foo::copy ctor"); }
    int v1;
};

struct Bar : public Foo {
    // 自定义了Bar的构造和析构行为
    Bar(int _v2 = 1000) : v2(_v2) { puts("Bar::ctor"); }
    Bar(const Bar& x) : Foo(x) { puts("Bar::copy ctor"); }
    int v2;
};

int main() 
{
    Bar b(10);
    cout << b.v1 << ' ' << b.v2 << endl;
    Bar c(b);
    cout << c.v1 << ' ' << c.v2 << endl;
    // Foo::ctor
    // Bar::ctor
    // 10 10
    // Foo::copy ctor
    // Bar::copy ctor
    // 791099984 32711
    return 0;
}
```

在上面的代码中，我们没有在拷贝构造中手动完成对象的拷贝工作，因此这里对象 c 的值是未定义的。

#### （3）派生类中删除的拷贝构造和基类的关系

* 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认的拷贝（移动）构造函数是被删除的，因为编译器无法销毁派生类对象的基类部分
* 如果基类中的默认构造函数、拷贝（移动）构造函数、拷贝（移动）赋值运算符或析构函数是被删除的或不可访问的，则派生类中对应的成员函数是被删除的，因为编译器不能使用基类成员来执行派生类对象积累部分的构造、拷贝、移动或销毁操作

#### （4）移动操作与继承

前面提到过，大多数基类都需要定义一个虚析构函数。因此在默认情况下，积累通常不会有合成的移动操作，而且在它的派生类中也没有合成的移动操作。

因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时，应该首先在基类中进行定义：

``` c++
struct Foo {
    Foo() = default;

    Foo(Foo &&) = default;
    Foo& operator=(Foo &&) = default;

    Foo(const Foo&) = default; 
    Foo& operator=(const Foo&) = default;
    
    virtual ~Foo() = default;
};
```

并且，由于我们定义了移动操作，所以编译器不会为我们生成合成的拷贝操作，因此我们还需要定义拷贝构造和拷贝赋值。

### 9. 派生类的拷贝控制成员

#### （1）构造、赋值和析构

派生类构造函数在其初始化阶段不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。**注意初始化基类部分只能通过基类的构造函数**：

``` C++
struct Foo {
    Foo() {puts("Foo::ctor");}
	Foo(double _pi) : pi(_pi) {puts("Foo::ctor(double)");}
    Foo(Foo &&) = default;
    Foo& operator=(Foo &&) = default;

    Foo(const Foo&) = default; 
    Foo& operator=(const Foo&) = default;
    
    virtual ~Foo() = default;

    double pi;
};

struct Bar : Foo {
    Bar(double _pi, int _val, string _s)
        : Foo(_pi), val(_val), s(_s)
        {puts("Bar::ctor");}

    int val;
    string s;
};
```

派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动积累部分的成员。类似的，派生类的拷贝赋值运算符和移动赋值运算符也需要为其基类部分赋值。**为基类部分构造或赋值的操作都是通过<font color=blue>基类的接口</font>来实现的。**

如果我们没有显式调用基类的构造函数来初始化，编译器会执行基类的默认构造函数。但如果我们没有显式调用基类的赋值函数来赋值，编译器不会执行基类部分的赋值运算符。因为构造是必须的，赋值不是必须的：

``` c++
struct Foo {
    Foo() : pi(99.99) {}
	Foo(double _pi) : pi(_pi) {}

    Foo(const Foo &x) : pi(x.pi) {}
    Foo& operator=(const Foo &x) {
        pi = x.pi;
        return *this;
    }

    virtual ~Foo() = default;

    double pi;
};

struct Bar : Foo {
    Bar(double _pi, int _val, string _s)
        : Foo(_pi), val(_val), s(_s) {}
    Bar(const Bar &x) : val(x.val), s(x.s) {}
    Bar& operator=(const Bar &x) {
        val = x.val;
        s = x.s; 
        return *this;
    }
    
    int val;
    string s;
};

int main() 
{
    Bar b(3.14, 1024, "hello");
    Bar a(12.34, 1234, "1234");

    // 拷贝构造
    Bar c(b);
    cout << c.pi << ' ' << c.val << ' ' << c.s << endl;
    // 赋值运算符
    a = b;
    cout << a.pi << ' ' << a.val << ' ' << a.s << endl;
    return 0;
}
// 99.99 1024 hello
// 12.34 1024 hello
```

在上面的派生类 Bar 中，我们在其拷贝构造和拷贝赋值部分只完成了派生类对象部分构造和拷贝操作。

* 在拷贝构造函数中：派生类调用基类的默认构造函数将积累部分的 pi 初始化为 99.99
* 在拷贝赋值函数中：派生类只完成了自身成员变量的赋值，因此这里派生类对象 a 中基类部分的 pi 的值仍然是 12.34

无论怎样，这都不是我们想要的结果。正确的写法应该是通过动态绑定，调用基类的接口完成构造和赋值：（移动赋值和拷贝赋值是同样的道理）

``` c++
struct Foo {
    Foo() : pi(99.99) {}
	Foo(double _pi) : pi(_pi) {}

    Foo(const Foo &x) : pi(x.pi) {}
    Foo& operator=(const Foo &rhs) {
        pi = rhs.pi;
        return *this;
    }

    virtual ~Foo() = default;

    double pi;
};

struct Bar : Foo {
    Bar(double _pi, int _val, string _s)
        : Foo(_pi), val(_val), s(_s) {}
    Bar(const Bar &x) 
        : Foo(x), // 显式调用基类的拷贝构造函数 
    	  val(x.val), s(x.s) {}
    Bar& operator=(const Bar &rhs) {
        // 显式调用基类的赋值运算符
        Foo::operator=(rhs);
        val = rhs.val;
        s = rhs.s; 
        return *this;
    }
    
    int val;
    string s;
};

int main() 
{
    Bar b(3.14, 1024, "hello");
    Bar a(12.34, 1234, "1234");

    // 拷贝构造
    Bar c(b);
    cout << c.pi << ' ' << c.val << ' ' << c.s << endl;
    // 赋值运算符
    a = b;
    cout << a.pi << ' ' << a.val << ' ' << a.s << endl;
    return 0;
}
// 3.14 1024 hello
// 3.14 1024 hello
```

与构造、赋值不同，析构函数只负责销毁派生类自己的分配的资源。本质上，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分是自动销毁的。

#### （2）在构造函数和析构函数中调用虚函数

当我们在构造函数或析构函数中调用了虚函数，则我们应该执行与构造函数或析构函数所属类型相同的虚函数版本。这意味着，在构造函数和析构函数当中，虚函数不会进行动态绑定从而绑定到派生类的版本。

原因也很简单，因为在基类的构造函数当中，派生类部分还未初始化；在基类的析构函数中，派生类部分已经销毁了。

#### （3）“继承”的构造函数

<font color=blue>在 C++ 中，“继承”的构造函数指的是子类通过“继承”基类的构造函数来实现构造函数的“继承”。</font>C++11 引入了“继承”构造函数的概念，允许子类使用基类的构造函数，而无需重新定义。使用 `using` 关键字可以让基类的构造函数直接在派生类中可用。这样可以**减少代码重复，同时让子类更简洁**。

假设我们有一个基类 Base 和一个派生类 Derived：

``` c++
class Base {
public:
    Base(int x) {
        cout << "Base constructor with int: " << x << endl;
    }
    Base(double y) {
        cout << "Base constructor with double: " << y << endl;
    }
};

class Derived : public Base {
public:
    using Base::Base;
};

int main() 
{
    Derived d1(16);
    Derived d2(3.14);
    return 0;
}
// Base constructor with int: 16
// Base constructor with double: 3.14
```

我们对这里的继承加上了引号，是因为这种继承并不是像普通成员函数那样的继承。C++ 中的继承构造函数是在编译器层面实现的。编译器在编译时生成了一组“中间构造函数”，以便让派生类可以直接调用基类的构造函数。

##### 实现原理

当我们在派生类中使用 `using Base::Base` 来继承基类的构造函数时，编译器实际上为每个基类构造函数在派生类中生成了一个**隐式的构造函数**。这些隐式构造函数将接收的参数直接传递给基类的对应构造函数，然后完成派生类的初始化。这样就实现了构造函数的继承。

通常情况下，using 声明语句只是令某个名字在当前作用域内可见。而当作用域构造函数时，using 声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换言之，对于基类的每个构造函数，编译器都生成一个形参列表完全相同的构造函数。其形式如下：

``` c++
derived(parms) : base(args) {}
// derived：派生类的名字
// base：基类的名字
// params：构造函数的形参
// args：将派生类的形参传递给基类的构造函数
```

例如，考虑以下代码：

```cpp
class Base {
public:
    Base(int x) { /* ... */ }
    Base(double y) { /* ... */ }
};

class Derived : public Base {
    using Base::Base; // 继承构造函数
};
```

在编译时，编译器会自动为 `Derived` 类生成如下的构造函数：

```cpp
class Derived : public Base {
public:
    // 编译器生成的桥接构造函数
    Derived(int x) : Base(x) {}        // 调用 Base(int)
    Derived(double y) : Base(y) {}     // 调用 Base(double)
};
```

##### “继承”的构造函数的特点

和普通成员的 using 声明不一样，一个构造函数的 using 声明不会改变该构造函数的访问级别。即，不管 using 声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和共有的构造函数也是同样的规则。

一个 using 声明不能指定 explicit 和 constexpr。如果基类的构造函数是 explicit 或者 constexpr，则继承的构造函数也拥有相同的属性。

当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个有默认实参的形参。例如：

``` c++
class Base {
public:
    Base(int _a = 1, int _b = 2, int _c = 3) 
    : a(_a), b(_b), c(_c)  {}
    
    int a, b, c;
};

class Derived : public Base {
public:
    using Base::Base;
};

/*====================================================*/
class Derived : public Base {
public:
    Derived(int _a, int _b, int _c) : Base(_a, _b, _c) {}
   	Derived(int _a, int _b) : Base(_a, _b) {}
   	Derived(int _a) : Base(_a) {}
   	Derived() : Base() {}
};
/*====================================================*/
```

虽然在派生类继承过来的构造函数中忽略掉了默认实参（默认值），但当我们通过 Base 进行构造的时候，依然可以在 Base 中使用这些默认值。

如果基类含有多个构造函数，则除了以下这两种外，大多数时候派生类会继承所有这些构造函数：

1. 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表。此时继承而来的构造函数会被派生类定义的构造函数覆盖。
2. 默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。

### 10. 容器与继承

当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）。这些指针可以指向基类对象，也可以指向派生类对象。

## 十、模板

### 1. 非类型模板参数

除了定义类型参数，还可以在模板中定义非类型参数。一个非类型参数用来表示一个整形，或者是一个指向对象或函数类型的指针或（左值）引用。我们可以通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数。

绑定到非类型整型参数的实参必须是一个常量表达式（可以在编译器求值）。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通（非 static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化。

在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。

> 非类型模板参数的模板实参必须是常量表达式。因为我们需要在编译器推导出模板实例。

当模板实例化时，非类型参数被一个用户提供的值。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。

例如：

``` c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return strcmp(p1, p2);
}

int main()
{
    // 老生常谈的字符串字面值常量的空字符
    cout << compare<3, 4>("hi", "dog") << endl;
    // 编译器自动推断
    cout << compare("hi", "dog") << endl;
    return 0;
}
```

### 2. 模板编译

当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。这一特性影响了模板中的错误检测，即大多数编译错误在实例化期间报告：
``` c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return "hello"; // 没有实例化该模板,编译通过
}

int f()
{
    return "hello";// return value type does not match the function type
}
```

对于模板，编译器会在三个阶段报告错误：

1. 编译模板本身时：此时编译器只是进行语法检查，例如忘记分号或者变量名拼错等。
2. 编译器遇到模板使用时：检查实参数目是否正确，参数类型是否匹配。
3. 模板实例化时：类型相关的错误。

另外，与普通函数和普通类成员函数的声明和定义分离（分别放在头文件和源文件中）不同，为了生成一个模板的实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码相比，模板的头文件通常既包含声明也包括定义。例如：

``` C++
// header.h
template<typename T>
T ret(T x);

// source.cpp
template<typename T>
T ret(T x)
{
    return x;
}

// main.cpp
template<typename T>
T ret(T);

int main()
{
    cout << ret<int>(10) << endl;
    return 0;
}
```

编译器会报错找不到 `ret` 这个函数的定义：

``` shell
/usr/bin/ld: /tmp/cc2BGbdB.o: in function `main':
/home/jyyyyx/cpp/main.cpp:10:(.text+0xd8): undefined reference to `int ret<int>(int)'
collect2: error: ld returned 1 exit status
```

这是因为如果声明和定义分离，那么只有在链接阶段才能找到定义。但对于模板来说，我们需要在编译阶段就找到相应的定义来生成实例代码。

### 3. 函数模板

对于函数模板，编译器能自动推导模板参数的值：

``` c++
template<unsigned N, typename T>
unsigned get_size(T (&array)[N])
{
    return N;
}

int main()
{
    int a[] = {1, 2, 3};
    cout << get_size(a) << endl;
    return 0;
}
```

### 4. 类模板

**与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。**因此我们必须显式指定模板参数。

#### （1）类模板名

类模板的名字不是一个类型名。类模板用来实例化类型，而一个实例化的类型总是包含模板参数。例如 `template<typename T> class Foo;` ，Foo 不是一个类型，`Foo<T>` 是一个具体的类型。

类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。而不同类模板实例本质上是不同的类，因此在类外定义函数时，需要指定模板参数来区分不同的类模板实例：

``` C++
template<typename T>
class Foo {
public:
    void f();
};

template<typename T>
void Foo<T>::f()
{
    cout << "Foo::f" << endl;
}
```

对于一个成员函数，如果它没被用到，就无需定义。同样的，在模板中，如果一个成员函数没有被使用，则它不会被实例化。成员函数只有被用到时才进行实例化。通常要将声明和定义放在源文件中，否则实例化会报错。

当我们使用类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参：

``` c++
template<typename T>
class Foo {
public:
    Foo(T _val = T()) : val(_val) {}
    // 无需使用 Foo<T>&
    Foo& operator++() {
        ++ val;
        return *this;
    }
private:
    T val;
};
```

同样的，当我们在类外定义时，出现在类名之后的内容属于类模板自己的作用域：

``` c++
template<typename T>
class Foo {
public:
    Foo(T _val = T()) : val(_val) {}
    // 无需加 <T>
    Foo operator++(int);
    private:
    T val;
};

template<typename T>
// 返回类型需要加 <T>
Foo<T> Foo<T>::operator++(int)
{
    // 无需加 <T>
    Foo tmp = *this;
    ++ this->val;
    return tmp;
}
```

#### （2）友元

当一个类包含一个友元声明时，类与友元各自是否是模板是模板是相互无关的。

如果一个类模板包含一个非模板友元，则友元被授予可以访问所有模板实例。如果友元自身是模板，类可以授予给所有友元模板实例，也可以只授予给特定实例。

通过分析模板的实例化其实能很简单的分析出来。

通常来说，友元应该是一个类或一个函数，但实际上与内置类型的友好关系是允许的，这方便我们将模板参数作为自己的友元：
``` c++
template<typename T>
class Foo {
public:
    // 将模板类型参数声明为友元
    friend T;
};
```

#### （3）模板类型别名

简化模板类型参数：

``` c++
template<typename T>
using twin = pair<T, T>;

twin<int> p;
```

固定一个或多个模板参数：

``` c++
template<typename T>
using pint = pair<T, int>;

pint<string> p;
```

#### （4）static成员

当我们在类模板中定义了 static 成员时，每个类模板实例都有自己的 static 成员实例。例如：
``` c++
template<typename T>
class Foo {
public:
    Foo() { ++ val; }
    static std::size_t count();
private:
    static int val;
};

// 在定义类成员时需要加上模板类型
template<typename T>
int Foo<T>::val = 1;

template<typename T>
std::size_t Foo<T>::count()
{
    return val; 
}

int main()
{
    // Foo<int>和Foo<string>分别有他们自己的static成员
    Foo<int> f1, f2, f3;
    cout << Foo<int>::count() << endl;
    cout << f1.count() << ' ' << f2.count() << ' ' << f3.count() << endl;
    Foo<string> f4, f5;
    cout << Foo<string>::count() << endl;
    cout << f4.count() << ' ' << f5.count() << endl;
    // 4
    // 4 4 4
    // 3 
    // 3 3
    return 0;
}
```

### 5. 模板参数

#### （1）作用域

模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，直到声明或定义结束之前。与其它名字一样，模板参数名会隐藏外层作用域中声明的相同名字。

#### （2）使用类的类型成员

当我们使用作用域运算符（`::`）来访问类的静态成员和类型成员时，对于普通（非模板）代码，编译器掌握类的定义，因此它知道通过作用域运算符访问的名字是类型还是 static 成员。

但是对于模板代码就存在困难。例如，T 是一个模板类型参数，当编译器遇到类似 `T::mem` 这样的代码时，它不知道 mem 是一个类型成员还是一个 static 数据成员，直到实例化时才能知道。但是为了处理模板，编译器必须知道 mem 是否表示一个类型。例如：

``` C++
template<typename T>
class Bar {
public:
    void f() {
        T::PII * p;
    }
};
```

其中的 p ，编译器需要知道它到底是一个 PII 类型的指针，还是与一个名为 PII 的静态变量的乘积。

<font color=blue>默认情况下，C++ 语言假定通过作用域运算符访问的名字不是类型。</font>因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过关键字 typename 来实现这一点：

``` c++
template<typename T>
class Bar {
public:
    void f() {
        typename T::PII *p;
    }
};
```

> 注意不能使用 class

#### （3）默认模板参数

和普通函数的参数一样，我们可以为函数或类的模板参数提供默认值。实际上 STL 就大量为模板实参提供默认值。提供默认值的规则与普通函数一样，不再赘述。

``` c++
// cmp有一个默认模板实参 less<T>
// 和一个默认函数实参 F()
template<typename T, typename F = less<T>>
bool cmp(const T &a, const T &b, F f = F())
{
    return f(a, b);
}

int main()
{
    cout << cmp(1, 2) << endl;
    cout << cmp<int, greater<int>>(1, 2) << endl;
    return 0;
}
```

由于类模板无法推导模板参数，因此我们必须显式指定模板参数。不过当所有模板参数都有默认值时，只需要提供一个空的尖括号即可：

``` c++
template<typename T = int>
class Foo {};
Foo<> f;
```

### 6. 成员模板

#### （1）成员模板不能是虚函数

#### （2）非模板类的成员模板

``` C++
class DebugDelete {
public:
    DebugDelete(std::ostream &_os = std::cerr) : os(_os) {}
    
    template<typename T>
    void operator()(T *p) const {
        os << "deleting unique_ptr" << std::endl;
        delete p;
    }
private:
    std::ostream &os;
};

int main()
{
    unique_ptr<int, DebugDelete> p(new int(10), DebugDelete());
    return 0;
}
```

#### （3）模板类的成员模板

``` c++
template<typename T>
class Vector {
public:
    // 模板成员函数
    template<typename It>
    Vector(It b, It e) : data(b, e) {} 
    size_t size() const { return data.size(); }
    T& operator[](size_t i) { return data[i]; }
private:
    vector<T> data;
};

int main()
{
    vector<int> a{1, 2, 3, 4, 5};
    Vector<int> v(a.begin(), a.end());
    for(size_t i = 0; i < v.size(); i ++ )
        cout << v[i] << endl;
    return 0;
}
```

与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。

``` C++
template<typename T>
class Foo {
public:
    template<typename U>
    U func(U x);
};

// 在类外定义成员函数
template<typename T>
template<typename U>
U Foo<T>::func(U x)
{
    return x;
}

int main()
{
    Foo<int> f;
    cout << f.func(10) << endl;
    cout << f.func(3.14) << endl;
    cout << f.func("String") << endl;
    return 0;
}
```

### 7. 控制模板实例化

模板被使用时才会实例化意味着相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。

在大系统中，在多个文件中实例化相同模板的额外开销可能非常大。在新标准中，我们可以通过<font color=blue>显式实例化（explicit instantiation）</font>。一个显式实例化有如下形式：

``` c++
extern template declaration;	// instantiation declare
template declaration;			// instantiation define
```

declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如：
``` c++
extern template class Foo<int>;					// declare
template int compare(const int&, const int&);	// define
```

当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。因为将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，只能有一个定义，但可以有多个 extern 声明。

由于编译器在使用一个模板时自动对其实例化，因为 extern 声明必须出现在任何使用此实例化版本的代码之前。

> 实例化定义不能放在头文件中，不然被如果多个源文件引入就会导致重复定义错误。

一个类模板的实例化定义会实例化该模板的所有成员（包括构造函数、析构函数、内敛的成员函数和友元函数等）。这意味着，编译器将生成这些成员函数对应的代码。

因此，与处理类模板的普通实例化不同（只实例化使用到的成员函数），编译器会实例化该类的所有成员。即使我们不使用某个成员，他也会被实例化。因此，**我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。**

例如，NoDefault 是一个没有默认构造函数的类型，我们不可以用它来显示实例化 `vector<NoDefault>`。因为编译器需要实例化 vector 的构造函数，尽管我们可能并不用到它，由于该类型没有构造函数，因此会编译失败：

``` c++
class NoDefault {
public:
    NoDefault() = delete;
};

template class vector<NoDefault>;   // 编译错误
vector<NoDefault> v;    // 编译通过
```

### 8. 引用折叠

在 C++ 中我们是不能定义“引用的引用”的，但是如果我们间接创建（如类型别名，模板参数）了一个“引用的引用”，则这些引用形成了“折叠”。

C++ 中的引用折叠（reference collapsing）规则，是当多层引用组合在一起时，编译器应用的一套规则，用来决定最终的引用类型。

引用折叠规则的基本原则是：

* **左值引用优先于右值引用。**即：如果有一个左值引用参与折叠，那么最终结果一定是左值引用。

具体规则如下：

| 第一层引用类型 | 第二层引用类型 | 折叠结果 |
| -------------- | -------------- | -------- |
| T&             | &              | T&       |
| T&             | &&             | T&       |
| T&&            | &              | T&       |
| T&&            | &&             | T&&      |

从表格中可以看出，只有在 `T&& &&` 的情况下，结果才是 `T&&`，其它情况下都是 `T&`。

### 9. 模板实参推导

对于一个函数模板，当我们调用它时，编译器会利用调用中的函数来推断其模板参数，从而实例化出与我们的函数调用最匹配的版本，这个过程就称为模板实参推导。

#### （1）类型转换与模板参数类型

如果一个函数形参的类型使用了模板类型参数，那么它采用特殊的初始化规则。只有很有限的几种类型转换会自动地应用于这些实参。**编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。**

和往常一样，顶层 const 无论是在形参还是在实参中，都会被忽略（顶层const 在按值传递时无意义）。在其它类型转换中，能在调用中应用于函数模板的包括如下两项。

* const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参。（底层 const）
* 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针，一个函数实参可以转换为一个该函数类型的指针。

其他类型转换，如算数类型转换、派生类向基类的类型转换以及用户自定义的转换，都不能应用于函数模板。

看下面的例子：

``` c++
template<typename T>
void fobj(T a, T b) {}

template<typename T>
void fref(const T &a, const T &b) {}

int main()
{
    int a[3], b[4], c[4];
    double d[4];
    fobj(a, b);
    fobj(b, d); // type not match
    fref(a, b); // size not match
    fref(b, c);
    fref(c, d); // type not match
    return 0;
}
```

在函数 `fobj` 中，数组转换为指针；在 `fref` 中，数组不会进行隐式类型转换，都作为数组本身传递，此时数组大小也是数组类型的一部分。

另一个标准库的例子就是 `max` 和 `min` 函数，以 `max` 为例，当我们通过 `max` 比较两个对象时，这两个对象的类型必须“相同”，例如：

``` C++
cout << max(3, 3.14) << endl; // no instance of overloaded function "max" matches the argument list
```

上面的 `max` 函数调用是不合法的，因为 `max` 只接受一个模板参数，但我们传入的两个函数调用实参的类型却不相同，因此编译器无法为我们生成一个模板实例，尽管 int 可以转换为 double。我们有两种解决方法：

``` c++
// 保证实参类型相同
cout << max((double)3, 3.14) << endl; 
// 显式指定模板参数
cout << max<double>(3, 3.14) << endl;
```

#### （2）函数模板显式实参

在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。

##### 指定显式模板实参

假定我们有一个求和的函数 `sum`，我们将返回类型设置为模板参数，以允许用户指定结果的类型。这样，用户就可以选择合适的精度。

``` C++
template<typename RT, typename T1, typename T2>
RT sum(T1 a, T2 b) { return a + b; }
```

但是在这个例子中，没有任何函数实参的类型可用来推断 T1 的类型。因此，每次调用 `sum` 都必须为 RT 提供一个显式模板实参。

> 不要误认为编译器会自动通过 `a+b` 的结果来推断返回类型。最简单的情况，如果 a 和 b 的类型不同呢？

同一般的“提供默认值”一样，我们只能自左向右为模板参数提供显式实参，因此，如果这里的 RT 出现在 T1 和 T2 之后，那么我们只能为 T1 和 T2 提供了显式实参之后才能为 RT 提供显式实参。

``` C++
template<typename RT, typename T1, typename T2>
RT sum(T1 a, T2 b) { return a + b; }

int main()
{
    cout << sum<int>(1.5, 2.7) << endl;    // 4
    cout << sum<double>(1.5, 2.7) << endl; // 4.2
    return 0;
}
```

#### （3）尾置返回类型与类型转换模板

当我们希望用户确定返回类型时，用显式模板实参表示模板函数的返回类型是很有效的。但在其他情况下（例如用户不希望自己确定返回类型），要求显式指定模板实参会给用户增添额外负担，而且不会带来什么好处。例如，我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个元素的引用：

``` C++
template<typename It>
??? &func(It beg, It end)
{
    // process
    return *beg; // return reference
}
```

我们并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型：

``` C++
vector<int> v{1, 2, 3};
auto &it = func(v.begin(), v.end()); // func应该返回int&
```

在上面的例子中，我们知道函数应该返回 `*beg`，并且我们知道可以用 `decltype(*beg)` 来获取此表达式的类型。但是，在编译器遇到函数的参数列表 `(It beg, It end)` 之前，`beg` 都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回类型出现在函数列表之后，所以它可以使用函数的参数。

``` c++
template<typename It>
auto func(It beg, It end) -> decltype(*beg)
{
    auto start = beg;
    while(beg != end) {
        cout << *beg << ' ';
        ++ beg;
    }
    cout << endl;
    return *start;
}

int main()
{
    vector<int> v{1, 2, 3};
    auto &it = func(v.begin(), v.end());
    it = 10;
    cout << v[0] << endl;   // 10
    return 0;
}
```

通过结合使用尾置返回和 `decltype()`，我们就可以让编译器推导出返回类型。

##### 进行类型转换的标准库模板类

有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似 `func` 的函数，但返回一个元素的值而非引用。

但是在编写这个函数的过程中，我们面临一个问题：对于传递的参数类型，我们几乎一无所知。在此函数中，我们知道唯一可以使用的操作是迭代器操作，而所有的迭代器操作都不会生成元素，只能生成元素的引用。

为了获得元素类型，我们可以使用标准库的**类型转换模板（type transformation template）**。这些模板定义在头文件 **`type_traits`** 中。这个头文件中的类通常用于所谓的模板元变成血祭。但是，类型转换模板在普通编程中也很有用。

在本例中，我们可以使用 `remove_reference` 来获得元素类型。`remove_reference` 模板有一个模板类型参数和一个名为 `type` 的公开类型成员。如果我们用一个引用类型实例化 `remove_reference`，则 `type` 将表示被引用的类型。例如，如果我们实例化 `remove_reference<int&>` ，则 `type` 成员将是 `int`。更一般的，给定一个迭代器 `beg`：

```C++
remove_reference<decltype(*beg)>::type;
```

将获得 `beg` 引用的元素的类型。

通过组合 `remove_reference`、尾置返回及 `decltype`，我们就可以在函数中返回元素值的拷贝：

``` c++
template<typename It>
auto func(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    auto start = beg;
    while(beg != end) {
        cout << *beg << ' ';
        ++ beg;
    }
    cout << endl;
    return *start;
}

int main()
{
    vector<int> v{1, 2, 3};
    auto it = func(v.begin(), v.end());
    it = 10;
    cout << v[0] << endl;   // 1
    return 0;
}
```

> 注意 type 是一个类型成员，因此：
>
> 1. 访问它需要通过作用域运算符 `::`
> 2. 不需要加 `()`

##### 标准类型转换模板

| Mod<T>,mod           | Description    | t               | mod<t>::type |
| -------------------- | -------------- | --------------- | ------------ |
| remove_reference     | 去引用         | X&,X&&          | X            |
|                      |                | 其他            | T            |
| add_const            | 添加顶层const  | X&,const X,函数 | T            |
|                      |                | 其他            | const T      |
| add_lvalue_reference | 转换成左值引用 | X&              | X&           |
|                      |                | X&&             | X&           |
|                      |                | 其他            | T&           |
| add_rvalue_reference | 转换成右值引用 | X&,X&&          | X&           |
|                      |                | 其他            | T&&          |
|                      |                |                 |              |
| remove_pointer       |                | X\*             | X            |
|                      |                | 其它            | T            |
| add_pointer          |                | X&,X&&          | X*           |
|                      |                | 其它            | T*           |
| make_signed          |                | unsigned X      | X            |
|                      |                | 其它            | T            |
| make_unsigned        |                | signed X        | unsigned X   |
|                      |                | 其它            | T            |
| remove_extent        |                | X\[n\]          | X            |
|                      |                | 其它            | T            |
| remove_all_extents   |                | X\[n1\]\[n2\]…  | X            |
|                      |                | 否则            | T            |



说明：

1. C++14 提供了一种更方便的获取 `::type` 的方法，那就是在模板名后面加上 `_t`。例如：`remove_reference<int&>::type` 可以写成 `remove_reference_t<int&>`。
2.  **`add_const`**：C++ 中，`const` 限定符应用于引用类型时，它实际上会作用域引用所指向的第对象（底层 `const`）。而我们这里的 const 实际上是添加顶层 `const`，因此对于 `X&`，依然返回 `X&` 而不是 `const X&`。同样的，对于指针来说，`add_const` 会将指针修饰为常量指针而不是“指向常量”的指针。
3. **`add_rvalue_reference`**：对于转换成左值引用，无论是左值还是右值都会变成左值；但是对于转换成右值引用来说，左值依然是左值，右值却变成了非引用类型；以上结果就是因为 C++ 的<font color=blue>引用折叠</font>规则。

#### （4）函数指针与实参推断

当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。

例如：

``` c++
template<typename T>
int compare(const T &lhs, const T &rhs)
{
    return lhs < rhs;
}

using fptr = int(*)(const int&, const int&);

int main()
{
    fptr fp1 = compare; 
    // 这里compare的实参会被推导为int
    cout << fp1(1, 2) << endl;
    return 0;
}
```

#### （5）函数实参推断和引用

##### 从[左值引用函数参数]推断类型

当一个函数参数是模板类型的一个[普通左值引用]时（即，形如 `T&`），绑定规则告诉我们，只能传递给它一个左值。实参可以是 const 类型，也可以不是。如果实参是 const 的，则 T 将被推断为 const 类型。

如果一个函数参数的类型是 `const T&`，正常的绑定规则告诉我们可以传递给它任何类型的实参。当函数参数本身是 const 时，T 的类型推断结果不会是一个 const 类型。

##### 从[右值引用函数参数]推断类型

如果一个函数参数是一个右值引用（即，形如 `T&&` 时），正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通左值引用函数参数的推断过程。推断出的 T 的类型是该**右值实参的类型**。

##### 引用折叠和[右值引用参数]

对于一个接受[右值引用函数参数]的模板函数来说，我们可能认为下面的调用是不合法的：

``` C++
template<typename T>
void f(T &&x)
{
    x = 1024;
}

int main()
{
    int x = 10;
    f(x);	// 通过一个左值来绑定右值
    cout << x << endl;
    return 0;
}
```

即我们是不能直接将左值绑定到右值上的。但是，C++ 语言在正常绑定规则之外定义了两个额外规则，允许这种绑定。这两个额外规则是 move 这种标准库设施正确工作的基础：

1. <font color=blue>**右值引用的特殊类型推断规则：**</font>第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值传递给函数的右值引用参数，并且**此右值指向模板类型参数**（如 `T&&`）时，编译器推断模板类型参数为实参的左值引用类型。因此，这里我们调用 `f(x)` 时，编译器推断 T 的类型为 `int&`，而非 `int`。
2. <font color=blue>**引用折叠规则：**</font>T 的类型被推断为 `T&` 意味着 `f` 的函数参数类型是一个类型为 `int&` 的右值引用，即我们间接的创建了一个“引用的引用”。在 C++ 中引用的引用是不合法的，在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建了一个“引用的引用”，引用会进行折叠。

通过右值引用的特殊类型推断规则和引用折叠规则，我们就能实现<font color=blue>**万能引用**。</font>

##### 编写接受[右值引用函数参数]的模板函数

模板参数可以推断为一个引用了类型，这一特性对模板内的代码可能有令人惊讶的影响：

``` c++
template<typename T>
void func(T&& val)
{
    T t = val; // t是val的拷贝还是绑定到val的引用呢？
    t = 1024;  // 仅仅修改t还是同时修改t和val呢？
}
```

当我们对一个右值调用 `func` 时，T 为 int，此时 t 的类型为 int，它通过 val 拷贝初始化；当我们对一个左值调用 `func` 时，T 是 int&，此时 t 的类型时 int&，他是一个绑定到 val 的引用。

``` C++
func(1);
int x = 10;
func(x);
cout << x << endl; //1024
```

可以发现，对于代码中的一条初始化语句，它的行为可以会因为传入的实参类型而改变，这就导致代码的编写比较困难。

在实际中，右值引用通常用于两种情况：

1. 模板转发
2. 模板重载：

``` C++
template<typename T> void func(T&& val);
template<typename T> void func(const T& val);
```

#### （6）理解 std::move

``` c++
template<typename T>
remove_reference_t<T>&& Move(T &&t)
{
    return static_cast<remove_reference_t<T>&&>(t);
}
```

##### 从一个左值 static\_cast 到一个右值引用是允许的

这里又有一条针对右值引用的特许规则：虽然不能隐式的将一个左值转换为右值引用，但我们可以用 static\_cast 显式的将一个左值转换为一个右值引用。

1. 在模板编程中，`static_cast<T&&>` 可以确保我们在**完美转发**（perfect forwarding）中正确地保持参数的左右值属性。
2. 当我们调用一个函数需要**移动对象资源**时，比如将对象传递给一个构造函数或赋值操作，`static_cast<Type&&>` 可以将一个左值转换为右值引用，使得函数能通过移动语义来处理这个对象，从而避免不必要的拷贝。

在 C++ 中，**不能直接将一个右值转换为左值引用**，因为右值没有持久的存储空间，无法为左值引用提供有效的绑定目标。

#### （7）转发

某些函数需要将其一个或多个实参连同类型不变的转发给其它函数。在此情况下，我们需要保持被转发实参的所有性质，包括：

1. 实参类型是否是 const
2. 实参是左值还是右值

看下面的例子，我们编写一个模板函数 `flip`，它接受一个可调用表达式和两个参数。`flip` 将调用这个可调用表达式并将接受的两个参数传递给它：

``` c++
void f(int v1, int &v2)
{
    ++ v2;
}

// flip的顶层const和引用信息丢失了
template<typename F, typename T1, typename T2>
void flip(F f, T1 t1, T2 t2)
{
    f(t1, t2);
}

int main()
{   
    int x = 1, y = 2;
    flip(f, x, y);   
    cout << x << ' ' << y << endl; //1 2
    return 0;
}
```

在上面的代码中，我们的本意是通过 `f` 修改 y 的值，但因为在将 y 传递给 flip 时丢失了引用信息，导致实际上修改的是 `flip` 的 t2。

##### 定义能保持类型信息的函数参数

通过将一个函数参数定义为一个指向模板参数类型的右值引用，我们可以保持其对应参数的所有类型信息（包括左右值和 const）。

1. 通过引用折叠可以保存左值和右值信息。
2. 通过引用可以保存 const 信息，引用的 const 是底层的。

我们修改 flip 函数如下：

``` c++
void f(int v1, int &v2)
{
    ++ v2;
}

template<typename F, typename T1, typename T2>
void flip(F f, T1&& t1, T2&& t2)
{
    f(t1, t2);
}

int main()
{   
    int x = 1, y = 2;
    flip(f, x, y);   
    cout << x << ' ' << y << endl;  // 1 3
    return 0;
}
```

但这个版本的 flip 也只是解决的一半问题。它对于接受一个左值引用的函数工作的很好，但不能用于接受右值引用参数的函数。例如：

``` C++
void g(int&& v1, int &v2)
{
    cout << v1 << ' ' << v2 << endl;
}

template<typename F, typename T1, typename T2>
void flip(F f, T1&& t1, T2&& t2)
{
    f(t1, t2); // error: cannot bind rvalue reference of type ‘int&&’ to lvalue of type ‘int 
}

int main()
{   
    int x = 1;
    flip(g, 42, x);   
    return 0;
}
```

在上面的代码中，我们传递给 t1 一个临时对象 42，t1 的类型被推导为一个右值引用。但是如果我们把 t1 传递给函数 g 的 v1，会报错：我们将一个左值传递给右值引用。这是因为，尽管 t1 的类型是右值引用，但 t1 本身和任何变量一样，作为表达式本身它都是一个左值。因此这里 t1 实际上是作为一个左值传递给函数 g 的。

这一点下面的情况是一样的：

``` c++
int rf(const int &x) { cout << "lvalue" << endl; }
int rf(int &&x) { cout << "rvalue" << endl; }
int f(int x) { rf(x); }
int main()
{   
    f(11); // lvalue
    return 0;
}
```

<font color=blue>上面说的这一种无法处理右值引用的情况非常关键，理解好了这一点，才能理解我们为什么需要**“完美转发”（forward）**。</font>

##### 在调用中使用 std::forward 保持类型信息

我们可以使用一个名为 forward 的新标准库设施来传递 flip 的参数，它能保持原始参数的类型。类似 move，forward 定义在头文件 `utility` 中。与 move 不同的是，forward 必须通过<font color=blue>**显式模板实参**</font>来调用。**forward 返回该显示实参类型的<font color=blue>右值引用</font>。即，forward\<T\> 的返回类型是 `T&&`，即万能引用**。通过万能引用，forward 可以保证转发后的类型依然是 T 本来的类型。

> forward 为什么要显式接受模板参数 T 的原因也很简单，因为 T 保存的就是模板推导出的调用者传递的实参的类型。

通常情况下，我们使用 forward 传递那些定义为模板参数类型的右值引用，即，forward 依赖万能引用实现，同时也“配合万能引用”使用。当万能引用接受一个左值时，forward 转发一个左值；当万能引用接受一个右值时，forward 转发一个右值：

``` c++
void f(const int& x) {cout<<"lvalue"<<endl;}
void f(int&& x) {cout<<"rvalue"<<endl;}

template<typename T>
void warp(T&& arg) // 万能引用
{
    f(std::forward<T>(arg));    // 完美转发
}

int main()
{   
    int x = 1;
    warp(1); // rvalie
    warp(x); // lvalue
    return 0;
}
```

你可能会问，正如我们前面所说的，forward 本质上是返回 T 的类型，那么我们直接通过 static\_cast 将元素类型显式转换为 T 不就好了：`static_cast<T>(arg);` 当然可以！不过此时，如果 T 的类型是 int，注意不是 `int&&`，static\_cast 就会丧失 `T&&` 的移动语义。这就导致，原本使用移动进行的操作，现在不得不依赖于拷贝，从而产生不必要的拷贝操作。例如：

``` c++
struct Foo {
    Foo(int _x) {};
    Foo(const Foo&x) {puts("copy ctor");}
    Foo(Foo&&x) {puts("move ctor");}
};

void f(Foo x) {}

template<typename T>
void warp(T&& arg) // 万能引用
{
    f(std::forward<T>(arg));    // move ctor
    f(static_cast<T>(arg));     // copy ctor
}
```

> 一言以蔽之，那就是 `static_cast<T>(arg)` 会丢失右值引用属性。

那你可以又问，既然如此，我们直接让 `T` 变成 `T&&`，即 `static_cast<T&&>(arg);` 不就好了？当然好了！因为这就是 std::forward 的实现：

``` c++
template<typename T>
T&& forward(remove_reference_t<T>& arg) noexcept
{
    return static_cast<T&&>(arg);
}

template<typename T>
T&& forward(remove_reference_t<T>&& arg) noexcept
{
    static_assert(!std::is_lvalue_reference<T>::value,
          "std::forward must not be used to convert an rvalue to an lvalue");
    return static_cast<T&&>(arg);
}
```

你可能又又又要问了，为什么这里要为 forward 设计两个版本，分别接受一个左值引用和一个右值引用。我们直接用下面的形式不行吗？

``` C++
template<typename T>
// 直接使用万能引用，既能接受左值，又能接受右值
T&& forward(T&& arg) noexcept
{
    return static_cast<T&&>(arg);
}
```

那这又回到最初的问题了，**对于某个函数中的参数来说，它可能是一个右值引用，但当它作为表达式时，它是一个左值。**因此说如果我们这里使用万能引用的话，forward 的 T 总是被解释为 `int &`，此时如果我们显式指定的 T 为 `int &&`，就会冲突。

所以这里 forward 的实现直接让变量 arg 的类型与模板参数 T 无关，在第一个重载版本中，arg 的类型永远是 `T&`；在第二个重载版本中，arg 的类型永远是 `T&&`。也就是说，这个的模板参数仅仅是用来保存“类型信息”的，它并不用来决定 forward 的参数 arg 的类型。就比如上面的 warp 函数，`std::forward<T>` 的 T 仅仅是用来保存 `T&& arg` 中 T 的类型信息：到底是左值还是右值。

那问题又来了，既然表达式作为变量时是左值，那么我们只需要一个接受 `T&` 的版本就好了啊，为什么还需要一个接受右值的版本呢？事实就是，有一些情况，参数还真会变成右值。

看cppreference上的例子:

> This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.
>
> For example, if a wrapper does not just forward its argument, but calls a member function on the argument, and forwards its result:

``` c++
template<typename T>
T&& Forward(remove_reference_t<T>& arg) noexcept
{
    puts("lvalue forward");
    return static_cast<T&&>(arg);
}

template<typename T>
T&& Forward(remove_reference_t<T>&& arg) noexcept
{
    puts("rvalue forward");
    static_assert(!std::is_lvalue_reference<T>::value,
          "std::forward must not be used to convert an rvalue to an lvalue");
    return static_cast<T&&>(arg);
}

struct Foo {
    Foo(int&& _val) {puts("move");}
    Foo(const int& _val) {puts("copy");}
};

template<class T>
void wrapper(T&& arg)
{
    Foo(
        Forward<decltype(Forward<T>(arg).get())>
        (Forward<T>(arg).get()) // 这里的Forward<T>(arg)永远调用左值的重载版本
                                // 但是对其返回值调用get()成员返回的对象可能是int,也可能是int&
                                // 因此最外围的Forward可能调用左值版本,也可能调用右值版本
    );
}

struct Arg {
    int i = 1;
    int  get() && { puts("rget"); return i; } // call to this overload is rvalue
    int& get() &  { puts("lget"); return i; } // call to this overload is lvalue
};

int main()
{   
    Arg a;
    wrapper(Arg()); // move
    wrapper(a);     // copy
    return 0;
}
// lvalue forward
// rget
// rvalue forward
// move
// lvalue forward
// lget
// lvalue forward
// copy
```

也就是说，如果不直接转发arg，而是转发arg的成员函数的返回值，那么就需要使用第二种重载。在上面的例子中，`decltype(forward<T>(arg).get())`会被推导为`int`, `forward<T>(arg)`会返回右值，`forward<T>(arg).get()`会调用函数`int get() && { return i; }`返回右值，完美匹配第二种模板。

这就是第二种模板存在的意义。虽然比较少见，但世界那么大，总有人会用到的吧:-)

[REFERENCE HERE😀](https://www.matsjiang.com/article/12)

### 10. 重载与模板

函数模板可以被[另外一个模板]或[一个普通非模板函数]重载。与往常一样，重载函数必须有不同数量或类型的参数。

> 注意是另一个“模板”而不是另一个“模板实例”。

如果涉及模板函数，则函数匹配规则会在以下几方面收到影响：

* 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。

* 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。

* 与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的

* 与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数，但是，如果有多个函数提供同样好的匹配，则：

  （1）如果同样好的函数中只有一个是非模板函数，则选择此函数。

  （2）如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。

  （3）否则，此函数调用有歧义

> 总而言之，当模板函数与普通函数并存，且它们的调用“一样好”时，编译器会优先调用**“最特例化”**的。
>
> * 对于普通函数而言，我们可以将其理解为比“全特化”还好特化的模板，因此它不仅特化了所有参数，甚至把模板都特化“没了”。
> * 对于 `T` 和 `T*` 来说，显然 `T*` 更特例化，因为 `T` 可以表示任何类型，而 `T*` 只能表示指针，

例如：

``` c++
template<typename A, typename B>
void f(A a, B b){puts("AB");}
template<typename B>void f(int a, B b){puts("IB");}
template<>void f(int a, int b){puts("[tmplate]II");}
void f(int a, int b) {puts("II");}
void f(int a, double b){puts("ID");}

int main()
{   
    f(1, 2); // II
    f(3.14, 3.14); // AB
    f(1, "hello"); // IB
    return 0;
}
```

下面是一个稍微有点误导性的匹配：

``` c++
template<typename T>
void f(const T *p)
{
    puts("const T*");
}

template<typename T>
void f(T x)
{
    puts("T");
}

int main()
{   
    int *p = new int(10);
    f(p);
    return 0;
}
```

实际上，``f(p)`` 匹配的是第二个版本。我们现在来分析一下：p 本身的类型是 `int *` 。对于第一个版本，参数类型推导为 `int*`；对于第二个版本参数类型被推导为 `const int*`。而在 C++ 中，指针的常量性会影响匹配优先级。

##### 缺少声明可能导致程序行为异常

通常，如果使用了一个忘记声明的函数，代码将编译失败。但在涉及模板函数时，编译器可以从模板实例化出与调用匹配的版本。

因此，当涉及函数模板的重载时：在定义任何函数之前，记得声明所有重载的函数版本。这样，就不必担心由于未遇到我们希望调用的函数而实例化一个并非你所需的版本。

注意，如果声明位于调用函数之后，也属于“缺少声明”的情况，因为在调用函数之后的声明对调用函数而言依然是不可见的。

### 11. 可变模板参数

一个可变参数模板就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为**参数包**。存在两种参数包：

1. 模板参数包：表示零个或多个模板参数，形式为 `typename...` 或 `class...`。
2. 函数参数包：表示零个或多个函数参数，形式为在函数参数类型名后面跟一个省略号。

例如：

``` c++
template<typename T, typename... Args> // Args为模板参数包
void foo(T &t, Args&... args);         // args为函数参数包
```

#### （1）sizeof… 运算符

当我们需要知道包中有多少元素时，可以使用 sizeof… 运算符。与 sizeof 运算符相同，sizeof… 运算符也返回一个常量表达式：

``` c++
template<typename T, typename... Args>
void foo(const T &t, const Args&... args)
{
    cout << sizeof...(Args) << endl; // 类型参数的数目
    cout << sizeof...(args) << endl; // 函数参数的数目
}

int main()
{   
    foo(1, 3.14, "hello");
    return 0;
}
```

#### （2）函数模板与类模板中的应用

我们前面提到过使用 `initializer_list<T>` 来实现可变参数，但是它只能接受相同类型的可变参数。而可变模板参数可以接受不同类型的参数。

 使用可变模板参数时，通常通过递归的形式处理可变参数。与普通递归一样，这里的递归也需要有终点，因此我们通常定义一个不包含可变模板参数的模板特例化作为递归的终点。

``` c++
/* 可变参数函数模板 */
template<typename T>
void print(const T &t) // 递归终点
{   
    cout << t;
}
template<typename T, typename... Args>
void print(const T& t, const Args&... args)
{
    cout << t << ' ';
    print(args...);
}

int main()
{   
    print(1, 3.14, "hello");
    return 0;
}
```

#### （3）包拓展

先来看一个可变模板参数的应用：

``` c++
template<typename T, typename... Args>
void print(const T& t, const Args&... args) // 拓展Args
{
    cout << t << ' ';
    print(args...);	// 拓展args
}
```

其中，`typename...` 我们称之为[模板参数包]，`Args&...` 称之为[函数参数包]。那么，print 中的 `args...` 又是什么用法呢？我们之前好像从没在意过！

对于一个参数包（模板参数包/函数参数包），除了获取其大小外，我们能对它做的唯一的事情就是**拓展（expand）**它。当拓展一个包时，我们还要提供用于每个拓展元素的**模式（pattern）**。<font color=blue>**拓展一个包**就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在**模式右边放一个省略号**（…）来触发拓展操作。</font>因此上面代码中的 `args...` 就是拓展包操作，我们一直在用却从没深入理解过它。对于该拓展，我们没有对它应用任何样式，实际上写为 `(args)...` 可能更好理解。

实际上，对于函数参数包 args，可以将它看作是模板参数包 Args 的拓展，模式为 `const &`，即将模式 `const &` 应用到 Args 中的每个元素。因此，此模式的拓展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如 `const T&`。

例如，对于一个调用 `print(1,3.14,"hello");`  经过拓展之后的模板相当于：

``` c++
void print(const int &t, const double& arg1, 
           const string &arg2) {
    cout << t << ' ';
    print(arg1, arg2);
}
```

正如我们所提到的，上面函数体中的 `print(args...);` 对函数参数包的模式相当于什么也不做，实际上，我们可以为其指定一些模式：

``` C++
template<typename T>
const T& check(const T &arg)
{
    cout << arg << endl;
    return arg;
}

template<typename T>
void print(const T &t) 
{   
    cout << t << endl;
}

template<typename T, typename... Args>
void print(const T& t, const Args&... args)
{
    cout << t << endl;
    print(check(args)...);
}
```

其中 check 就是我们为 args 指定的模式，print 相当于：

``` c++
print(check(arg1), check(arg2));
```

因此，check 的返回值不能为 void，因为我们需要在 print 中打印 check(arg1) 和 check(arg2) 的值。

#### （4）转发参数包

在新标准下，我们可以组合使用可变参数模板与 forward 机制编写函数，实现将其[实参不变]地传递给其它函数。

标准库的 emplace_back 就是一个很好的例子。emplace_back 直接在数据内存处调用构造函数，而构造函数可能有多个，其参数个数和类型不同，因此使用可变参数模板是个很好的例子。

另外在将参数从 emplace_back 传递给构造函数时，我们需要确保参数的类型信息不变（左值/右值），同之前讲到的，emplace_back 的参数类型需要是右值引用（保留左值和右值信息），传递参数时需要使用 forward（避免变量作为表达式时永远是左值）。

``` c++
class Foo {
public:
    template<typename... Args>
    void emplace_back(Args&&... args) // 模式为&&
    {
        // 分配内存
        alloc.construct(first_free++, 
        	std::forward<Args>(args)...); 
        	// 对args中的每个参数应用模式forward<Args>
    }
};
```

值得注意的是，对于语句 `std::forward<Args>(args)...` ，它不仅拓展了函数参数包 `args`，还拓展了模板参数包 `Args`。它相当于：

``` C++
std::forward<Args1>(args1), std::forward<Args2>(args2), ...
```

同理，`make_shared` 等函数也是同样的设计原理：

1. 接受参数包
2. 拓展并转发给 new 进行实际的内存分配

``` c++
template<typename T, typename... Args>
std::shared_ptr<T> make_shared(Args&&... args)
{
    return shared_ptr<T>(new T(std::forward<Args>(args)...));
}
```

### 12. 模板特例化

在某些情况下，通用模板的定义对特定类型是不合适的：通用定义可能编译失败或做的不正确。此时，我们可以定义函数或类模板的一个特例化版本。

一个模板特例化就是一个用户提供的模板实例，**它将一个或多个模板参数绑定到特定的类型或值上。**

特例化与重载和原模板是很好区分的，特例化一定会在函数名或类名后面加上 `<Types>`， 其中 Types 就是我们具体特化的类型。而重载则要求函数的参数个数或类型不同。

#### （1）函数模板特例化

当我们特例化一个函数模板时，必须为原模板中的<font color=blue>每个模板参数</font>都提供实参。为了指出我们正在实例化一个模板，应使用关键字 template 后跟一个空尖括号对。空尖括号指出我们将为原模板的所有模板参数提供实参：

``` c++
template<typename T1, typename T2>
void f(T1 a, T2 b) {}

template<> // 函数模板特例化
void f(int a, int b) {}
```

至于为什么函数模板不能偏特化，似乎不是因为语言实现不了，而是因为偏特化的功能可以通过函数的重载完成。

#### （2）函数重载与模板特例化

当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了自己的定义。重要的是：<font color=blue>一个特例化版本本质上是一个实例，而非函数名的一个重载版本。</font>因此，**特例化不影响函数匹配**，因为它本质上并没有产生新的函数版本（参数个数或参数类型不同），特例化影响的只是函数匹配到特定模板时会选择的“实例”。

> 一个模板就是一个生成特定类类型或函数的蓝图。生成特定类或函数的过程称为**“实例化”**。模板特例化就是通过我们指定的实例改变了模板对于特定类型所生成的特定类或函数，因此称为**“特例化”**。

#### （3）特例化版本的声明必须可见

如我们先前提到的一样，对于普通类和函数，声明丢失的情况很容易发现，因为编译器会编译错误。但是对于模板特例化的声明，编译器可以通过原模板产生代码，导致编译器调用的并非我们想要的函数，由于此时函数调用正常执行，但是调用了错误的函数，因此出现错误时很难排查。

#### （4）类模板特例化  

类模板特例化的一个典型例子就是 hash 模板：

``` c++
struct Foo {
    int val;
    string s;
    bool operator==(const Foo &rhs) const ;
};

namespace std {
    template<> struct hash<Foo> { // 类模板全特化
        typedef size_t result_type;
        typedef Foo augument_type;
        size_t operator()(const Foo &f) const {
            return hash<int>()(f.val) + hash<string>()(f.s);
        }
    };
}

// 这里的operator==必须在类外定义,否则不可见hash的定义
bool Foo::operator==(const Foo &rhs) const {
    return hash<Foo>()(*this) == hash<Foo>()(rhs);
}

int main()
{   
    unordered_set<Foo> s;
    s.insert({1,"a"});
    s.insert({2,"b"});
    s.insert({3,"c"});
    s.insert({2,"b"});

    for(auto &x : s) {
        cout << x.val << ' ' << x.s << endl;
    }
    return 0;                        
}
```

与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的特例化仍然是一个模板，因此使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。

部分特例化版本的模板参数列表是原始模板参数列表的一个子集（例如引用形式）或是一个特例化版本（指定了具体的类型）。

``` c++
template<typename T> struct Remove_reference {
    typedef T type;
};
template<typename T> struct Remove_reference<T&> {
    typedef T type;
};
template<typename T> struct Remove_reference<T&&> {
    typedef T type;
};
/*========================================*/
template<typename A, typename B>
struct Foo {
    Foo() {puts("AB");}
};
template<typename B>
struct Foo<int,B> {
    Foo() {puts("IB");}
};
template<>
struct Foo<int,int> {
    Foo() {puts("II");}
};

int main()
{   
    Foo<int,int> a;    // II
    Foo<int,double> b; // IB
    Foo<double,int> c; // AB
    return 0;
}
```

#####  类不能重载

现在，假设我们想借助可编目版参数实现一个 tuple，初步框架如下：

``` c++
template<typename T> // 递归终点
class Tuple {};

template<typename T, typename... Args>
class Tuple : public Tuple<Args...> {};//  error: redeclared with 2 template parameters
```

在这里，我们初步是想通过递归定义的方式实现 tuple，但是编译器却告诉我们这两个 tuple 重定义错误了。这是因为对于这两个 tuple 来说，它们的关系是 “重载” 而不是 “特例” 的关系。而对于类来说，是不存在重载的，因此这里编译器报告重定义错误。正确的写法是应该将第一个 Tuple 写为特例化的形式，即在类名的后面加上尖括号：

``` c++
template<typename T> // 递归终点
class Tuple<T>/*特例*/ {}; // ‘Tuple’ is not a class template

template<typename T, typename... Args>
class Tuple : public Tuple<Args...> {};
```

但是编译器依然报告错误，它说第一个 Tuple 不是一个类模板。这是因为第一个模板作为第二个模板的“特例”，它出现在第二个模板之前了，因此这里需要更换一下两个模板之间的声明顺序：

``` c++
template<typename T, typename... Args>
class Tuple : public Tuple<Args...> {};

template<typename T> // 递归终点
class Tuple<T>/*特例*/ {};
```

#### （5）成员函数特例化

我们也可以只特例化特定成员函数而不是特例化整个模板。例如：

``` c++
template<typename T>
struct Foo {
    void f() {puts("T");}
};
template<>
void Foo<int>::f() {puts("I");}
template<>
void Foo<double>::f() {puts("D");}

int main()
{   
    Foo<int>().f();     // I
    Foo<double>().f();  // D
    Foo<string>().f();  // T
    return 0;
}
```

#### （6）





























## `[*]`十一、标准库特殊设施

### 1. tuple

tuple，一个“快速而随意”的数据结构。

``` C++
#include <tuple>

tuple<T1,T2,...,Tn> t; // 默认构造函数，值初始化
tuple<T1,T2,...,Tn> t(v1,v2,...,vn); 
make_tuple(v1,v2,...,vn);	

t1 == t2;	 // 只有两个tuple大小相等时才能比较（==、<...）
t1 != t2;    // 字典序比较，类型不必对应相同，但应该可以相互转换
t1 relop t2; // 显然比较一个string和一个int不合法

get<i>(t);	 // 返回第i个成员的引用（左值/右值）,i从0开始

tuple_size<tupleType>::value; // 一个类模板,可以通过一个tuple类型来初始化。他有一个名为value的public constexpr static数据成员，类型为size_t，表示给定tuple类型中成员的个数

tuple_element<i,tupleType>::type; // 返回第i个成员的类型
								  // i是常量表达式
```

### 2. bitset

bitset 使得位运算的使用更为容易，它能够处理超过最长整型类型大小的位集合。

* 作为一个类模板，bitset 类似 array 类，有固定的大小，需要用一个常量表达式指定。

* bitset 中的二进制位从 0 开始编号。编号从 0 开始的位称为低位（low-order），编号到 n-1 结束的二进制位称为高位（high-order）

```c++
#include <biset>
// 初始化：多余的高位置0
bitset<n> b;				   // 为一位均为0
bitset<n> b(u);				   // ULL
bitset<n> b(s,pos,m,zero,one); // string
bitset<n> b(cp,m,zero,one);	   // const char* / char[]
							   // 字符串的下标最小的对应高位
							   // 如果字符部位zero或one
							   // 抛出invalid_argument异常
// 检测或设置一个或多个二进制位
b.any();
b.all();
b.none();
b.count();
b.size();
b.test(pos);  // 位置pos是否为true

b[pos];		  // 返回引用

b.set(pos,v); // 将位置pos置位v,v默认为true
b.set();	  // 将所有位置位true

b.reset(pos); // 将位置pos置位false
b.reset();    // 将所有位置位fasle

b.flip(pos);  // 改变位置pos的状态
b.flip();     // 改变所有位的状态

b.to_ulong(); // 返回一个unsigned long值
b.toullong(); // 返回一个unsigned long long值
			  // 溢出时抛出 overflow_error 异常
b.to_string(zero,one); // 返回一个string
os << b;      // 以0/1的形式打印
is >> b;      // 当下一个字符不是0/1，或已经读取了b.size()个位时
		      // 读取过程停止，本质上使用一个临时string对象初始化
```

### `[*]`3. 正则表达式

### 4. 随机数

随机数生成器的两个评估指标：

1. 生成效率
2. 随机数质量

#### （1）C库函数rand的问题

**1.随机性和质量较差**：

* `rand()` 生成的伪随机数序列质量一般，随机性不强，特别是在现代计算需求下很难满足要求。它使用的算法通常是线性同余法，容易产生明显的模式，不适合对随机性有高要求的应用，比如密码学。

**2.范围有限**：

* `rand()` 生成的数在 `[0, RAND_MAX]` 范围内，而 `RAND_MAX` 通常较小（如 `32767` 或 `2147483647`），因此随机数范围受限，不适合需要更大范围或精度的应用。

**3.缺乏分布控制**：

* `rand()` 只能生成均匀分布的随机数，无法直接生成特定分布的随机数（如正态分布或伯努利分布）。如果需要其他分布的随机数，需要手动实现，增加了代码复杂度。

**4.功能有限**：

* `rand()` 只能生成在 `[0, RAND_MAX]` 范围内的整数，因此对于例如浮点数的生成，程序员只能试图转换 rand 生成的浮点数的范围、类型或分布，而这个过程常常会引入非随机性以及其它问题。
  * 例如，由于 `RAND_MAX` 通常较小，通过除法缩放得到的浮点数精度有限。
  * 其次 `rand()` 的伪随机特性本身质量不高，经过缩放后浮点数的分布可能不均匀，无法保证生成结果的均匀性和随机性。
  * 浮点数的缩放和偏移操作会引入精度误差，使得生成的数在边界处分布不均匀。`float random_float_in_range = a + static_cast<float>(rand()) / RAND_MAX * (b - a);`

#### （2）C++ 随机数

C++ 不应该使用 C 库函数 rand，而应该使用 default_random_engine 类和恰当的分布类对象来生成随机数。

在 C++ 中，定义在头文件 `random` 中的随机数库通过一组**协作**的类和对象来解决 rand 的问题，这些类分为三个层次：

1. 随机数引擎（类）：生成[原始] unsigned 随机数序列
2. 随机数分布（类）：生成指定类型的、在给定范围内的、服从特定概率分布的随机数
3. 随机数生成设备（随机数种子）：调整引擎

随机数引擎对象和随机数分布对象的结合构成了 C++ 的**随机数发生器**。其中[随机数引擎对象]用于生成原始 unsigned 随机数序列，而[随机数分布对象]则将随机数引擎生成的原始 unsigned 随机数序列<font color=blue>映射</font>为我们要求的特定类型、特定范围和特定分布概率的随机数序列。从而解决了 C 库函数 rand 的局限性。

#### （3）随机数引擎

随机数引擎是函数类对象，它们定义了一个调用运算符，该运算符不接收参数并返回一个随机 unsigned 整数。我们可以通过调用一个随机数引擎对象生成“原始”随机数：

``` C++
default_random_engine e;
for(int i = 0; i < 10; i ++ )
    cout << e() << endl;
```

标准库定义了多个随机数引擎类，区别在于**性能**和**随机性质量**不同。每个编译器会指定其中一个作为 default_random_engine 类型。此类型一般具有最常用的特性。随机数引擎操作：

``` C++
Engine e;		// 默认ctor；使用该引擎类型默认的种子	
Engine e(s);	// 使用整型值s作为种子
e.seed(s);		// 使用种子s重置引擎的状态
e.min();
e.max();
Engine::result_type; // 此引擎生成的unsigned整形类型
e.discard(u);	// 将引擎推进u步；u的类型为unsigned
```

对于大多数场合，随机数引擎是不能直接使用的，这也是为什么我们称他为原始随机数（随机数引擎看起来和 rand 并没有什么大的差别）。问题在于原始随机数的值范围通常与我们需要的不符，而正确转换随机数的范围是机器困难的。

#### （4）随机数分布

分布类型的操作：

``` c++
Dist d;
d(e);      //e是一个随机数引擎对象
d.min();   //返回d(e)能生成的最小值和最大值
d.max();
d.reset(); //重置d的内部状态，使得下一次生成的数序列可以从头开始，仿佛分布对象是新创建的一样。
```

> 通常情况下，标准的分布对象在每次调用时都会按照设定好的分布规律生成数值，且不依赖于前一次的生成结果。因此，大部分分布对象的状态在生成数值时不会改变，所以对于这些分布，调用 `reset()` 并不会有明显的效果。
>
> 不过，对于某些分布（例如 `std::poisson_distribution` 或 `std::geometric_distribution`），它们可能在生成数值时会改变内部状态，以提升效率或满足特定的生成要求。在这些情况下，`reset()` 可以确保分布对象的内部状态归零，以避免后续生成数值时出现偏差。

C++ 随机数生成优于 rand 的核心在于 C++ 提供了分布类型，通过分布类型，我们可以指定随机数的范围和类型（浮点数/大整数/小整数）等。

``` C++
default_random_engine e;
uniform_int_distribution<unsigned> u(0, 9);
for(int i = 0; i < 10; i ++ )
    cout << u(e) << endl;
```

类似随机数引擎，随机数分布也是函数对象类。它的函数调用运算符接受一个随机数引擎作为参数，分布对象使用该引擎参数生成随机数，并将其映射到指定的分布。

注意，我们传递给分布对象的是[引擎本身]，即 u(e)。如果我们写成 u(e())，含义就变成将 [e 的下一个值]传递给 u，会导致编译错误。之所以要传递引擎而不是引擎生成的值是因为某些分布可能需要调用多次引擎才能生成一个值。

##### 4.1 生成随机实数

程序常需要一个随机浮点数的源。特别是，程序经常需要 0 到 1 之间的随机数。在 C 语言中，我们通过 `rand() % RAND_MAX;` 来实现 0~1 随机浮点数的生成。但这种发放有一个显著的缺点，那就是通常整数的范围远小于浮点数的范围，这就会导致随机整数的精度通常低于随机浮点数，从而导致一些浮点数永远不会生成。

在 C++ 中，我们可以通过定义一个 `uniform_real_distribution` 类型的对象，并让标准库来处理从随机整数到随机浮点数的映射。

``` c++
default_random_engine e(time(nullptr));
uniform_real_distribution u;
for(int i = 0; i < 3; i ++ )
    cout << u(e) << endl;
```

##### 4.2 使用分布的默认结果类型

分布类型都是模板，具有单一的模板参数类型，表示分布生成的随机数的类型，对此有一个例外，我们将在下面介绍。这些分布类型要么生成浮点数，要么生成整数类型。

> 实际上，只有一种情况可以作为例外：那就是 bool 值。bool 值的结果要么是 0 要么是 1，它不需要指定特殊的类型。

每个分布类型都有一个默认模板实参（指定随机数的默认类型）。生成浮点数的分布默认模板实参类型是浮点数，生成整数的分布默认模板实参类型是整数。由于分布类型只有一个实参，因此当我们希望使用默认模板实参时，需要显示指定 `<>`：

``` c++
default_random_engine e(time(nullptr));
uniform_real_distribution<> u;
for(int i = 0; i < 3; i ++ )
    cout << u(e) << endl;
```

实际上不加 `<>` 也是以可以的。

##### 4.3 生成非均匀分布的随机数

除了正确生成在指定范围内的数之外，C++ 新标准库的另一个优势是可以生成非均匀分布的随机数。事实上，新标准库定义了 20 中分布类型。

作为例子，我们可以生成一个正态分布的值的序列，并画出值的分布。由于 生成正态（高斯）随机数的类 `normal_distribution` 生成浮点数，我们使用头文件 cmath 中的 lround 函数（四舍五入并返回 long 类型整数，普通的 round 返回 double 类型）将每个随机数舍入到下界。例如以 4 为中心，1.5 为标准差的正太分布，根据 68-95-99.7 规则，我们希望 99% 的值都在 0-8 之间（包含）。

``` c++
int main()
{
    default_random_engine e(time(nullptr));
    normal_distribution<> u(4, 1.5);
    vector<unsigned> vals(9);
    for(int i = 0; i < 20000; i ++ ) {
        unsigned val = lround(u(e));
        if(val < vals.size()) ++ vals[val];
    }
    for(int i = 0; i < vals.size(); i ++ )
        cout << i << ": " << string(int(vals[i] * 1.0 / 100), '*') << endl;
    return 0;
}
```

输出：

``` c++
0: *
1: *******
2: **********************
3: *****************************************
4: ****************************************************
5: ******************************************
6: **********************
7: *******
8: *
```

##### 4.4 bernoulli_distribution 类

我们注意到有一个分布不接受模板参数，即伯努利分布类 `bernoulli_distribution`，因为它是一个普通类，而非模板。此分布总是返回一个**伯努利分布**（要么为 0，要么为 1）。它返回 1的概率是一个常数，此概率的默认值为 0.5。

我们可以修改这个默认值，使得返回 true 的概率为 0.6：

``` C++
int main()
{
    default_random_engine e(time(nullptr));
    bernoulli_distribution u(0.6); //返回1的概率为0.6
    int true_cnt = 0, false_cnt = 0;
    for(int i = 0; i < 10000; i ++ )
    {
        bool r = u(e);
        r ? ++true_cnt : ++ false_cnt;
    }
    cout << true_cnt * 1.0 / 10000 << endl // 0.6026
    cout << false_cnt * 1.0 / 10000 << endl; // 0.3974
    return 0;
}
```

#### （5）引擎就是一个数值序列

随机数引擎本质上并不是“真正的随机数”生成器，而是一个伪随机数生成器（PRNG，Pseudo-Random Number Generator）。它根据某个算法和种子生成一系列具有特定模式的数值，这个序列看上去随机，但实际上是可重复和可预测的。

> 随机数引擎使用某种数学算法（如线性同余算法、梅森旋转算法）来生成数值序列。只要算法和初始种子相同，每次生成的序列也是完全相同的。这种确定性使得伪随机数序列在实际运行时可重复，而不是完全随机的。

由于随机数引擎的算法是有限的数学计算过程，生成的数列是周期性的，即经过一定次数后会重新循环生成相同的数列。例如，`std::mt19937` 引擎的周期非常长（约为 219937−12^{19937} - 1219937−1），因此它在较短时间内表现为随机，但从理论上讲，仍然会回到序列的起点并重复。

#### （6）随机数并不“随机”

同上一节讲到的，随机数引擎实际上是“伪随机”。这意味着随机数有一个容易让人迷惑的特性，那就是即使生成的数看起来是随机的，但对于一个给定发生器，每次运行程序她都会返回相同的数值序列。**序列不变这一特性在调式时非常有用**。但另一方面，使用随机数发生器的程序也必须考虑这一特性。

``` C++
vector<unsigned> bad_randVec()
{
    vector<unsigned> v;
    default_random_engine e;
    uniform_int_distribution u;
    for(int i = 0; i < 3; i ++ )
        v.push_back(u(e));
    return v;
}
```

对于上面的代码，每次返回的 vector 都是一样的。编写此代码的正确方式是将引擎和关联的分布对象定义为 static：

``` c++
vector<unsigned> bad_randVec()
{
    vector<unsigned> v;
    static default_random_engine e;
    static uniform_int_distribution u;
    for(int i = 0; i < 3; i ++ )
        v.push_back(u(e));
    return v;
}
```

这样就可以确保每次调用该函数之后，随机数引擎和分布的状态都会改变。

#### （7）设置随机数发生器种子

随机数发生器会生成相同的随机数序列这一特性在调试时很有用。但是，一旦我们的程序调式完毕，我们通常希望每次运行程序都会生成不同的随机结果。

对于上一节讨论的使用 static 来修改随机数发生器状态的方法，在一次程序执行过程中的不同调用中，每次调用的结果并不相同。但两次程序执行过程中的对应每一次调用的结果是相同的。因此，我们还需要一种更好的方法来修改随机数发生器的状态。

我们可以通过提供一个种子（seed）来达成这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。我们可以在创建引擎时指定种子，也可以在创建后使用引擎的 seed() 成员提供种子。

可以把种子理解为一个起点，它决定了生成器在伪随机数序列中的“位置”。<font color=blue>从数学角度来看，**种子**只是生成器算法的一个**初始输入**，它不会改变生成器的算法本身逻辑，因此算法产生的数值序列以及其周期性不会改变，但会使生成器从不同的起点开始生成数列。</font>

* 伪随机数生成器通过数学算法生成一系列看似随机的数值，而种子是输入给算法的第一个值，决定了生成序列的起始位置。
* 每个不同的种子值会生成一个不同的伪随机数序列，种子相同的情况下，生成器将始终产生相同的随机数序列。这使得伪随机数生成器是确定性的，也就是说，它的行为是可以重复和预测的。
* 种子的选择会影响伪随机数生成器的表现，但不同生成器对种子敏感性不一样。对于高质量的生成器（如 `std::mt19937`），种子的分布性好，即不同种子可以很好地分散生成的序列，使得伪随机数更具随机性和均匀性。
* 简单的生成器可能对种子敏感，某些种子值可能导致生成器产生不均匀的数列，甚至是非常接近的序列。因此，选择合适的生成器和种子组合，对生成伪随机数的质量有直接影响。

由此可见，选择一个好的随机数种子是极其重要且极其苦难的。最常用的方法是调用系统函数 time，它返回从一个Unix纪元（`1970年1月1日 00:00:00 UTC`）到当前时间经历了多少秒。函数 time 接受单个函数指针参数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单的返回当前时间距离 Unix 纪元的时间：

``` c++
vector<unsigned> bad_randVec()
{
    vector<unsigned> v;
    default_random_engine e(time(nullptr));
    uniform_int_distribution u;
    for(int i = 0; i < 3; i ++ )
        v.push_back(u(e));
    return v;
}
```

不过值得一提的是，time 是以秒为单位计时的，因此这种方法只适用于生成种子的间隔为秒级或更长的应用。

#### （8）mt19937 和 random_device

##### random_device

`std::random_device` 是C++11标准库中提供的一个**随机数引擎**，用于生成**硬件随机数或伪随机数**。它被设计为**产生高质量的种子数**，通常用于初始化其它伪随机数生成器，比如`std::mt19937`（梅森旋转算法）。

> 注意 random_device 是一个随机数引擎，只不过它生成的随机数往往与硬件有关。其用途是作为其它随机数引擎的种子。

`std::random_device`通常是基于硬件熵源，提供比传统伪随机数生成器更不可预测的随机性。不过它是依赖于平台的，在某些平台上（如Linux），`std::random_device`确实使用了硬件熵源。而在另一些平台（如某些Windows实现）上，它可能会退化为伪随机数生成器。

##### mt19937

`std::mt19937` 是C++11标准库中的一个**伪随机数引擎**，它基于**梅森旋转算法**（Mersenne Twister），其中`mt`表示“梅森旋转”（Mersenne Twister），`19937`表示它的周期为 $2^{19937} - 1$。`std::mt19937` 是一种高效、快速且均匀的随机数生成器，广泛用于需要大量随机数的场景。

`std::mt19937_64` 与 `std::mt19937` 类似，但使用 **64位** 的梅森旋转算法，适合需要生成更大范围随机数的应用。和 `std::mt19937` 一样，它基于 **Mersenne Twister** 算法，但使用64位精度。

* `std::mt19937` 生成32位伪随机数，适合一般用途。
* `std::mt19937_64` 生成64位伪随机数，适合需要更高数值精度的场景。

##### 实例

``` C++
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<uint32_t> u(0, 10 - 1);

int main()
{
    vector<size_t> cnt(10);
    for(int i = 0; i < 10000000; i ++ )
        cnt[u(gen)] ++ ;
    for(int i = 0; i < 10; i ++ ) 
        cout << i << ": " << cnt[i] * 1.0 / 10000000 << endl;
    return 0;
}
```

### 5. IO库再探

标准库的操纵符大都定义在头文件 `iomanip` 中。

#### （1）格式控制

除了<font color=blue>条件状态</font>外，每个 iostream 对象还维护一个<font color=blue>格式状态</font>来控制 IO 如何格式化的细节。包括：整型数是几进制、浮点数的精度、一个输出元素的宽度等。

<font color=blue>标准库定义了一组**操纵符（manipulator）**来修改流的格式状态。一个操纵符是一个**函数**或是一个**对象**，会影响流的状态，并能用作输入或输出运算符的**运算对象**。</font>类似输入和输出运算符，操纵符也返回它所处理的流对象，因此我们可以在一条语句中组合操纵符和数据。

例如我们常用的操纵符–– `endl`，我们将它“写”到输出流，就像是一个值一样。但 endl 不是一个普通值，而是一个操作：它输出一个换行符并刷新缓冲区。

操作符用于两大类输出控制：

1. 控制数值的输出形式
2. 控制补白的数量和位置

大多数改变格式状态的操纵符都是设置/复原成对的：一个操纵符用来将格式状态设置为一个新值，而另一个用来将其复原，恢复为正常的默认格式。

由于操纵符本质上改变的是流的“格式状态”值，因此，当操纵符改变流的格式状态时，通常改变后的状态对所有后续 IO 都生效。因此，通常最好在不再需要特殊格式时尽快将流恢复到默认状态。

注意，“格式状态”的值是基于“流”而不是“IO 语句”的。这意味着，你在第一条 IO 语句中修改了格式状态的值并且没有复原，在另外一条 IO 语句中仍然会生效。例如 cin 和 cout 语句，它们共享 iostream 流的“格式状态”。

##### 1.1 控制布尔值的格式

> * boolalpha
> * noboolalpha

默认情况下，bool 打印 0 或 1。我们可以通过使用 boolalpha 操纵符将 0 和 1 替换为 true 和 false：

``` C++
int main()
{
    {
        bool f1 = false, f2 = true;
        cout << boolalpha << f1 << ' ' << f2 << endl; // false
    }
    bool f3 = true;
    cout << f3 << endl; // true
    cout << noboolahpha; // 复原
    cout << f3 << endl; // 1
    return 0;
}
```

##### 1.2 指定整型值的进制

> * showbase
> * dec
> * oct
> * hex
> * uppercase
> * nouppercase
> * nobaseshow

hex，oct，dec 可以将进制分别改为十六进制、八进制、十进制。默认为十进制：

``` C++
int val = 0x12345678;
cout << "hex: " << hex << 20 << ' '  << 1024 << endl;
cout << "octal: " << oct << 20 << ' '  << 1024 << endl;
cout << "decimal: " << dec << 20 << ' '  << 1024 << endl;
cout << noshowbase; //恢复流状态
cout << "default: " << 20 << ' '  << 1024 << endl;
```

``` c++
hex: 14 400
octal: 24 2000
decimal: 20 1024
default: 20 1024
```

但我们发现，这种形式的输出不太“直观”，例如十六进制，它不是 `0x14`，而是直接输出 14。我们可以使用 showbase 来显示的输出当前数字的进制（0x 表示十六进制，0 表示八进制，无前导字符串表示十进制）：

``` C++
cout << showbase;
cout << "hex: " << hex << 14 << ' '  << 1024 << endl;
cout << "octal: " << oct << 14 << ' '  << 1024 << endl;
cout << "decimal: " << dec << 14 << ' '  << 1024 << endl;
cout << noshowbase; //恢复流状态
cout << "default: " << 14 << ' '  << 1024 << endl;
```

``` c++
hex: 0xe 0x400
octal: 016 02000
decimal: 14 1024
default: 14 1024
```

不过我们可以发现，十六进制下 进制前缀 `0x` 的 `x` 和 数据部分的 `e` 都是以小写形式输出的。我们可以通过 uppercase 操纵符来以大写形式输出：

``` C++
cout << showbase << uppercase << 
    hex << 14 << ' '  << 1024 
    << nouppercase << noshowbase << endl; // 0XE 0X400
```

最后可以通过 noshowbase 恢复流状态（十进制输出 + 不显示进制前缀）。

##### 1.3 控制浮点数格式

我们可以控制浮点数输出三种格式：

1. 以多高的精度（多少个数字，包括整数部分和小数部分）打印浮点数
2. 数值是大因为十六进制、定点十进制还是科学计数法形式
3. 对于没有小数部分的浮点数是否打印小数点

###### 1）指定打印精度

> * precision(int)
> * setprecision(int)

<font color=blue> 默认情况下，精度会控制打印的数字的总数。</font>当打印时，浮点数按当前精度射入而非阶段，因此，如果当前精度为四位数字，则 3.1415926 将大因为 3.1412；如果精度为三位，则打印 3.14。

> 精度控制的是打印的数字（整数部分+小数部分）的总数意味着，如果浮点数的整数部分就超过了精度大小，那么浮点数可能忽略小数部分。
>
> ```c++
> double s = 1.23456789; 
> cout << s * 1e5 << endl; // 123457
> ```
>
> 在上面的例子中，由于整数部分就占了 6 位，而默认精度就是 6 位，因此这里小数部分会被舍入（注意不是截断）。

我们可以通过 IO 对象的 precision 成员或使用 setprecision 操纵符来改变精度。precision 成员是重载的。一个版本接受一个 int 值，并将精度设置为此值，返回值为旧精度值。另一个版本不接受参数，返回当前精度值。setprecision 操纵符接受一个参数，用来设置精度。它们都定义在头文件 `iomanip` 中。

``` c++
double p = 3.1415926;
cout << "cur precision: " << cout.precision() << endl;
cout << "default: " << sqrt(2.0) << endl;
cout.precision(4);
cout << sqrt(2.0) << endl;
cout << setprecision(8) << sqrt(2.0) << endl;
```

其中，`cout.precision(int)` 有返回值；`setprecision()` 没有返回值。它们设置的精度是整数部分和小数部分数字的个数和。

注意，标准库似乎没有设置默认浮点数精度（复原）的操纵符，因此如果我们想要暂时修改浮点数精度，需要先将原来的精度保存下来。

###### 2）指定浮点数记数法

除非你需要控制浮点数的表示形式（如，按列打印（列对齐）数据或打印金额或百分比的数据），否则，**由标准库选择记数法**是最好的方式。

``` c++
cout << sqrt(2.0) << endl;  // 1.41421
cout << 1000 * sqrt(2.0) << endl; // 1414.21
cout << 100000 * sqrt(2.0) << endl; // 141421
cout << 1000000 * sqrt(2.0) << endl; // 1.41421e+06
```

如上所示，当浮点数太大时，标准库会自动使用科学计数法。

> * scientific
> * fixed
> * hexfloat
> * defaultfloat

通过使用恰当的操纵符，我们可以强制一个流使用科学计数法、定点十进制或是十六进制计数法。defaultfloat 将流恢复到默认状态 —— 根据要打印的值选择记数法。

* **`std::scientific`** 适用于显示非常大的或非常小的浮点数。
* **`std::fixed`** 适用于需要固定小数位数的格式化输出。
* **`std::hexfloat`** 适用于需要查看浮点数的十六进制表示，通常用于底层编程。
* **`std::defaultfloat`** 恢复默认的浮点格式，适合自动选择合适的格式。

```` C++
cout << fixed << setprecision(7) << sqrt(2) << endl; // 1.4142136
cout << scientific << 10000 * sqrt(2) << endl; // 1.4142136e+04
cout << hexfloat << sqrt(2) << endl; // 0x1.6a09e667f3bcdp+0
````

这些操纵符也会**改变流的精度的默认含义**。在执行 scientific、fixed 或 hexfloat 后，浮点数精度控制的是小数点后面的数字位数，而默认情况下是指数字的总位数。

使用 fixed 和 scientific 令我们可以**按列打印**数值，因为小数点距小数部分的距离是固定的。

默认情况下，十六进制数字和科学记数法中的 e 都打印成小写形式。我们可以通过 uppercase 操纵符打印这些字母的大写形式。

###### 3）打印小数点

> * showpoint
> * noshowpoint

默认情况下，当一个浮点数的小数部分位 0 时，不显示小数点。showpoint 操纵符可以强制打印小数点。

``` c++
cout << showpoint << f << endl; // 123.000
```

##### 1.4 输出补白

当按列打印数据时，我们常常需要非常精确的控制数据格式。标准库提供了一些操纵符帮助我们完成所需的控制：

* setw(w)：指定**下一个**数字或字符串值的最小空间（宽度）
* left：左对齐输出
* right：右对齐输出，右对齐是默认格式
* internal：控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满所有中间空间
* setfill(ch)：允许指定一个字符代替默认的空格来补白输出

``` c++
int main()
{
    int i = -16;
    double d = 3.14159;
    // 默认对齐方式
    cout << "i: " << setw(12) << i << "next col" << "\n"
         << "d: " << setw(12) << d << "next col" << "\n";
    // 左对齐
    cout << left 
         << "i: " << setw(12) << i << "next col" << "\n"
         << "d: " << setw(12) << d << "next col" << "\n";
    // 右对齐
    cout << right
         << "i: " << setw(12) << i << "next col" << "\n"
         << "d: " << setw(12) << d << "next col" << "\n";
    // 中间
    cout << internal
         << "i: " << setw(12) << i << "next col" << "\n"
         << "d: " << setw(12) << d << "next col" << "\n";
    // 以#取代空格填充空白
    cout << setfill('#')
         << "i: " << setw(12) << i << "next col" << "\n"
         << "d: " << setw(12) << d << "next col" << "\n"
         << setfill(' '); // 恢复正常的补白字符    
    return 0;
}
```

``` C++
i:          -16next col
d:      3.14159next col
i: -16         next col
d: 3.14159     next col
i:          -16next col
d:      3.14159next col
i: -         16next col
d:      3.14159next col
i: -#########16next col
d: #####3.14159next col
```

##### 1.5 控制输入格式

> * skipws
> * noskipws

默认情况下，输入运算符会忽略空白符（空格，制表符，换行符、回车符和换行符）。操纵符 noskipws 会令运算符读取空白符，而不是跳过他们。

#### （2）未初始化IO

除了通过操纵符实现输入和输出的格式化 IO 之外，标准库还提供了一组底层操作，支持未格式化 IO。这些操作允许我们将一个流当作一个<font color=blue>无解释的字节序列</font>来处理。

##### 2.1 单字节操作

 单字节操作每次一个字节地处理流。他们会**读取而不是忽略空白符**。

``` c++
is.get(ch);		//从istream is读取下一个字节存入ch。返回is
is.put(ch);		//将字符ch输出到ostream ps。返回os
is.get();		//将is的下一个字节作为int返回

is.putback(ch);	//将字符ch放回is。返回is
is.unget();		//将is向后移动一个字节。返回is
is.peek();		//将下一个字节作为int返回，但不从流中删除它
```

###### 2.1.1 将字符放回流

有时我们需要读取一个字符才能知道还未准备好处理它。在这种情况下，我们希望将字符放回流中。标准库提供了三种方法退回字符，他们有着细微的区别：

* peek 返回输入流中下一个字符的副本，但不会从流中删除它
* unget 使得输入流向后移动，并且将最近读取的字符放回流的顶部，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以调用 unget
* putback 是更特殊版本的 unget：它退回从流中读取的最后一个值，但它接受一个参数，此参数必须和最后读取的值相同

一般情况下，在读取下一个值之前，标准库保证我们可以退回最多一个值。即，标准库不保证在中间不进行读取操作的情况下能连续调用 putback 或 unget。

##### 2.2 多字节操作

一些未格式化 IO 操作一次处理一块数据。如果速度是要考虑的重点的话，这些操作是很重要的，但类似其他底层操作，这些操作也容易出错。特别是，这些操作要求我们**自己分配并管理用来保存和提取数据的字符数组**。

``` c++
is.read(sink, size); 
	// 读取最多size个字节，存入字符数组sink中。返回is
os.write(source, size);
	// 将字符数组source的size个字节写入os

is.get(sink, size, delim);
	// 读取最多size个字节或遇到字符delim或EOF时停止。
	// 遇到delim时，将其留在输入流中，不读取出来存入sink
is.getline(sink, size, delim);
	// 和get的区别在于，遇到delim时会读取出来并丢弃掉

is.gcount();
	// 返回上一个未格式化读取操作从is中读取的字节数
	// 将字符退回流的单字符操作也输入未格式化读取（输入）操作
	// 因此对于peek、unget、putback会返回0
is.ignore(size=1, delim=EOF);
	// 读取并忽略最多size个字符，包括delim。
```

注意这里的 cin.getline() 和 头文件 `string` 中定义的 string 不同。

注意 ch 数组要预留出一个空间存放空字符！

##### 2.3 低层函数容易出错

一般情况下，我们主张使用标准库提供的高层抽象。返回 int 的 IO 操作很好的解释了原因。

一个常见的编程错误就是将 get 或 peek 的返回值赋予一个 char 而不是一个 int。这是错误的，但编译器不能发现这个错误。最终会发生什么依赖于程序运行所在的机器以及输入数据是什么。例如，在一台 char 被实现为 unsigned char 的机器上，下面的循环永远不会停止：

``` C++
char ch;
while((ch = cin.get()) != EOF)
    cout.put(ch);
```

如果 EOF 对应的 int 值为 -1，那么循环将永远为 true。除此之外，如果 cin.get() 的值超出了unsigned  char 所能表示的范围，程序的行为也是未定义的。

#### （3）流随机访问

各种流通常都支持对流中数据的随机访问。我们可以重定位流，使之跳过一些数据，首先读取最后一行，然后最后第一行，以此类推。标准库提供了一堆函数，来定位（`seek`）到流中给定的位置，以及告诉（`tell`）我们当前位置。

> 随机 IO 本质上是依赖于系统的。因此如何使用这些特性需要查询系统文档。

虽然标准库为所有流类型都定义了 seek 和 tell 函数，但它们是否做有意义的事情依赖于流绑定到哪个设备。在大多数系统中，绑定到 cin、cout、cerr 和 clog 的流不支持随机访问 —— 毕竟，当我们向 cout 直接输出数据时，类似向会跳十个位置这种操作是没有意义的。对这些流我们可以调用 seek 和 tell 函数，但在运行时会出错，将流置于一个无效状态。

> 由于 istream 和 ostream 类型通常不支持随机访问，所以这里主要讨论的是 fstream 和 sstream 类型。

##### 3.1 seek和tell函数

为了支持随机访问，IO 类型维护一个标记来确定下一个读写操作要在哪里进行。标准库提供了两个函数 seek 和 tell 用来重定位标记的位置以及返回当前标记的位置。事实上标准库定义了两对 seek 和 tell，分别用于输入流和输出流。其中后缀是 g(get) 的表示输入流；后缀是 p(put) 的表示输出流版本。

``` c++
tellg();
tellp();

seekg(pos);// 绝对地址
seekp(pos);

seekg(off,from);// 相对地址，将标记定位到from之前或之后off个字符
seekp(off,from);// from：
					// beg，偏移量相对于流开始的位置
					// cur，偏移量相对于流当前位置
					// end，偏移量相对于流结束位置
```

##### 3.2 只有一个标记

在 seek 和 tell 函数中区分了输入流 get 和输出流 put 的版本可能导致一个误解，认为输入流和输出流分别有一个独立的标记。事实上，**流中只存在唯一的标记，并不存在独立的读标记和写标记。**

由于只有唯一的标记，因此只要我们在读写操作间切换，就需要进行 seek 操作来重定位标记。

##### 3.3 重定位标记

seek 函数有两个版本：一个移动到文件中的绝对位置；另一个移动到文件中的相对位置：

``` C++
seekg(pos_type new_position);
seekp(pos_type new_position);

seekg(off_type offset, ios_base::seekdir from);
seekp(off_type offset, ios_base::seekdir from);
```

其中，类型 pos_type 和 off_type 是机器相关的，off_type 的值可正可负，他们定义在头文件 `istream` 和 `ostream` 中。

##### 3.4 访问标记

tellg 和 tellp 返回一个 pos_type 值，它通常用来记住一个位置，以便稍后再定位回来：

``` c++
ostringstream writeStr;
ostringstream::pos_type mark = writeStr.tellp();
// ...
if(cancelEntry) {
    writeStr.seekp(mark);
}
```

##### 3.5 读写同一个文件

我们给出一个编程实例，来体会一下 seek 和 tell 的应用。在这里编程实例当中，假定已经给定了一个要读取的文件，我们要在此文件的末尾写入新的一行，这一行包含文件中每行的相对起始位置。第一行的起始位置固定为 0，因此不必写入。例如，给定下面文件：

``` c++
abcd
efg
hi
j
```

则程序应该生成如下修改过的文件：

``` c++
abcd
efg
hi
j
5 9 12 14
```

注意别把每行最后的换行符忽略了。

``` c++
fstream file("./data/io.txt", fstream::ate | fstream::in | fstream::out);
if(!file) //好的编程习惯
{
    cout << "[error]open file failed" << endl;
    return EXIT_FAILURE;
}
auto end_mark = file.tellg();
file.seekg(0, fstream::beg);
size_t cnt = 0;
string line;
while(file && file.tellg() != end_mark && getline(file, line)) 
{
    cnt += line.size() + 1; //换行符
    auto cur_mark = file.tellg();
    file.seekp(0, fstream::end);
    file << cnt;
    if(cur_mark != end_mark)    file << " ";
    file.seekg(cur_mark);
}
file.seekp(0, fstream::end);
file << "\n";
```

#### （4）附录：定义在 iostream 中的操纵符

| 操纵符          | 含义（*表示默认流格式状态）                 |
| --------------- | ------------------------------------------- |
| boolalpha       |                                             |
| \*noboolalpha   |                                             |
| showbase        |                                             |
| \*noshowbase    |                                             |
| showpos         | 对非负数显示+，pos:positive，正数           |
| \*noshowpos     |                                             |
| showpoint       | 对浮点数总是显示小数点                      |
| \*noshowpoint   | 只有当浮点数包含小数部分时才显示小数点      |
| uppercase       | 数字中的字母显示为大写，例如E/e，0X/0x，F/f |
| *nouppercase    |                                             |
| *dec            |                                             |
| oct             |                                             |
| dec             |                                             |
| left            | 在值的左侧添加填充字符                      |
| right           | 在值的右侧添加填充字符                      |
| internal        | 在负号和值之间甜茶填充字符                  |
| fixed           | 浮点数显示为定点十进制                      |
| scientific      | 浮点数显示为科学计数法                      |
| unitbuf         | 每次输出操作后都刷新缓冲区                  |
| \*nounitbuf     |                                             |
| \*skipws        | 输入运算符提奥果空白符                      |
| noskipws        |                                             |
| flush           | 刷新ostream缓冲区                           |
| ends            | 插入空字符然后刷新ostream缓冲区             |
| endl            | 插入换行然后刷新ostream缓冲区               |
| setfill(ch)     | 用ch填充空白                                |
| setprecision(n) | 将浮点精度设置为n                           |
| setw(w)         | 下一个读或写值的宽度为w个字符               |
| setbase(b)      | 将整数输出为b进制                           |

## 十二、适用于大型程序的工具

与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：

* 在独立开发的子系统之间协同处理错误的能力
* 使用各种库（可能包含独立开发的库）进行协同开发的能力
* 对比较复杂的应用概念建模的能力

本章介绍的三种 C++ 语言特性正好能满足上述要求，它们是：异常处理、命名空间和多重继承。

### 1. 异常处理

异常处理机制允许程序中独立开发的部分能够在**运行时**就出现的问题进行通信并做出相应的处理。异常使得我们能够**将问题的检测与解决过程分离开来**。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无需知道问题处理模块的所有细节，反之亦然。

#### （1）抛出异常

在 C++ 语言中，我们通过抛出（throwing）一条表达式来引发（raise）一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码（handler）将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。程序的异常抛出部分会告知异常处理部分到底发生了什么错误。

当执行一个 throw 时，跟在 throw 后面的语句将不再被执行。相反，程序的控制权从 throw 转移到与之匹配的 catch 模块。catch 可能是同一个函数中的局部 catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个重要的意义：

* 沿着调用链的函数可能会提早推出
* 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁

##### 栈展开

在抛出一个异常后，查找对应 catch 的过程是一个栈展开（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断回退查找，直到找到了与异常匹配的 catch 子句为止；或者也可能一直没找到匹配的 catch，则推出主函数后查找过程终止。

假如找到了一个与之匹配的 catch 子句，则程序进入该子句并执行其中的代码。当执行完这个 catch 子句之后，找到与 try 块关联的最后一个 catch 子句之后的点，并从这里继续执行。

如果没找到匹配的 catch 子句，程序将推出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的 catch 子句时，程序将调用标准库函数 **terminate**，顾名思义，terminate 负责终止程序的执行过程。

##### 栈展开过程中对象自动销毁

如果在栈展开过程中退出了某个块，编译器将负责确保这个块中创建的对象能被正确的销毁。如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用。与往常一样，编译器在销毁内置类型的对象时不需要做任何事。

> 注意对于指针来说，我们只会销毁指针本身，而不会销毁指针所指向的对象。

如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始化了，而另外一些成员在异常发生前也许还没有初始化。即使某个对象只构造了一部分，我们也要确保已构造的对象能被正确的销毁。

类似的，异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似，如果在异常发生前已经构造了一部分对象，则我们应该确保这部分元素被正确的销毁。

> 这里的销毁可以是释放已经分配的资源；也可以是将变量恢复到合法的状态等等。

##### 析构函数与异常

从语法上来说，析构函数可以抛出异常。但从逻辑上和风险控制上，析构函数中不要抛出异常，因为栈展开容器导致资源泄露和程序崩溃，所以**别让异常逃离析构函数**。具体原因在《More Effective C++》中提到两个： 

1. 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
2. 通常异常发生时，C++ 的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。（即所谓的双重异常）

在实际的编程过程中，因为析构函数仅仅是释放资源，所以他不太可能抛出异常。所有标准库类型都能确保它们的析构函数不会引发异常。

如果析构函数的某个操作真的可能抛出异常，则该操作应该被放置在一个 try 语句块当中，并且在析构函数内部得到处理。

不过，为了确保析构函数不会抛出异常，尽量不要在析构函数中执行可能抛出异常的操作，例如申请资源等。

##### 异常对象

异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行**拷贝初始化**。因此，throw 语句中的表达式必须拥有完全类型（有定义）。而且如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型。如果是临时对象，它的生命周期会延长到捕获它的那个 catch 子句。

如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直至找异常匹配的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向局部对象的指针几乎肯定是一种错误的行为。如果指针所指向的对象位于某个块中，而该块在 catch 语句之前就已经推出了，则意味着在执行 catch 语句之前局部对象就已经被销毁了。

<font color=blue>当我们抛出一条表达式时，该表达式的**静态编译时类型**决定了异常对象的类型。</font>例如，一条 throw 表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。

> 在 C++ 的设计哲学中，性能始终是优先考虑的因素。静态类型在编译时就已经确定了异常对象的具体类型，编译器可以直接生成用于创建和传递该类型对象的代码，而不需要在运行时对异常对象进行额外的类型检查或解析。这种编译时的确定性减少了运行时开销，使得异常处理机制更加高效。
>
> 动态类型检查会引入额外的开销，特别是因为异常处理在许多程序中很少发生，因此 C++ 更倾向于使用静态类型来在编译阶段确定异常对象的类型。这样可以避免运行时的额外复杂性，也符合 C++ 的 **“零开销异常”** 设计理念**（Zero-cost exception handling）**。

#### （2）捕获异常

catch 子句中的异常声明形式上和只包含一个形参的函数形参列表类似。像在形参列表中一样，如果 catch 无需访问抛出的表达式的话，则我们可以忽略捕获形参的名字。

catch 子句声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型。它可以是左值引用，但不能是右值引用。

<font color=blue>与其他临时对象不同，异常对象在初始化 catch 子句形参时被认为是左值。</font>

> 看下面的例子：
>
> ``` C++
> void f3() { throw 100; }
> void f2() { f3(); }
> void f1()
> {
>     try { f2(); }
>     catch(int &x) { cout << x << endl;  // 100 }
> }
> 
> int main() 
> {
>     f1();
>     return 0;
> }
> ```
>
> 在函数 f3 的作用域中我们抛出了一个临时对象 100，按理说，在函数 f3 结束之后，这个临时对象应该被销毁。但这是异常对象，如果把一个还没处理的异常对象销毁也太逆天了。
>
> 那你可能说，既然这样，我们抛出一个非临时对象不就好了，例如全局对象或静态对象，可问题是，我们总不能因为异常，提前创建一些全局的或者静态对象吧？这也不现实，也不符合零开销异常的原则。
>
> 所以说，抛出临时异常对象是我们的刚需，而临时异常对象又会超过其所在函数的作用域。因此，C++ 在设计上，可以延长这个临时异常对象的生命周期。也即，我们不严格的说在 C++ 中，异常处理机制的设计将抛出的异常视为左值。
>
> 故而它可以被左值引用接受而不能被右值引用接受。

和普通函数的参数类似，如果 catch 的参数类型是非引用，则该参数是异常对象的一个副本；相反，如果参数类型时左值引用，则该参数是异常对象的一个别名，因此此时改变参数也会改变异常对象。

如果 catch 形参类型是基类类型，如果是指针或引用那么它也可以使用派生类对象进行初始化；反之，则只会保留基类部分，派生类部分将被切掉。

不过，异常声明的静态类型将决定 catch 语句所能执行的操作。如果 catch 的参数是基类指针或引用类型，尽管它可以接受派生类对象，但它无法使用派生类特有的任何成员。这一点和 throw 时的类型绑定一致。这都是因为现代 C++ 需要在编译期记录 catch 形参的类型信息。

``` c++
struct Foo {
    void f() {puts("f");}
};

struct Bar : Foo {
    void g() {puts("g");}
};

int main() 
{
    try {
        throw Bar();
    } 
    catch(Foo& x) {
        x.g(); // class "Foo" has no member "g"
    }
    return 0;
}
```

由于对于类型 Foo 来说，它本身并没有函数 g 的信息，所以这里调用函数 g 失败。但是对于虚函数来说，Foo 中有它的定义，所以虚函数的调用没有问题，并且会触发动态绑定：

``` c++
struct Foo {
    void f() const {puts("f");}
    virtual void v() const {puts("Foo::v");}
};

struct Bar : Foo {
    void g() const {puts("g");}
    void v() const override {puts("Bar::v");}
};

int main() 
{
    try {
        throw Bar();
    } 
    catch(Foo& x) {
        x.v(); // Bar::v
    }
    return 0;
}
```

另外，如果在多个 catch 语句的类型之间存在着继承关系，则应该把最底端（most derived type）的类放在前面。这很显然！

#### （3）重新抛出

重新抛出异常时，不需要包任何和表达式，直接 throw 即可：`throw;` 这种空的 throw 语句只能出现在 catch 语句或 catch 语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空 throw 语句，相当于我们抛出了一个“无法被 catch”的异常，因此编译器将调用 terminate。

> 如果我们重新抛出的异常含有一个表达式，就不算是“重新”抛出而是“新”抛出。

很多时候，catch 语句会改变其异常参数的内容。如果在改变了参数的内容后 catch 语句重新抛出异常，则只有当 catch 语句声明是引用类型时我们对参数所做的改变才会被保留并继续传播。

例如：

``` C++
void f1()
{
    try {
        throw 10;
    }
    catch(int x) {
        cout << "f1: " << x << endl; // f1: 10
        x = 100;
        throw;
    }
}

void f2()
{
    try {
        f1();
    }
    catch(int x) {
        cout << "f2: " << x << endl; // f2: 10
    }
}

int main() 
{
    f2();
    return 0;
}
```

如果我们修改参数类型为引用：

``` C++
void f1()
{
    try {
        throw 10;
    }
    catch(int &x) {
        cout << "f1: " << x << endl; // f1: 10
        x = 100;
        throw;
    }
}

void f2()
{
    try {
        f1();
    }
    catch(int &x) {
        cout << "f2: " << x << endl; // f2: 100
    }
}

int main() 
{
    f2();
    return 0;
}
```

#### （4）捕获所有异常的处理代码

为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为 catch-all 的代码。例如 `catch(...)`。

由于通过 `...` 我们并不能直到异常的具体类型，甚至得不到异常对象，因此 catch-all 一般会结合重新抛出语句 `throw;` 一起使用，其中 catch-all 执行当前局部能完成的工作，随后重新抛出异常。

catch-all 可以与其它 catch 一起出现，但 catch-all 显然的要放在最后。

#### （5）函数try语句块与构造函数

通常情况下，程序执行的任何时刻都可能发生异常，特别是函数异常发生在处理构造函数初始值的过程中。由于构造函数体内的 try 语句无法处理初始值列表抛出异常的情况，我们必须将构造函数写成**函数 try语句块（也称为函数测试块，function try block）**。函数 try 语句块使得一组 catch 语句既能处理构造函数体（或析构函数体），又能处理构造函数的初始化过程（或析构函数的析构过程）。

``` C++
class Foo {
public:
    // 关键字try出现在初始值列表的冒号以及函数体之前
    Foo(int _val = 0) try : val(_val) {
        /*空函数体*/
    } catch(int e) {
            cout << e << endl;
        }
private:
    int val;
};
```

除了初始值列表和花括号，构造函数还有一种抛出异常的情况，那就是在参数初始化的过程中发生了异常。不过参数初始化属于调用表达式的一部分，这个异常会在调用者所在的上下文中处理。

#### （6）noexcept异常说明

对于用户和编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的代码（例如，不必使用 try-catch 语句块）；其次，如果编译器确定函数不会抛出异常，它就能执行某些特殊的优化操作（例如，移动语义），而这些操作并不适用于可能出错的代码。

在 C++11 新标准中，通过 **noexcept 说明（noexcept specification）**指定某个函数不会抛出异常。noexcept 说明后面也可以跟一个可选的实参，它会转化为一个 bool 值，用来显式指定 noexcept 说明的真假。

noexcept 紧跟在函数的参数列表后面：

``` C++
retType func(paras) const &/&& noexcept(expr) final/override =0;  
```

上面语句大致说明了各种“函数说明符”的出现顺序：

1. const 限定符
2. 引用限定符
3. noexcept 说明
4. override/final 说明
5. 虚函数的=0

此外，我们还需要注意 noexcept 的出现时机：

* 对于一个函数来说，noexcept 说明必须出现在该函数的所有声明语句和定义语句中。
* 我们可以在函数指针的声明和定义中指定 noexcept。指定为 noexcept(true) 的函数指针只能指向定义为 noexcept 的函数
* 在 typedef 或类型别名中则不能出现 noexcept

最后，注意 noexcept 说明符并不是函数签名的一部分。

##### 违反异常说明

编译器并不会在编译时检查 noexcept 说明。实际上，如果一个函数在说明了 noexcept 说明的同时又含有 throw 语句或者调用了可能抛出异常的其它函数，编译器将顺利通过，并不会因为这种违反异常说明的情况而报错。（个别编译器会对这种用法做出警告）

因此可能出现这样一种情况：尽管函数声明了它不会抛出异常，但实际上还是抛出了。一旦一个 noexcept 函数抛出了异常，程序就会调用 terminate 以确保遵守不会在函数运行时抛出异常的承诺。上述过程是否执行栈展开未作约定，因此，noexcept 可以用在两种情况下：

1. 确认函数不会抛出异常
2. 根本不知道该如何处理异常 —— 因此一旦抛出异常就 terminate

尽管我们通过 try-catch 去捕获异常，也无法捕获 noexcept 函数抛出的异常：

``` C++
void throw_int() 
{
    throw 5;
}

void func() noexcept 
{
    throw_int();
}

int main() 
{
    try {
        func();
    }
    catch(int e) {
        cout << e << endl;
    }
    return 0;
}
//terminate called after throwing an instance of 'int'
```

##### 异常说明的实参与异常运算符

noexcept 说明符接受一个可选的实参，该实参必须能转换为 bool 类型：

* 如果实参为 true，则函数不会抛出异常
* 如果实参为 false，则函数可能抛出异常

noexcept 说明符的实参常常与 **noexcept operator**混合使用。noexcept 运算符是一个一元表达式，它的返回值是一个 bool 类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。**和 sizeof 运算符类似，noexcept 运算符在编译期求值，且不会对运算对象求值。**

``` C++
struct Foo {
    void f1() noexcept(false) {}
    void f2() noexcept(true)  {}
    void f3() { throw 100; }
    ~Foo() {}
};
void throw_int() noexcept(false) {}

vector<int> v;
string s;
int i;
double d;
void(*fptr)() = &throw_int;

void func() 
{
    cout << noexcept(throw_int()) << endl ; // false
    cout << noexcept(fptr) << endl;         // true
    cout << noexcept(throw_int) << endl;    // true
    cout << noexcept(Foo()) << endl;        // true
    cout << noexcept(Foo().~Foo()) << endl; // true
    cout << noexcept(Foo().f1()) << endl;   // false
    cout << noexcept(Foo().f2()) << endl;   // true
    cout << noexcept(Foo().f3()) << endl;   // false
    cout << noexcept(v) << endl;            // true
    cout << noexcept(s) << endl;            // true
    cout << noexcept(i) << endl;            // true
    cout << noexcept(d) << endl;            // true
}
```

可以发现：

* 函数默认是可能抛出异常的，析构函数除外

* 如果传入一个函数的调用形式 `noexcept(throw_int())` 会返回函数的 noexcept 属性
* 如果传入的是一个指向函数的指针 `noexcept(fptr)` 或者普通对象，返回 true，甚至空指针也返回 p（一个对象本身怎么会抛出异常呢）

> noexcept 有两层含义：
>
> 1. 当跟在函数参数列表后面时，它是异常说明符；
> 2. 当作为 noexcept 异常说明的 bool 实参出现时，他是一个运算符

##### 异常说明与指针、虚函数和拷贝控制

尽管 noexcept 说明符不属于函数类型的一部分，但是函数的异常说明仍会影响函数的使用：

1. 函数指针以及该指针所指的对象必须具有一致的异常说明。这一点和 const 类似，一个声明为不抛出异常的指针只能指向不抛出异常的函数；而一个没有声明为不抛出异常的指针既可以指向不抛出异常的函数，也可以指向抛出异常的函数
2. 如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常

``` C++
class Foo {
public:
    virtual void f() {}
    virtual ~Foo() = default;
};

class Bar : public Foo {
public:
    void f() override {}
};

class Mike : public Bar {
public:
    void f() noexcept override {}
};

class Cat : public Mike {
public:
// exception specification for virtual function "Cat::f" 
// is incompatible with that of overridden function "Mike::f"
    void f() override {}
};
```

3. 当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是 noexcept 的。如果合成成员调用的任意一个函数可能抛出异常，则合成的成员是 noexcept(false)。而且，如果我们定于了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。

#### （7）异常类层次

``` shell
exception
├── bad_cast
├── bad_alloc
└── runtime_error
│   ├── overflow_error
│   ├── unrderflow_error
│   ├── range_error
│   └── ...
└── logic_error
    ├── domin_error      # 参数不在允许的范围内
    ├── invalid_argument # 传递给函数的参数无效
    ├── out_of_range     
    ├── length_error     # 试图创建一个超出容器最大大小的异常
    └── ...
```

类型 exception 仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为 what 的虚成员。其中 what 函数返回一个 const char*，该指针指向一个一 null 结尾的字符数组，并且确保不会抛出任何异常：
``` c++
class exception
{
public:
    exception() _GLIBCXX_NOTHROW { }
    virtual ~exception() _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_NOTHROW;
#if __cplusplus >= 201103L
    exception(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(const exception&) = default;
    exception& operator=(exception&&) = default;
#endif

    /** Returns a C-style character string describing the general cause
     *  of the current error.  */
    // 确保 what 不会抛出异常
    virtual const char*
        what() const _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_NOTHROW;
};
```

类 exception、bad_alloc 和 bad_cast 定义了默认构造函数，类 runtime_error 和 logic_error 没有默认构造函数，但是有一个可以接受 C 风格字符串或者标准库 string 类型实参的构造函数，这些实参负责提供关于错误的更多信息。

在这些类中，what 负责返回用于初始化异常对象的信息。因为 what 是虚函数，所以当我们捕获基类的引用时，对 what 函数的调用将执行与异常对象动态类型对应的版本。

#### （8）自定义异常

``` C++
class divide_by_zero : public runtime_error {
public:
    divide_by_zero(const std::string &s)
        : runtime_error(s) {}
    virtual const char* what() const noexcept override {
        return runtime_error::what();
    }
};

int main() 
{
    int a = 1, b = 0;
    try {
        if(!b)  throw divide_by_zero("[ERROR]divide by zero: Floating pointe exception");
        int r = a / b;
    } 
    catch(runtime_error &e) {
        cout << e.what() << endl;
    }
    return 0;
}
```

### 2. 命名空间

大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发**命名空间污染（namespace pollution）**。

命名空间为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。

命名空间的结尾花括号不需要分号结尾。

#### （1）命名空间定义

##### 每个命名空间都是一个作用域

定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何对象访问。位于命名空间之外的代码则必须明确指出所有名字属于那个命名空间 `using namespace namespace_name;`。

##### 命名空间可以是不连续的

回想一下我们为某个自定义类型指定 hash 模板特例化时，此时 std 命名空间就是不连续的。

命名空间不连续这个特性也允许我们将命名空间中的成员的声明和定义分离，负责声明的命名空间放在头文件中，负责定义的命名空间部分则放在源文件中。

同样的，不同的命名空间也应该放在不同的文件中。

##### 定义命名空间成员

在通常情况下，我们不把 `#include` 放在命名空间内部。如果我们这么做了， 隐含的意思是把头文件中所有的名字定义成该命名空间的成员。

可以在命名空间的外部定义命名空间的成员，此时该成员必须使用含有命名空间前缀的名字。对于函数来说，命名空间成员的外部定义和类成员的外部定义类似，在名字处指定命名空间之后，参数列表以及函数体内就无需再指定命名空间前缀了：

``` c++
namespace prime {
    class Foo;
    Foo operator+(const Foo &lhs, const Foo &rhs);
}

// 只需要在类名处指定命名空间前缀
class prime::Foo {
public:
    Foo(int _val = 0) : val(_val) {}
    Foo& operator+=(const Foo& rhs);
    int get() const { return val; }
private:
    int val;
};

// 需要在返回类型和函数名处指定命名空间前缀
prime::Foo& prime::Foo::operator+=(const prime::Foo& rhs) {
    val += rhs.val;
    return *this;
}

// 需要在返回类型和函数名处指定命名空间前缀
prime::Foo prime::operator+(const Foo &lhs, const Foo &rhs)
{
    Foo res(lhs);
    return res += rhs;
}

int main() 
{
    prime::Foo a(10), b(20);
    a += b;
    cout << a.get() << endl; 
    cout << (a + b).get() << endl;
    return 0;
}
```

##### 模板特例化

模板特例化必须定义在原始模板所属的命名空间中。

``` c++
struct Foo {
    int val;
    bool operator==(const Foo &rhs) const {
        return val == rhs.val;
    }
};

// struct hash定义在命名空间std中
namespace std {
    template<>
    struct hash<Foo> {
        size_t operator()(const Foo &f) const {
            return hash<int>()(f.val);
        }
    };
}

int main() 
{
    unordered_set<Foo> s;
    s.insert({1});
    s.insert({1});
    s.insert({2});
    s.insert({3});
    for(auto &x : s)
        cout << x.val << endl;
    
    return 0;
}
```

##### 全局命名空间

全局作用域中定义的名字定义在全局命名空间（global namespace）中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字是被隐式地添加到全局命名空间中的。

由于全局作用域是隐式的，所以他没有名字：

``` c++
int x = 10;
int y = ::x; // 10
```

##### 嵌套的命名空间

``` C++
namespace outer {
    int x = 10;
    namespace inner {
        int y = x;
        double x = 3.14;
    }
    double z = inner::x;
}
```

嵌套的命名空间同时也是一个嵌套的作用域。它遵循一般的嵌套作用于的名字规则：

* 内层命名空间声明的名字将隐藏外层命名空间声明的名字
* 在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码想访问它必须在名字前添加限定符

##### 内联命名空间

C++11 新标准引入了一种新的嵌套命名空间（nested namespace），称为内联命名空间（inline namespace）。

与普通的嵌套命名空间不同，内联命名空间的名字可以被外层命名空间直接使用：

``` c++
namespace outer {
    int x = 10;
    inline namespace inner {
        int y = x;
    }
    int z = y;
}
```

关键字 inline 必须出现在命名空间第一次定义的地方，后续在打开命名空间时 inline 可有可无。

内联命名空间可以用于**版本发布**。例如，我么可以将当前版本的代码放在内联命名空间中，而之前的代码都放在一个非内联命名空间中。



##### 未命名的命名空间

未命名的命名空间就是没有名字的命名空间。未命名的命名空间中定义的变量拥有**静态生命周期**：他们在第一次使用前创建，并且直到程序结束才销毁。

``` C++
namespace {
    int x = 10;
    template<typename T>
    T get_self_value(const T &x) { return x; }
}

int main() 
{  
    cout << x << endl;
    cout << get_self_value(10) << endl;
    return 0;
}
```

我们可以直接使用未命名的命名空间中的成员，毕竟我们也找不到什么命名空间的名字来限定他们；同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。

另外我们也可以发现，未命名的命名空间的主要作用就是用于声明静态成员。事实上，**在 C++ 中，我们正是以未命名的命名空间取代文件中的静态声明。**

> 在标准 C++ 引入命名空间的概念之前，程序需要将名字声明成 static 以使其只对于整个文件有效。这种在文件中进行静态声明的做法是从 C 语言继承而来的。在 C 语言中，声明为 static的全局实体在其所在的文件外不可见。

也正因为用于文件内静态声明的特性，一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间，不同文件中的未命名的命名空间互相无关。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同的实体。

未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同：

``` C++
/*=====================================================*/
int val = 1024;

namespace {
    int val = 16;
}

int main() 
{  
    cout << val << endl; // "val" is ambiguous
    return 0;
}
/*=====================================================*/
int val = 1024;

namespace outer {
    namespace {
        int val = 16;
    }
}

int main() 
{  
    cout << val << endl;        // 1024
    cout << outer::val << endl; // 16
    return 0;
}
/*=====================================================*/
```

#### （2）使用命名空间成员

通过作用域运算符获取命名空间成员太过繁琐，下面是一些更为简便的使用命名空间成员的方法：

##### 命名空间别名

``` C++
namespace outer {
    namespace inner {
        int val = 10;
    }
}

// 通过namespace来制定别名
namespace space = outer::inner;

int main()
{
    cout << space::val << endl;
    return 0;
}
```

##### using声明

一条 using 声明语句一次只引入命名空间的一个成员。对于 using 声明引入的名字，我们可以直接使用而不需要再加上作用域标志。

using 声明引入的名字遵守与过去一样的作用域规则：它的有效范围从 using 声明的地方开始，一直到 using 声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。

``` C++
namespace outer {
    int val = 10;
}

void f()
{
    // outer::val不可见
    int val = 30;
    for(int i = 0; i < 3; i ++ ) {
        // int val = 20; // 会导致命名冲突
        using outer::val;
        cout << val << endl;
    }
    // outer::val不可见
}
```

一条 using 声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。

##### using指示

using 指示（using directive）和 using 声明类似的地方是，我们可以使用命名空间名字的简写形式；和 using 声明不同的是，我们无法控制那些名字是可见的，因为所有名字都是可见的。

using 指示以 using 关键字开始，后面是关键字 namespace 和命名空间的名字。这个命名空间必须是已经定义好的命名空间的名字，否则程序将发生错误。

##### using与作用域

我们先来看两个例子：

``` C++
int a = 1;

namespace A {
    int a = 11, b = 22, c = 33;
}

int main()
{
    using A::a;        // using 声明
    cout << a << endl; // 11
    return 0;
}

/*====================================*/

int a = 1;

namespace A {
    int a = 11, b = 22, c = 33;
}

int main()
{
    using namespace A; // using 指示
    cout << a << endl; // "a" is ambiguous
    return 0;
}
```

一样的代码，只是一个使用 using 声明，一个使用 using 指示，但结果天差地别。

我们前边提到过 using 声明的名字的作用域与 using 声明语句本身的作用域一直，效果上就好像 using 声明语句为命名空间的成员在当前作用域内创建了一个**别名**一样。

<font color=blue>但 using 指示所做的绝非声明别名这么简单。相反，**它具有将命名空间成员提升到包含命名空间本身和 using 指示的最近作用域的能力**。</font>由于命名空间一般是全局作用域，因此这里命名空间成员的名字通常都被提升为全局作用域。所以说，通过 using 指示引入命名空间成员是一种很危险的行为，它很容易导致命名冲突

#### （3）类、命名空间与作用域

##### 实参相关的查找与类类型参数

``` c++
std::string s;
std::cin >> s; // 等价于operator>>(std::cin, s);
```

`operator>>` 函数定义在标准库 string 中，string 又定义在命名空间 std 中，但是我们不需要 using 声明和 `std::` 限定符就可以调用该函数。

对于命名空间中名字的隐藏规则有一个重要的例外，它使得我们可以直接访问输出运算符。这里例外是，<font color=blue>当我们给函数传递一个**类类型的对象**时，除了在常规的作用域中查找外还会查找**实参类所属的命名空间**。这一例外对于传递类的引用或指针的调用同样有效。</font>

在此例中，当编译器发现对 operator>> 的调用时，首先在当前作用域寻找合适的函数，接着查找输出语句的外层作用域。随后，因为 >> 表达式的形参是类类型的，所以编译器还会查找 cin 和 s 的类所属的命名空间。也就是说，对于这个调用来说，编译器会查找定义了 istream 和 string 的命名空间 std。当在 std 中查找时，编译器找到了 string 的输出运算符函数。

查找规则的这个例外允许概念上作为类接口一部分的**非成员函数**无需单独的 using 声明就能被程序使用。加入该规则不存在，则我们将不得不为输出运算符专门提供一个 using 声明或使用命名空间限定符：

``` C++
using std::operator>>;
// 或者：
std::operator>>(std::cin, s);
```

显然上面两种形式都比较笨拙。

下面是一个具体的例子：

``` c++
namespace A {
    struct Foo {
        int val;
    };
    Foo operator+(const Foo &a, const Foo &b) {
        return Foo{a.val + b.val};
    }
    void print(const Foo &f) {
        cout << f.val << endl;
    }
}

int main()
{
    A::Foo a{10}, b{20};
    A::Foo c = a + b;
    // 无需加限定符或using声明就可以使用namespace A中的函数
    cout << c.val << endl; // 30
    print(c);              // 30
    return 0;
}
```

##### 查找与std::move和std::forward

前面我们提到过，对于 move（以及 forward 函数）的调用，要使用完全限定符的形式 `std::move` 和 `std::forward`。现在解释一下为什么：

因为标准库 move 和 forward 函数都是模板函数，它们都接受一个右值引用的函数形参。而在函数模板中，右值引用形参是万能匹配，它可以匹配任何类型。因此如果我们定义了一个 move 或 forward 函数，那么不管函数接受什么类型的参数，都会与标准库的版本冲突。

##### 友元声明与实参相关的查找

在友元中，我们提到过，当类声明了一个友元时，该友元声明并没有使得友元本身可见。然而，一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员。

``` c++
namespace A {
    class C {
        friend void f2();
        friend void f(const C&);
    };
}

int main()
{
    A::C objs;
    f(objs);
    f2(); // identifier "f2" is undefined
    return 0;
}
```

对于上面的例子，我们可以找到 `f` 的声明但找不到 `f2` 的声明。原因在“实参相关的查找与类类型参数”已经说明了，那就是对于 `f`，它还会查找 `objs` 所在命名空间 `A`。

#### （4）重载与命名空间

命名空间对函数的匹配过程有两方面的影响：

1. using 声明或 using 指示能将某些函数添加到候选函数集
2. 对于接受类类型参数的函数来说，其名字查找将在实参类所属的命名空间中进行

##### 重载与using声明

对于一个 using 声明来说，要注意**它声明的是一个名字，而非一个特定的函数**。因此对于 `using NS::print;` 来说，该函数的所有版本都被引入到当前作用域。

1. 一个 using 声明引入的函数将重载该声明语句所属作用域中其它已有的同名函数
2. 如果 using 声明出现在局部作用域当中，则引入的名字将隐藏外层作用域的相关声明
3. 如果 using 声明所在的作用域中已有一个同名且形参列表相同的函数，该 using 声明将引发错误

注意第 2 点所说的隐藏外层作用于的相关声明，是指隐藏外层作用于的所有声明，因为我们本质上是隐藏了外层作用域中的**“同名函数”**。而所有重载函数都是同名函数！

``` C++
namespace NS {
    void print(int x) { cout << "NS::int" << endl; }
}

void print(const char *x) { cout << "::const char *" << endl; }
void print(double x) { cout << "::double" << endl; }
void print(char ch) { cout << "::char" << endl; }

int main()
{
    using NS::print; // 隐藏全局作用于中的三个print函数
    print(1);        // NS::int
    print('a');      // NS::int
    print("hello");  //argument of type "const char *" 
        // is incompatible with parameter of type "int
    return 0;
}
```

##### 重载与using指示

using 指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的某个函数同名，则命名空间的函数被添加到重载集合中。

与 using 声明不同的是，对于 using 指示来说，引入一个已有函数形参列表完全相同的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可：

``` c++
namespace NS {
    void print(const char *x) { cout << x << endl; }
    void print(double x) { cout << x << endl; }
    void print(int x) { cout << x << endl; }
    int val = 10;
}

// 使用using指示如果出现同名同形参列表的函数
// 在声明处并不会报错
// 普通变量也是
int val = 10;
void print(int x) { cout << x << endl; }
using namespace NS;

int main()
{
    ::print(::val);
    NS::print(NS::val);
    return 0;
}

/*=====================================================*/

namespace NS {
    void print(const char *x) { cout << x << endl; }
    void print(double x) { cout << x << endl; }
    void print(int x) { cout << x << endl; }
    int val = 10;
}

int val = 10;
void print(int x) { cout << x << endl; }
using NS::print; // conflicits
using NS::val;      // conflicits
```

### 3. 多重继承与虚继承

使用多重继承时要十分小心，经常会出现二义性问题。

许多专业人员认为：**不要提倡在程序中使用多重继承**，只有在比较简单和不易出现二义性的情况或实在必要时才使用多重继承，能用单一继承解决的问题就不要使用多重继承。也是由于这个原因，有些面向对象的程序设计语言(如Java，Smalltalk)并不支持多重继承。

#### （1）多重继承

每个基类包含一个可选的访问说明符。如果忽略，class 默认为 private，struct 默认为 public。

和单继承一样，多重继承的派生列表也只能包含已经被定义的类，而且这些类不能是 final 的。C++ 并没有对最大继承个数做出限制，但在某个给定的派生列表中，同一个基类只能出现一次。

##### 派生类构造函数初始化所有基类

和单继承一样：

* 构造一个派生类的对象将同时构造并初始化它的所有基类子对象
* 多重继承的派生类的构造函数初始值也只能初始化它的直接基类
*  基类的构造顺序与派生列表中基类出现的顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。

##### 继承的构造函数与多重继承

C++11 新标准中，允许派生类从它的一个或多个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：

``` C++
struct B1 {
    B1() = default;
    B1(int x) {}
};

struct B2 {
    B2() = default;
    B2(int x) {}
};

struct D : public B1, public B2 {
    using B1::B1;   // 引入B1的构造函数
    using B2::B2;   // 引入B2的构造函数

};

int main()
{
    D d(10);
    return 0;
}

// more than one instance of constructor "D::D" matches the argument list:C/C++(309)
// main.cpp(29, 9): function "B1::B1(int x)" (declared at line 12), inherited via using decl at line 21
// main.cpp(29, 9): function "B2::B2(int x)" (declared at line 17), inherited via using decl at line 22
// main.cpp(29, 9): argument types are: (int)
```

其实通过“继承”的构造函数的原理我们可以更清晰的观察出来，当我们引入 B1 和 B2 的构造函数时，编译器实际上会为 D 生成两个构造函数：

``` c++
struct D : public B1, public B2 {
    D(int x) : B1(x) {}
    D(int x) : B2(x) {}
    // 参数列表完全相同，重复定义错误
};
```

此时我们必须自定义重复定义的函数，例如：

``` c++
struct D : public B1, public B2 {
    D(int x) : B1(x), B2(x) {}
};
```

##### 析构函数与多重继承

和单继承一样，析构函数只需要负责清除类本身分配的资源即可，派生类的资源以及基类都是自动销毁的。合成的析构函数函数体为空。

##### 多重继承的派生类的拷贝和移动操作

与单继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作。即，我们要确保这些操作的“完整性”，对于派生类的拷贝、移动或赋值操作而言，你不能仅仅只完成派生类对象的拷贝、移动或赋值，还需要完成其直接基类部分的拷贝、移动和赋值。

因为对于自定义的拷贝、移动和赋值成员，在执行时不会调用直接基类的对应成员。只有当派生类使用的是合成版本的拷贝、移动和赋值成员时，才会自动对其基类执行这些操作，即每个基类分别使用自己的对应成员隐式的完成构造、移动和销毁等操作。

``` c++
struct B1 {
    B1() = default;
    B1(B1&) {
        puts("B1::B1");
    }
};

struct B2 {
    B2() = default;
    B2(B2&) {
        puts("B2::B2");
    }
};

struct D : public B1, public B2 {
    D() = default;

};

int main()
{
    D a;
    // 由于我们没有自定义D的拷贝构造函数
    // 因此会为D合成一个拷贝构造函数
    // 对于D的拷贝构造,会隐式调用基类的对应成员
    D b(a);
    return 0;
}
// B1::B1
// B2::B2

/*=====================================================*/

struct B1 {
    B1() = default;
    B1(B1&) {
        puts("B1::B1");
    }
};

struct B2 {
    B2() = default;
    B2(B2&) {
        puts("B2::B2");
    }
};

struct D : public B1, public B2 {
    D() = default;
    D(D&) {
        puts("D::D");
    }
};

int main()
{
    D a;
    // 由于我们自定义了D的拷贝构造函数
    // 因此这里只会执行D的拷贝构造函数的函数体
    D b(a);
    return 0;
}
// D::D
```

#### （2）类型转换与多个基类

和单继承一样，在多继承体系中，基类的指针和引用可以接受一个派生类对象。

值得注意的是，编译器不会在派生类向**直接基类**的几种转换中进行比较和选择，因为在它看来转换到任意一种**直接基类**都一样好：

``` c++
struct B {};
struct B1 : public B {};
struct B2 {};
struct D : public B1, public B2 {};

void print(B&) { puts("B"); }
void print(B1&) { puts("B1"); }

int main()
{
    D d;
    print(d); // B1
    return 0;
}

/*===================================================*/

struct B {};
struct B1 : public B {};
struct B2 {};
struct D : public B1, public B2 {};

void print(B2&) { puts("B2"); }
void print(B1&) { puts("B1"); }

int main()
{
    D d;
    print(d); // ambigous
    return 0;
}
```

##### 基于指针类型或引用类型的查找

与单继承一样，对象、指针和引用的静态类型决定了我们能够使用那些成员。特殊的，当类型是指针或引用，调用函数是虚函数时，会进行类型动态绑定。

#### （3）多重继承下的类作用域

在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。

在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的“使用”将具有二义性。只有在“使用”时具有二义性意味着，对于一个派生类来说，从它的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出他的版本：

``` c++
struct B {
    int max_weight() {
        return 0;
    }
};

struct B1 : public B {
};

struct B2 {
    int max_weight() {
        return 1;
    }
};

struct D : public B1, public B2 {
};

int main()
{
    D d;
    cout << d.max_weight() << endl; // ambiguous
    return 0;
}
```

> 注意，这里 D 直接继承自 B1 和 B2，而 B1 又直接继承自 B，因此 B 中的函数也会包含在 B1 中，所以在 D 中，max_weight 函数分别在 B1 和 B2 中有定义。

和往常一样，编译器会先查找名字在进行类型匹配。因此即使两个基类中的同名函数参数列表不同，编译器也会报二义性错误：

``` c++
struct B {
    int max_weight() {
        return 0;
    }
};

struct B1 : public B {
};

struct B2 {
    int max_weight(int x) {
        return x;
    }
};

struct D : public B1, public B2 {
};

int main()
{
    D d;
    // B2中的max_weight和B1中继承自B的max_weight参数列表不相同
    cout << d.max_weight(1) << endl; // ambiguous
    return 0;
}
```

我们可以通过指明限定符来调用特定的版本，但最好的做法是在派生类中为该函数定义一个型版本：

``` c++
struct B {
    int max_weight() {
        return 0;
    }
};

struct B1 : public B {
};

struct B2 {
    int max_weight(int x) {
        return x;
    }
};

struct D : public B1, public B2 {
    // 定义D自己的版本，从而隐藏直接基类中的同名函数
    int max_weight(int x) {
        return max(B1::max_weight(), B2::max_weight(x));
    }
};

int main()
{
    D d;
    cout << d.max_weight(-1) << endl; // 0
    return 0;
}
```

#### （4）虚继承

尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。即，派生类可以通过它的多个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后再间接继承该类。典型的例如 C++ IO 标准库的 iostream。

``` C++
struct B {
    int val;  
};

struct B1 : public B {
};

struct B2 : public B {
};

struct D : public B1, public B2 {
    
};

int main()
{
    D d;
    // 这里通过B1和B2继承了两份B,因此D中包含两个int变量
    cout << sizeof(d) << endl; // 8
    return 0;
}
```

基类每出现一次就意味着派生类中有一份它的拷贝，这显然不是我们想要的。除了空间上的浪费外，还会导致二义性等比较严重的问题，因此我们一般称在派生类中有多份拷贝的基类为<font color=blue>“二义基类”</font>。例如使用该基类的成员，显然会导致二义性错误，还有一些不容易察觉的错误例如将一个派生类对象传给二义基类的指针或引用：

``` C++
struct B {
    int val = 10;  
};

struct B1 : public B {
};

struct B2 : public B {
};

struct D : public B1, public B2 {
    void func() {
        // cout << val << endl; // ambiguous
        cout << B1::val << endl; // 10
        cout << B2::val << endl; // 10
    }
};

int main()
{
	// base class "B" is ambiguous
    B *b = new D();
    return 0;
}
```

和非虚的多重继承体系一样，虽然我们可以通过限定符来获取指定的成员，但解决这种二义性问题的最好的方法是通过在派生类中为成员自定义新的实例。

C++ 语言中通过**虚继承（virtual inheritance）**机制解决基类被多次继承的问题。<font color=blue>虚继承的目的是令某个类做出说明，承诺愿意**共享它的基类**。其中，共享的基类子对象称为**虚基类**。</font>在这种机制下，无论虚基类在继承体系中出现多少次，在派生类都只包含唯一一个共享的虚基类子对象。

我们指定虚基类的方式是在派生列表中添加关键字 virtual，在继承列表中添加 virtual 说明，符合其名字“virtual 继承”。

通常，为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类。否则仍然会出现对基类的多次继承。例如：
``` c++
struct A {};
struct B : virtual A {};
struct C : virtual A {};
struct D : A {};
struct E : A, B, C, D {}
```

在上面的例子中，虽然我们在 B 和 C 中虚继承 A，但是在 D 中我们不是虚继承的，因此当 E 直接继承 A,B,C,D 时 A,B,C 共享一份 A 的成员，D 单独保留一份 A 的成员。

另外就是虚继承有一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。简而言之，我们无法预知未来，因此我们实际上并不清楚未来是否有虚继承的需求。例如我们有：

``` C++
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : B1, B2 {};
```

只有当定义 D 时才有对虚继承的需求，但如果 B1 和 B2 不是从 B 虚继承得到的，那么 D 的设计者就显得不太幸运了！

不过在实际的编程过程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次一般是由一个人或一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个是虚基类，况且新基类的开发者也无法改变已存在的类体系。

最后，虚基类是相当于虚继承的派生类而言的。即，对于虚继承的派生类而言，虚继承的基类是虚基类；但如果这个基类也被其他类普通继承，那么它就不是虚基类了。

#### （5）构造函数和虚继承

在普通的继承体系中，我们只能在派生类的构造函数中初始化其直接基类。<font color=blue>但在虚继承体系中，为了避免虚基类被重复初始化，我们规定虚基类应该由最低层的派生类初始化。</font>例如：B1 和 B2 都虚继承自 B，A 继承自 B1 和 B2，如果我们讲虚基类 B 的初始化工作交给 A 的直接基类 B1 和 B2，那么就会导致 B 重复初始化。因此，<font color=blue>只要我们能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。如果我们没有在最低层派生类显示初始化其虚基类，会调用虚基类的默认构造函数；如果虚基类没有默认构造函数，则代码发生错误</font>

e.g. 在非虚基成体系下，我们不能在派生类中初始化间接基类：

``` C++
struct B {
    B() = default;
    B(int _b) : b(_b) {}
    int b;
};
struct B1 : B {
    B1() = default;
    B1(int _b, int _b1) : B(_b), b1(_b1) {}
    int b1;
};
struct B2 : B {
    B2() = default;
    B2(int _b, int _b2) : B(_b), b2(_b2) {}
    int b2;
};
struct A : B1, B2 {
    A(int _b, int _a) 
// indirect nonvirtual base class is not allowed
        : B(_b), a(_a) {}
    int a;
};s
```

在虚基成体系下可以：

``` c++
struct B {
    B(int _val=-1) :val(_val) {puts("B");}
    int val;
};

struct B1 : virtual B {
    B1() : B(1) {puts("B1");}
};

struct B2 : virtual B {
    B2() : B(2) {puts("B2");}
};

struct C : B1, B2 {
    C() : B1(), B2() {puts("C");}
};

// B
// B1
// B2
// C
// -1
```

在上面的代码中，在 C 中我们使用其直接基类 B1 和 B2 的构造函数来完成初始化，看起来好像我们会在 B1 和 B2 中分别对 B 调用构造函数 B(1) 和 B(2)。但其实这两个构造函数都不会被调用，因为我们会在 C 中调用 B 的默认构造函数从而完成 B 的初始化工作。然后再调用 B1 和 B2 的构造函数时，由于 B 已经完成了初始化，此时便不会再调用 B 的构造函数。

##### 虚继承的对象的构造方式

含有虚基类的对象的构造顺序与一般的顺序稍有不同：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来直接按照基类在派生列表中出现的次序依次对其进行初始化。

这意味着，虚基类总是先于非虚基类构造，与他们在基成体系中的次序和位置无关。

> 注意如果虚基类还继承自某些基类，那么虚基类的构造函数还是先调用其直接基类的构造函数。

这样可以保证虚基类只会被初始化一次，从上一节最后的例子可以看出来：在 C 的初始化工作中，最先初始化虚基类 B，然后才是其直接基类 B1 和 B2。

##### 构造函数与析构函数的次序

一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左到右依次构造。接下来就是直接按照基类在派生列表中出现的次序依次对其初始化了。

和往常一样，对象的析构顺序和构造顺序正好相反。

## 十三、特殊工具与技术

C++ 的语言设计者希望它能够处理各种各样的问题。因此，C++ 的某些特征对于一些特殊的应用非常重要，而在另外一些情况下没什么作用。

### 1. 控制内存分配

#### （1）重载 new 和 delete

尽管我们说能够重载 new 和 delete 表达式，但是实际上重载这两个运算符与重载其它运算符的过程大不相同。我们首先需要知道一条 new 或 delete 表达式实际上做了什么事情：

``` c++
// T *p = new T(args);
void *mem = operator new(sizeof T); // 1.分配内存
mem->T(args);					    // 2.构造对象
T *p = static_cast<T*>(mem);		// 3.返回指针
// delete p;
p->~T();							// 1.销毁对象
operator delete(p);				    // 2.释放内存
```

> 对于 new[] 和 delete[]，其底层是调用 operator new[] 和 operator delete[]。

由此可见，new 和 delete 的执行实际上是依赖于 operator new 和 operator delete 来管理内存的。当编译器发现一条 new 表达式或 delete 表达式后，将在程序中查找可调用的 operator 函数。我们也可以通过作用域运算符来显式指定我们想要调用的 operator 函数版本（类版本或者全局版本）。

> **⚠⚠⚠ 由此可见，对 operator new 和 operator delete 的重载特别是全局作用于下，影响是深远的。**

因此如果我们想要重载 new 和 delete 以实现对内存分配和释放的管理，需要重载 operator new 和 operator delete。并且，对于某个重载版本，即使标准库中存在了这个函数的定义，编译器依然允许我们定义自己的版本，并且使用自己一的版本替换标准库定义的版本。

本质上我们并不能“重载” new 和 delete 表达式，我们重载的是其内部调用的 operator 函数。事实上，我们根本无法自定义 new 表达式和 delete 表达式的行为。

#### （2）operator 接口

标准库定义了 operator new 函数和 operator delete 函数的 8 个重载版本。其中前 4 个可能抛出 bad_alloc 异常，后 4 个版本则不会抛出异常：

``` C++
void* operator new(size_t);
void* operator new[](size_t);
void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;

void* operator new(size_t, nothrow_t&) noexcept;
void* operator new[](size_t, nothrow_t&) noexcept;
void operator delete(void*, nothrow_t&) noexcept;
void operator delete[](void*, nothrow_t&) noexcept;
```

> 当然现在肯定不止 8 个

用户程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于全局作用域或类作用域中。当我们将 operator new 或 operator delete定义为类的成员函数时，他们是<font color=blue>**隐式静态**</font>的，而且他们不能操作类的任何数据成员。

> 因为 operator new 发生在构造函数之前，而 operator delete 发生在析构函数之后。正因为 operator new 和 operator delete 发生在构造函数之前，析构函数之后，因此它们只能是静态函数。并且不能操纵类的任何任何数据成员。

##### 2.1 operator new

对于 operator new 函数或者 operator new[] 函数来说，它的返回类型必须是 void\*，第一个形参的类型必须是 size\_t 且该形参不能含有默认实参。当我们调用这两个函数时，编译器会把存储指定类型对象或数组所需的字节数传给 size_t 参数。

如果我们想要自定义 operator new 函数，可以为它提供额外的形参。此时，用到这些自定义函数的 new 表达式必须使用 new 的定位形式将实参传递给新增的形参。尽管我们在一般情况下可以自定义具有任何形参的 operator new，但下面这个函数却无论如何不能被用户重载：

``` C++
void *operator new(size_t, void*);
```

这种形式只供标准库使用，不能被用户重新定义。事实上，这种形式的 new 又称为 placement new，placement 指的是对象构造的位置，该函数用来在特定的位置上“放置”对象。使用 `placement new`，我们可以在已经分配好的内存中调用对象的构造函数，这样可以避免额外的内存分配开销，直接在指定的位置上构造对象。

所以说，placement new 区别于其它 operator new，它用来构造对象而不是分配内存。

##### 2.2 operator delete

operator delete 和 operator delete[] 的返回类型必须是 void，第一个形参的类型必须是 void\*。编译器用指向待释放内存的指针来初始化 void\* 参数。

**当我们将 operator delete 或 operator delete[] 定义成类的成员时，该函数可能包含另外一个类型为 size\_t 的形参。**此时，该形参的初始值第一个形参所指对象的字节数。size\_t 形参可用于删除继承体系中的对象。**如果基类有一个虚析构函数，则传递给 operator delete 的字节数将因待删除指针所指向对象的动态类型不同而有所区别（基类指针可能指向一个派生类对象）。**而且，实际运行的 operator delete 函数版本也由对象的动态类型决定。

和类的析构函数一样，涉及内存释放的操作不应该返回异常，因此重载 operator delete 应该在可以时添加 `noexcept`。

operator new 和 operator delete 归根结底还是使用 C 库函数 malloc 和free 来实现内存的分配和释放的。他们定义在 `cstdlib` 头文件中。

* malloc 函数接受一个表示待分配字节数的 size\_t，返回指向分配内存的指针或 0 表示分配失败。
* free 函数接受一个 void\*，它是 malloc 返回的指针的副本，free 将相关内存返回给系统。

free 一个空指针即 `free(0)` 是安全地，但也没有任何意义，它仅仅是为了编程上的方便。

``` C++
void *operator new(size_t size) 
{
    puts("call operator new");
    if(void *mem = malloc(size))
        return mem;
    throw bad_alloc();
}

void operator delete(void *mem) noexcept 
{
    puts("operator delete");
    free(mem);
}
```

#### （3）operator delete 的重载

有意思的一点是，虽然我们可以为 operator delete 指定带额外参数的重载版本，但编译器不会调用也无法调用该版本：

``` C++
void* operator new(size_t size, string s)
{
    cout << "call operator new: " << s << endl;
    if(void *mem = malloc(size))
        return mem;
    throw bad_alloc();
}

void operator delete(void *mem, string s) noexcept 
{
    cout << "call operator delete: " << s << endl;
    free(mem);
}

int main()
{
    int *p2 = new("int") int(1024);
    cout << *p2 << endl;
    delete("int") p2; // error: expected ‘;’ before ‘p2’
    return 0;
}
```

这可能是以下几方面导致的：

1. 避免运行时开销：如果 `delete` 要支持带参数的 `operator delete`，则编译器需要在构造时保存额外的参数信息，并在析构时解析并传递这些参数，这样会带来额外的内存开销和复杂的编译期逻辑。而 C++ 语言设计上是非常注重性能的，尤其在低级内存管理方面，所以简化 `delete` 以仅支持无参数的 `operator delete` 可以避免额外的运行时开销。
2. 确保 delete 操作的设计保持简单：在 C++ 中，`operator new` 可以支持 placement new 或其他带参数的形式，为特定用途（如内存池、特定地址分配等）提供灵活性。但对于 `delete` 操作，C++ 设计更倾向于保持简单，减少依赖，开发者可以通过自定义释放函数或其他内存管理策略来满足更复杂的需求。例如：智能指针与自定义删除器，自定义释放函数等。

#### （4）placement new

> placement new 用于在**已分配**的内存上**构造对象**，它允许我们手动指定对象的内存地址，从而在特定的内存区域上直接构造对象。它通常用于内存池、嵌入式编程或性能敏感的代码中。

尽管 operator new 和 operator delete 函数一般用于 new 表达式，但他们毕竟是标准库的两个普通函数，因此普通的代码也可以直接的调用它们。

在 C++ 的早期版本中，allocator 类还不是标准库的一部分。应用程序如果想把内存分配与初始化分离开来的话，需要调用 operator new 和 operator delete。这两个函数的行为与 allocator 的 allocate 成员和 deallocate 成员非常类似，它们负责分配或释放空间，但是不会构造或销毁对象。

与 allocator 不同的是，对于 operator new 分配的空间我们无法使用 construct  函数构造对象。相反，我们应该使用 new 的**定位 new（placement new）**形式构造对象。我们可以使用 placement new  传递一个地址，此时 placement new 的形式如下：

``` C++
// operator new(size,void*);
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size]
new (place_address) type [size] {braced initializer list}
```

其中 place\_address 必须是一个指针（地址），同时在 initializer 中提供一个（可能为空的）以逗号分隔的初始值列表，用于构造新分配的对象。

当仅通过一个地址值调用时，placement new 使用 `operator new(size_t,void*)` “分配”它的内存。这是一个我们无法自定义的 operator new 版本。该函数不分配任何内存，他只是简单的返回指针实参；然后由 new 表达式负责在给定的地址初始化对象以完成整个工作。<font color=blue>事实上，**placement new** 允许我们在一个**特定的**、**预先分配**的内存地址上**构造对象**。</font>

尽管在很多时候使用 placement new 与 allocator 的 construct 成员非常类似，但它们之间也有一个重要的区别。我们传给 construct 的指针必须指向同一个 allocator 对象分配的空间，但是传给 placement new 的指针无需指向 operator new 分配的内存。事实上，这块内存也不必是动态分配在堆上的内存，它也可以是栈上的内存，只要是一块“有效的内存”即可。

``` c++
int val;
new(&val) int(1024);
cout << val << endl; //1024

string s;
new(&s) string("hello");
cout << s << endl; //hello
s.~string();
new(&s) string("world");
cout << s << endl; //world

int *p = new int;
new(p) int(16);
cout << *p << endl; //16
new(p) int(256);
cout << *p << endl; //256
```

#### （5）显示调用析构函数

我们既可以通过类对象调用析构函数，也可以通过对象的指针或引用调用析构函数。显示调用析构函数与显示调用其它成员函数并无区别。析构函数只会销毁对象但不会释放内存。

### 2. 运行时类型识别

运行时类型识别（run-time type identification，RTTI）的功能由两个运算符实现：

* typeid 运算符，用于返回表达式的类型
* dynamic_cast 运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用

当我们将这两个运算符用于某种类型的**指针或引用**，并且该类型含有**虚函数**时，运算符将使用指针或引用所绑定对象的**动态类型**。

> 运行时类型识别本质上就是“动态绑定”，因此对象类型需要是指针或引用，还需要有虚函数。

这两个运算符特别适用于以下情况：**我们想使用基类的指针或引用执行某个派生类操作而且该操作不是虚函数。**因为一般来说，当我们通过指针或引用所调用的函数不是虚函数时，是不会执行动态绑定的。此时，我们可以使用 RTTI 运算符。

#### （1）dynamic_cast 运算符

``` c++
// type必须是一个类类型，而且在通常情况下该类型应该含有虚函数
dynamic_cast<type*>(e);
dynamic_cast<type&>(e);
dynamic_cast<type&&>(e);
```

在上面的所有形式中，e 的类型必须符合以下三个条件中的任意一个：

1. e 的类型是目标 type 的公有派生类
2. e 的类型是目标 type 的公有基类
3. e 的类型是目标 type 的类型

如果类型符合，则可以转换成功；否则，转换失败。如果一条 dynamic_cast 语句的转换目标是指针并且转换失败了，则结果为 0；如果转换目标是引用类型并且失败了，则 dynamic_cast 运算符将抛出一个 bad_cast 异常。

##### 1.1 指针类型的 dynamic_cast

> 将一个基类对象提升为派生类对象是一个合理的需求，因为不是所有的派生类都包含其专属的数据成员，也有可能仅仅比派生类多了一些函数功能接口。

假定 Base 类至少含有一个虚函数，Derived 是 Base 的公有派生类。如果有一个指向 Base 的指针 bp，则我们可以在运行时将它转换成指向 Derived 的指针：

``` C++
if(Derived *dp = dynamic_cast<Derived*>(bp)) {
    // 转换成功,使用dp指向的Derived对象
}
else {
    // 转换失败,使用bp指向的Base对象
}
```

> 我们可以对一个空指针执行 dynamic_cast，结果是所需类型的空指针。

在代码中，我们在条件部分定义了 dp，这么做有两个好处：

1. 在一个操作中同时完成类型转换和条件检查两项任务。
2. 指针 dp 在 if 语句之外是不可访问的。这意味着，一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到这个未绑定的指针，从而确保程序是安全地。

##### 引用类型的 dynamic_cast

引用类型的 dynamic_cast 与指针类型的 dynamic_cast 在表示错误发生的方式上略有不同。这是因为指针和引用对于“NULL”这一概念的处理不同，因为不存在所谓的空引用，所以对于引用类型来说无法使用与指针类型完全相同的错误报告策略。当对引用的类型转换失败时，程序抛出一个名为 std::bad_cast 的异常，该异常定义在 `typeinfo` 头文件中。

``` c++
void f(const Base &b)
{
    try {
        const Derived &d = dynamic_cast<const Derived&>(b);
    } 
    catch(bad_cast e) {
        cout << e.what() << endl;
    }
}
```

#### （2）typeid 运算符

为 RTTI 提供的第二个运算符是 typeid 运算符，它允许向程序表达式提问：你的对象是什么类型。

typeid 表达式的形式是 `typeid(e)`，其中 e 可以是任意表达式或类型的名字。typeid 操作的结果是一个**常量对象的引用**，该对象的类型是标准库类型 type\_info  或 type\_info 的公有派生类型。type\_info 类定义在 `typeinfo` 头文件中。

typeid 运算符可以作用于任意类型的表达式，和往常一样，顶层 const 会被忽略。如果表达式是一个引用，则 typeid 返回该引用索引对象的类型。值得注意的是，typeid 作用域数组或指针时，并不会执行向指针的标准类型转换。也就是说，我们对数组 a 执行 typeid(a)，则所得结果是数组类型而非指针类型：

``` C++
int a[3];
cout << typeid(a).name() << endl; //A3_i
cout << typeid(3).name() << endl; //i
```

当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid 运算符的结果是对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid 的结果直到运行时才会求得：

``` C++
struct Base {
    virtual ~Base() {}
};

struct Derived : public Base {
    virtual ~Derived() {}
};

#define type_name(x) cout << typeid(x).name() << endl;

int main()
{
    Base *p = new Derived();
    type_name(*p); //7Derived
    return 0;
}
```

**typeid 是否需要运行时检查类型决定了表达式是否会被求值。**只有当类函数含有虚函数时编译器才会对表达式求值；反之，如果类型不含有虚函数，则 typeid 运算符返回表达式的静态类型，对于静态类型编译器不需要求值也能得到。

另外，运行时检查类型需要求值的特性意味着，如果我们使用了 `typeid(*p)`，需要确保 `*p` 是恶合法的。如果 p 是一个空指针，则 typeid(\*p) 将抛出一个名为 bad_typeid 的异常：

``` C++
struct Base {
    Base(int _val = 0) : val(_val) {}
    virtual ~Base() {}
    int val;
};

struct Derived : public Base {
    Derived(int _val = 0) : Base(_val) {} 
    virtual ~Derived() {}
};

#define type_name(x) cout << typeid(x).name() << endl;

int main()
{
    Base *p = nullptr;
    type_name(*p); //terminate called after throwing an instance of 'std::bad_typeid'
    return 0;
}
```

虽然我们可以通过 typeid 运算符来获取某一对象的类型，但是大多数情况下获取的类型信息比较“晦涩”，看起来不直观。更多的情况是使用 typeid 运算符来判断两条表达式的类型是否相同或一条表达式的类型是否与指定类型相同。

#### （3）type\_info 类

type\_indo 类的精确定义随着编译器的不同而略有差异。不过，C++ 标准规定 type\_info 类必须定义在 `typeinfo` 头文件中，并且至少提供以下操作：

``` C++
t1 == t2; //如果type_info对象t1和t2表示同一种类型，返回true；
t1 != t2; //否则返回false
t.name(); //返回一个C风格字符串,表示类型名字的可打印形式
		  //名字生成的规则因系统而异
t1.before(t2) //返回一个bool值，表示t1是否在t2之前。
    		  //before所采用的顺序关系时依赖于编译器的
```

除此之外，因为 type\_info 类一般是作为一个**基类**出现，所以他还应该提供一个共有的虚析构函数。当编译器希望提供额外类型信息的时候，通常在 type\_info 的派生类中完成。

type\_info 类没有默认构造函数，而且它的拷贝构造函数和移动构造函数以及赋值运算符都被定义成删除的。因此，我们无法定义或拷贝 type_info 类型的对象，更也不能为其赋值。**创建 type\_info 对象的唯一途径是使用 typeid 运算符。**

```` C++
struct Base {
    Base(int _val = 0) : val(_val) {}
    virtual ~Base() {}
    int val;
};

struct Derived : public Base {
    Derived(int _val = 0) : Base(_val) {} 
    virtual ~Derived() {}
};

#define type_name(x) cout << typeid(x).name() << endl;

int main()
{
    Base *p = new Derived;
    type_name(*p);           // 7Derived
    type_name(p);            // P4Base
    type_name(char);         // c
    type_name(short);        // s
    type_name(int);          // i
    type_name(unsigned int); // j
    type_name(double);       // d
    type_name(long long);    // x
    type_name(string);       // NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
    type_name(int*);         // Pi
    return 0;
}
````

type\_info 类在不同的编译器上有所区别。有的编译器提供了额外的成员函
数以提供程序中所用类型的额外信息。读者应该仔细阅读你所用编译器的使用
手册，从而获取关于 type\_info 的更多细节。

#### （4）使用 RTTI

在某些情况下 RTTI 非常有用，比如当我们想为具有继承关系的类实现相等运算符时。对于两个对象来说，如果它们的类型相同并且对应的数据成员取值相同，则我们说这两个对象是相等的。在类的继承体系中，每个派生类负责添加自己的数据成员，因此派生类的相等运算符必须把派生类的新成员考虑进来。一种容易想到的解决方案是定义一套虚函数，令其在继承体系的各个层次上分别执行相等性判断。此时，我们可以为基类的引用定义一个相等运算符，该运算符将它的工作委
托给虚函数 equal，由equal 负责实际的操作。

遗憾的是，上述方案很难奏效。虚函数的基类版本和派生类版本必须具有相同的形参类型。如果我们想定义一个虚函数 equal，则该函数的形参必须是基类的引用。此时，equal 函数将只能使用基类的成员，而不能比较派生类独有的成员。

要想实现真正有效的相等比较操作，我们需要首先清楚一个事实：即如果参与比较的两个对象类型不同，则比较结果为 false。例如，如果我们试图比较一个基类对象和一个派生类对象，则 == 运算符应该返回 false。基于上述推论，我们就可以使用 RTTI 解决问题了。我们定义的相等运算符的形参是基类的引用，然后使 typeid 检查两个运算对象的类型是否一致。如果运算对象的类型不一致，则 == 返回 false；类型一致才调用equal函数。每个类定义的equal 函数负责比较类型自己的成员。这些运算符接受 Base& 形参，但是在进行比较操作前先把运算对象转换成运算符所属的类类型。

``` C++
class Base {
    friend bool operator==(const Base&, const Base&);
public:
    Base(int _ival) : ival(_ival) {}
protected:
    virtual bool equal(const Base&) const;
    int ival;
};

class Derived : public Base {
public:
    Derived(int _ival, string _sval) : Base(_ival), sval(_sval) {}
protected:
    bool equal(const Base&) const;
    string sval;
};

bool operator==(const Base &lhs, const Base &rhs)
{
    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}

bool Base::equal(const Base& x) const
{
    return ival == x.ival;
}

bool Derived::equal(const Base& x) const
{
    auto y = dynamic_cast<const Derived&>(x);
    return ival == y.ival && sval == y.sval;
}

#define println_is_equal(x, y) \
    cout << boolalpha << (x == y) << noboolalpha << endl;

int main()
{
    Base b1(10), b2(20), b3(10);
    println_is_equal(b1, b3); // true
    println_is_equal(b2, b3); // false

    Derived d1(10, "hello"), d2(10, "fuck"), d3(10, "hello");
    println_is_equal(d1, d3); // true
    println_is_equal(d2, d3); // false

    return 0;
}
```

### 3. 枚举类型

枚举类型将一组整形常量组织在一起。和类一样，每个枚举类型定义了一种**新的类型**。枚举属于**字面值常量类型**。

C++ 包含两种枚举：限定作用域的（C++ 11引入）和不限定作用域的。

* 定义限定作用域的枚举类型需要在 enum 后面跟 class（或 struct），名字不能为空。
* 定义不限定作用域的枚举类型时忽略掉关键字 class（或 struct），枚举类型的名字是可选的。如果 enum 是未命名的，则我们只能在定义该 enum 时定义它的对象，我们可以将未命名的 enum 视为一种名字为 `unnamed` 的 enum。

#### （1）枚举定义新的类型

和 class 一样，enum 也定了新的类型。因此只要 enum 有名字，我们就能定义并初始化该类型的成员。想要初始化 enum 对象或为 enum 对象赋值，必须使用该类的一个枚举成员或者该类型的另一个对象。不同类型之间不可以互相赋值：

``` C++
enum color {BLUE, RED}; // color枚举
enum SIX {MAN, WOMAN};	// six枚举
enum {TRUE, FALSE}; 	// unnamed枚举

// color c1 = MAN; // type convert error
// color c2 = TRUE; // type convert error 
color c3 = BLUE;
color c4 = c3;
color c5 = 0; // 错误：0不能转换为BLUE
```

一个**[不限定作用域]的枚举类型的对象或枚举成员**自动的转换为整形。因此，我们可以在任何需要整型值的地方使用它们：

``` c++
int v1 = RED;//正确：不限定作用于的枚举类型的枚举成员隐式的转换为int
int v2 = SIX::MAN;//错误：限定作用域的枚举类型不会进行隐式转换
int v3 = static_cast<int>(SIX::MAN); //正确：强制类型转化
color c = RED;
int v4 = c;
```

当我们将一个枚举成员传给整形参数时，enum 的值会被提升为 int 或更大的整形，实际提升的结果由枚举类型的潜在类型决定：

``` C++
enum Bool : bool {TRUE, FALSE};
enum Color {RED, BLUE, GREEN};
enum Vals : unsigned char {V1, V2, V3};

void f(int x) {puts("int");}
void f(unsigned char c) {puts("uchar");}
void f(unsigned long long l) {puts("llong");}

int main()
{
    f(Bool::TRUE); // int 
    f(Color::RED); // int 
    f(Vals::V1);   // uchar
    return 0;
}
```

同样的，由于枚举是一种类型，我们也可以通过作用域运算符来访问枚举的成员：

* 对于限定了作用域的枚举类型，我们只能通过作用域运算符来访问其枚举成员。
* 对于未限定作用域的枚举类型，我们既可以直接访问，也可以通过作用域运算符来访问。

``` c++
enum color {BLUE, RED};
enum class Bool {TRUE, FALSE};

color c1 = color::BLUE;
color c2 = RED;
Bool flag1 = Bool::TRUE;
Bool flag2 = TRUE; //identifier "TRUE" is undefined
```

#### （2）枚举成员的值

默认情况下，枚举值是从 0 开始，依次加 1，不过我们也能为一个或多个枚举成员指定专门的值。值得注意的是，**枚举值不一定唯一**。如果我们只为部分枚举成员指定了枚举值，那么未指定的枚举成员的值是前一个成员的值加一：

``` c++
enum {
    A, B, C, D = 10, E = 10, F, G = 30, H, U = 100,
    // 0 1 2 10 10 11 30 31 100
};
```

枚举成员是 const，因此在初始化枚举成员时提供的值必须是常量表达式。这也意味着，我们可以将枚举成员用到任何需要常量表达式的地方。

#### （3）指定 enum 成员的大小（类型）

> 潜在类型：枚举成员的类型

尽管每个 enum 都定义了唯一的类型，但实际上 enum 是由某种整数类型表示的。在 C++11 新标准中，我们可以在 enum 的名字后加上冒号以及我们想在该 enum 中使用的类型：

``` c++
enum intVals : unsigned long long {
    char_max = 255,
    short_max = 65536,
    int_max = 4294967295UL,
};
```

> 在这个代码中，`int_max` 的赋值确实需要指定 `UL` 后缀，以确保值 `4294967295` 被解析为 **无符号长整数（`unsigned long`）** 类型。
>
> 虽然在大多数编译器中，`4294967295` 即使不加后缀也会被解析正确（因为 `unsigned long long` 足够大），但为了确保代码的 **可读性** 和 **移植性**，明确地添加 `UL` 后缀是个好习惯。

如果我们没有指定 enum 的潜在类型，则默认情况下：

* 限定作用于的 enum 成员类型是 int 。
* 对于不限定作用于的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能容纳枚举值。

如果我们指定了枚举成员的潜在类型，则一旦某个枚举成员的值超过了该类型所能容纳的范围，将引发程序错误。

#### （4）枚举类型的前置声明

在 C++11 中，我们可以提前声明 enum。enum 的前置声明（无论隐式地还是显式的）必须指定其成员的大小（潜在类型）：

``` C++
enum intVals : unsigned long long;
enum doubleVals;//error: use of enum ‘doubleVals’ without previous declaration
enum class open_modes;
```

由于限定作用域的枚举类型的潜在类型默认为 int，因此我们可以不显式指定其潜在类型。但未限定作用域的枚举类型由于没有潜在类型，因此我们必须显式指定。

和其它声明语句一样，enum 的声明和定义必须匹配，这意味着 enum 的所有声明和定义需要保证其大小相同。而且，我们不能声明同名的限定作用域的 enum 类型以及不限定作用于的 enum 类型：

``` C++
enum intVals : int;
enum class intVals;
// enum "intVals" (declared at line 8) was previously declared as a different kind of enum type
```

### 4. 类成员指针

**成员指针（point to number）**是指可以指向类的**非静态数据成员**的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象。类的静态数据成员不属于任何对象，因此无需特殊的指向静态成员的指针，指向静态成员的指针域普通指针没有什么区别。

**成员指针的类型囊括了类的类型和成员的类型**。<font color=blue>当初始化一个这样的指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象；**直到使用成员指针时，才提供成员所属的对象。**</font>

一般来说，成员指针的类型为 `Type ClassName::*p = &ClassNane::member;`。如果你觉得复杂，也可以直接使用 `auto`。不过在我的机器上测试，显示 auto 无法推导？？

#### （1）为什么使用成员指针时才提供成员所属的对象

正如我们前面提到过的，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何内存中的对象：

``` c++
Type ClassName::*p = &ClassNane::member;
```

这条语句在为成员指针 p 赋初值之后，它只是保存了一个“偏移量”。即，成员指针的赋值只是保存了成员在类中的“相对位置”，只有当解引用成员指针时我们才提供对象的信息。因此 C++ 中的**成员指针**并不直接指向内存地址，而是相对于类对象的一个<font color=blue>“偏移”量</font>。只有在指定了对象之后，成员指针才能通过该对象的具体地址（首地址）来定位到该对象的成员。

简而言之，不同于普通指针的直接指定内存地址来定位对象，成员指针的“内存地址定位”分为两个阶段：

1. 定位成员相对于类对象的“偏移量” offset
2. 定位类对象的起始地址 start

通过 （start+offset）即可定位某个类对象的某个成员的内存地址。

那为什么不直接通过对类对象的某个成员取地址来实现“内存地址定位”呢？这样还只需要一次取地址，更方便不是吗？例如 `&obj.val;`。

如果是这样的话，你就没搞清楚成员指针的“定位”了。**成员指针是“特定于”某个成员的**，即，如果成员指针绑定的成员是 x，那么此时即使有个成员 y 的类型和 x 相同，我们也不会使用该指针访问 y，这个成员指针就是用来访问 x 的。因此说，像上面那种绑定形式，它看起来就不是一个成员指针，而只是一个普通指针了。

将指针绑定到特定的对象还有一个好处，就是每次使用时只需要指定类对象来调用指针即可，而不必重新对指针赋值，使其指向我们要绑定的对象。因此使其用来也更为方便。

即使我们的目的不是只绑定具体的成员，对于类成员而言，使用成员指针也是一个好的选择。因为使用成员指针时，我们在初始化时就会绑定到类的成员。这样编译器就知道哪个类类型的成员将被访问，从而进行**类型检查**。确保在操作特定对象时使用正确的成员。直接通过成员地址访问的话，编译器不会进行成员归属检查，更容易导致访问非法内存。

#### （2）成员指针是类对象的指针

另外一个有意思的点就是，对于普通指针，我们是直接通过指针来操纵指针所指向的对象的。但是对于成员指针来说，从它的用法可以看出，我们需要通过类对象来调用成员指针。看上去，这个指针是类的一个“成员”一样。

``` c++
struct Foo {
    Foo(int _x = 0, int _y = 0) : x(_x), y(_y) {}
    int x;
    int y;
};

Foo a(1, 2);

int main() 
{
    int Foo::*p = &Foo::x;
    a.*p = 10; // 通过类对象a调用成员指针p来操纵p所指向的对象
    cout << a.x << endl; // 10

    int *p2 = &a.x;
    *p2 = 100; // 直接通过指针p操纵所指向的都西昂
    cout << a.x << endl;

    return 0;
}
```

由于成员指针是类对象的指针，因此成员指针还能用于多态：

``` C++
struct Foo {
    Foo(int _x = 0, int _y = 0) : x(_x), y(_y) {}
    int x;
    int y;
};

struct Bar : Foo {
    Bar(int _x = 0, int _y = 0, int _z = 0) : Foo(_x, _y), z(_z) {}
    int z;
};

Foo a(1, 2);
Bar b(1, 2, 3);
int Foo::*ptr = &Foo::x; 

int main() 
{
    cout << b.x << endl; // 1
    b.*ptr = 100;
    cout << b.x << endl; // 100

    return 0;
}
```

#### （3）数据成员指针

指定类的数据成员指针时，需要包含成员所属的类，即在 `*` 之前添加 `classname::` 以表示当前定义的指针可以指向 classname 的成员：

``` C++
struct Foo {
    Foo(int _x = 0, int _y = 0) : x(_x), y(_y) {}
    int x;
    int y;
};

Foo a(1, 2);
Foo *b = new Foo(10, 20);

int Foo::*ptr = &Foo::x; 

int main() 
{
    a.*ptr = 10;
    b->*ptr = 30;
    return 0;
}
```

与成员访问运算符 `.` 和 `->` 类似，也有两种成员指针访问运算符 `.*` 和 `->*`。无论是哪一种形式，都是限制性解引用运算符 `*`，再执行成员访问运算符。

另外就是要注意，常规的访问控制权限对成员指针同样有效：

``` C++
struct Foo {
    Foo(int _x = 0, int _y = 0) : x(_x), y(_y) {}
private:
    int x;
    int y;
};

int Foo::*ptr = &Foo::x; //member "Foo::x" (declared at line 11) is inaccessible
```

由于数据成员一般情况下是私有的，所以我们通常不能直接获取数据成员的指针。常规的做法是定义一个函数，令其返回值是指向该成员的指针，然后我们就能通过该指针访问数据成员了。

``` C++
struct Foo {
    Foo(int _x = 0, int _y = 0) : x(_x), y(_y) {}
    int getx() const {return x;}
    static int Foo::* getPtrX() {return &Foo::x;}
private:
    int x;
    int y;
};

static int Foo::* getPtrX();

Foo a(1, 2);
Foo *b = new Foo(10, 20);

int Foo::*ptr = Foo::getPtrX();

int main() 
{
    a.*ptr = 10; 
    b->*ptr = 30;
    cout << a.getx() << endl; // 10
    cout << b->getx() << endl; // 30
    return 0;
}
```

不过我们可以发现，从函数返回指向类的数据成员的指针的方法似乎破坏了类的“封装”特性。`a.*ptr = 10;` 直接改变了类的私有成员的值。因此这里要格外小心！

#### （4）成员函数指针

我们也可以定义指向类的成员函数的指针：

``` C++
struct Foo {
    Foo(int _x = 0) : x(_x) {}
    int get() const { return x; }
    void set(int _x) {x= _x;}
public:
    int x;
};

Foo a(1);
Foo *b = new Foo(100);

// const放在参数列表的后面
int (Foo::*fptr1)() const = &Foo::get;
auto fptr2 = &Foo::get;

int main() 
{
    cout << (a.get)() << endl;
    cout << (a.*fptr1)() << endl;
    cout << (b->*fptr2)() << endl;
    return 0;
}
```

其实成员函数指针的类型并不复杂，按步骤走即可：

1. 函数类型为 `int get() const;` 注意别忘了 const 和引用限定符。
2. 将函数名替换为指针名 `int (*fptr)() const;`
3. 由于是成员函数指针，还需要添加类限定符：`int (Foo::*ptr) const;`

当然，更简单的方法是直接使用 auto😀，但是如果该函数有多个重载版本，就不能使用 auto，此时必须显示指定函数类型 😭。

另外就是，注意成员函数的调用形式，对于 `a.f()`，它相当于 `(a.f)()` 而不是 `a.(f())` 。即，先通过成员访问运算符获得 a 的成员 f，发现它是一个函数，然后通过成员访问运算符 `()` 传递参数。

当我们通过成员函数指针调用函数时，必须将 `a.*fpre1` 用括号括起来，否则对于 `a.*fptr1()` ，它会被解释为 `a.*(fptr1())`。因为函数调用运算符的优先级高于指针解引用运算符的优先级。

##### 4.1 成员指针的类型别名

从上面可见，指定成员函数指针的类型很麻烦，使用 typedef 或 using 来指定类型别名可以让成员函数指针更好理解：

``` C++
struct Foo {
    Foo(int _x = 0) : x(_x) {}
    int get() const { return x; }
    int get(int offset) const { return x + offset; } 
    void set(int _x) {x= _x;}
public:
    int x;
};

Foo a(1);
Foo *b = new Foo(100);

using FooGet = int(Foo::*)() const;
FooGet Fget = &Foo::get;

int main() 
{
    cout << (a.*Fget)() << endl;
    return 0;
}
```

##### 4.2 成员指针函数表

对于普通函数指针和指向成员函数的指针来说，一种常见的用法是将其存入一个函数表当中。如果一个类含有几个类型相同的成员，则这样一张函数表可以帮助我们从这些成员中选择一个。现在我们有一个光标类，它保存了光标的坐标，并且可以通过调用成员函数改变光标的位置：

``` c++
class Cursor {
public:
    Cursor& left(int d = 1);
    Cursor& right(int d = 1);
    Cursor& up(int d = 1);
    Cursor& down(int d = 1);

    int getX() const {return x;}
    int gety() const {return y;}

    void setX(int _x, int _y) {x = _x, y = _y;}

private:
    int x, y;
};
```

其中，`left`、`right`、`up` 和 `down` 这几个函数的类型完全相同。我们希望定义一个 `move` 函数，使其可以调用上面四个函数中的任意一个并执行相应的操作。我们可以在 Cursor 中添加一个静态成员，它是一个指向光标移动函数的指针的数组。另外我们也可以添加一个枚举用来方便的表示和调用我们当前使用的成员函数是哪一个：

``` c++
class Cursor {
public:
    using Motion = Cursor&(Cursor::*)(int);

    enum Direction {LEFT, RIGHT, UP, DOWN};

    Cursor() : x(0), y(0) {}
    Cursor(int _x, int _y) : x(_x), y(_y) {}

    Cursor& move(Direction mf, int d = 1) { return (this->*menu[mf])(d); }

    Cursor& left(int d = 1) { y-=d;; return *this; }
    Cursor& right(int d = 1) { y+=d; return *this; }
    Cursor& up(int d = 1) { x+=d;; return *this; }
    Cursor& down(int d = 1) { x-=d; return *this; }

    int getX() const {return x;}
    int getY() const {return y;}
    void set(int _x, int _y) { x = _x, y = _y; }

private:
    int x, y;
    static Motion menu[];
};

// 赋值的顺序要与enum的顺序一致
// 注意这里要写为 Cursor::menu
// 否则编译器会认为这只是一个普通的全局变量
Cursor::Motion Cursor::menu[] = {
    &Cursor::left, 
    &Cursor::right, 
    &Cursor::up, 
    &Cursor::down,
};

ostream& operator<<(ostream &os, const Cursor &c)
{
    return os << "(" << c.getX() << "," << c.getY() << ")";
} 

int main() 
{
    Cursor c(1, 2);
    cout << c << endl;
    cout << c.move(Cursor::DOWN, 3) << endl;
    cout << c.move(Cursor::RIGHT, 2) << endl;
    cout << c.move(Cursor::LEFT, 1) << endl;
    cout << c.move(Cursor::UP, 2) << endl;

    return 0;
}
```

##### 4.3 成员函数与类模板

当涉及模板时，使用 using 来定义别名比 typedef 更简单。

``` c++
template<typename T>
struct Less {
    bool operator()(T a, T b) {
        return a < b;
    }
};

template<typename T>
using fptr = bool (Less<T>::*)(T,T);

int a = 10, b = 20;
Less<int> obj;

int main()
{
    fptr<int> cmp = &Less<int>::operator();
    cout << (obj.*cmp)(a, b) << endl;
    return 0;
}
```

##### 4.4 成员函数与函数模板

``` C++
template<typename T, typename Func>
bool cmp(T a, T b, Func func)
{
    return func(a, b);
}
struct Less {
    template<typename T>
    bool operator()(T a, T b) {
        return a < b;
    }
};

template<typename T>
using fptr = bool (Less::*)(T,T);

int main()
{
    int a = 10, b = 20;
    Less obj;
    fptr<int> cmp = &Less::operator();
    cout << (obj.*cmp)(a, b) << endl;
    return 0;
}
```

#### （5）将成员函数用作可调用对象

如我们所知，想要通过一个指向成员函数的指针进行函数调用，必须首先调用 `.*` 或 `->*` 运算符将该指针绑定到特定的对象上。因此与普通的指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符。

由于成员指针不是可调用对象，所以我们不能直接将一个指向成员函数的指针传递给算法。以下是解决该问题的一些方法，用到的设施都在 `function` 头文件中，可以将一个成员函数指针转换为可调用对象。

要注意，即使将成员函数指针转换为一个可调用对象，也依然要通过实例化对象来调用可调用对象。就比如 string 类的成员函数生成的可调用对象，我们显然不能将这个可调用对象放在有关 int 的场景中，因为 int 的实例化对象无法调用  string 的成员函数。

##### 5.1 mem\_fn 

> Function template `std::mem_fn` generates **wrapper objects** for pointers to members, which can store, copy, and invoke a [pointer to member](https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_members). Both references and pointers (including smart pointers) to an object can be used when invoking a `std::mem_fn`.

标准库设施 mem\_fn 可以让编译器负责推断成员的类型，从而可以从成员指针生成一个可调用对象。其本质上是根据成员函数指针生成一个**仿函数**。

``` C++
vector<string> s = {"hello", "", "world"};

auto it = find_if(s.begin(), s.end(), mem_fn(&string::empty));
cout << it - s.begin() << endl;        // 1

auto f1 = mem_fn(&string::empty);
cout << f1(s[0]) << endl;             // 0
cout << f1(std::move(s[0])) << endl;  // 0

auto f2 = mem_fn(&vector<string>::size);
cout << f2(&s) << endl;               // 3 
```

##### 5.2 bind

bind 相较于 mem_fn 的一个好处就是，bind 可以为成员函数绑定参数，以及使用占位符，因此更加灵活。

``` C++
vector<string> s = {"hello", "", "world"};

auto it = find_if(s.begin(), s.end(), bind(&string::empty, _1));
cout << it - s.begin() << endl;   // 1

auto f1 = bind(&string::empty, _1);
cout << f1(s[0]) << endl;         // 0
cout << f2(std::move(s)) << endl; // 3

auto f2 = bind(&vector<string>::size, _1);
cout << f2(&s) << endl;           // 3 
```

事实上，我们可以发现，bind 生成的可调用对象既可以接受**引用参数**，也可以接受**指针参数**。这是因为 bind 生成的可调用对象含有重载的函数调用运算符：一个接受指针，另一个接受引用（既可以接受左值引用，也可以接受右值引用）。mem_fn 也是同理。

##### 5.3 使用 function 包装成员函数指针

``` C++
vector<string> s = {"hello", "", "world"};

// 接受一个左值引用（也可以接受右值引用）
function<bool(const string&)> str_empty = &string::empty;
auto it = find_if(s.begin(), s.end(), str_empty);
cout << it - s.begin() << endl; // 1

// 接受一个指针
function<size_t(const vector<string>*)> vec_size = &vector<string>::size;
cout << vec_size(&s) << endl;  // 3
```

不同于 mem_fn 和 bind，function 包装的成员函数所接受的参数的类型被我们指定好了，因此我们只能传入与参数匹配的类型。

另外我们可以发现，我们没有传入隐式地 `this` 指针。通常情况下，执行成员函数的对象将被隐式地传递给隐式的 `this` 指针。

### 5. 嵌套类

一个类可以定义在另一个类的内部，前者称为嵌套类（nested class）或嵌套类型（nested type）。嵌套类常用于定义作为**实现部分**的类。

#### （1）嵌套类和外层类的关系

<font color=blue>嵌套类是一个**独立**的类，与外层类基本没什么关系。</font>特别是，<font color=blue>外层类的对象和嵌套类的对象是相互独立的。</font>在嵌套类的对象中不包含任何外层类定义的成员；类似的，在外层类的对象中也不包含任何嵌套类定义的成员。

嵌套类中成员的种类和非嵌套类是一样的。和其他类类似，嵌套类也使用访问限定符来控制外界对其成员的访问权限。外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限。

<font color=blue>不过，嵌套类可以直接使用外层类的**类型名称**、**静态成员**和**枚举常量**。如要使用其它成员的名称，需要使用指针、引用或对象名。</font>

嵌套类就是外层类中定义的一个<font color=blue>**类型成员**</font>。和其他类型成员类似，该类型成员的访问权限由访问限定符 `public`、`protected` 和 `private` 限定。也因此，嵌套类的名字在外层类作用域中是可见的，在外层类作用于之外不可见。和其它嵌套的名字一样，嵌套类的名字不会和别的作用域中的同一个名字冲突。

#### （2）嵌套类的名字查找

嵌套类的名字查找和普通类并无区别，只是在查找时需要先查找外层类，再查找全局作用域：

``` C++
int val = 100;

struct Foo {
    typedef long long LL;
    static const int val = 10;
    struct Bar {
        void print() {
            cout << val << endl;
        }
    };

};

int main()
{
    Foo::Bar f;
    f.print(); // 10
    return 0;
}
```

#### （3）嵌套类在类外的定义

``` C++
struct Foo {
    typedef int size_type;
    struct Bar {
        Bar() = default;
        Bar(size_type _num);
        size_type get() const;
        void set(size_type x);
        static size_type MAX;
    private:
        size_type num;
    };
};

Foo::Bar::Bar(size_type _num) : num(_num) {}
Foo::size_type Foo::Bar::MAX = 1024;
Foo::size_type Foo::Bar::get() const {return num;}  
void Foo::Bar::set(size_type x){num = x;}

int main()
{
    Foo::Bar f;
    f.set(10);
    cout << f.get() << endl;
    return 0;
}
```

### 6. union：一种节省空间的类

union 是一个特殊的类。一个 union 可以有多个数据成员，但是在任意时刻就只有一个数据成员可以有值。<font color=blue>当我们给 union 的一个成员赋值之后，其他成员就变成**未定义**的状态了。</font>分配给一个 union 对象的存储空间至少要容纳它的最大的数据成员。和其他类一样，一个 union 定义了一种新类型。

类的某些特性对 union 同样适用，但并非所有特性都如此。**union 不能含有引用类型的成员**，除此之外，它的成员可以是多大多数类型。在 C++11 新标准中，含有构造函数或析构函数的类类型也可以作为 union 的成员类型。union 可以为其成员指定 public、protected 和 private 等保护标记，**默认情况下，union 的成员都是公有的。**

union 既不能继承自其他类，也不能作为基类使用，所以在 union 中不能含有虚函数。

#### （1）使用 union

如果我们为 union 提供了初始值，则该初始值被用于初始化第一个成员。为 union 的一个数据成员赋值会令其它数据成员变成未定义的状态。

#### （2）匿名 union

一旦我们定义了一个匿名 union，编译器就自动的为该 union 创建一个未命名的对象。在匿名 union 的定义所在的作用域内该 union 的成员都是可以直接访问的：

``` C++
union {
    char cval;
    int ival;
    double dval;
};
ival = 0x12345678;
cout << hex << showbase << uppercase << ival << endl;
```

匿名 union 不能包含受保护的成员或私有成员，也不能定义成员函数。

#### （3）union 的原理

我们前面一直说，为 union 的一个数据成员赋值会导致其它数据成员的值处于未定义状态，为什么呢？

这是因为 union 的成员变量共享“一块”内存空间，所有成员的修改都在这块内存空间上进行。

例如 union 可能包含一个 char（一字节）对象， 一个 int（四字节）对象，那么这个 union 的内存空间可能就是 4B，而 char 只使用 1 B。如果我们修改了 char 对象的值，那么 char 就会直接在这块内存上修改一个字节的数据，这就会导致 int 的 4B 其中一个字节的值被修改了。对于这种类型比较简单的情况，我们是可以推算出其它变量值的变化的：

``` C++
union {
    char cval;
    int ival;
};
cout << hex << showbase << uppercase;
ival = 0x12345678;
cout << ival << endl; // 0X12345678
cval = 0xaf;
cout << ival << endl; // 0X123456AF
```

> 从这个例子上来看，char 修改了 int 对象的低位值，这说明我们的电脑是“小端存储方式”，即低位的数据存放在低地址。

但是对于像包含类类型，递归 union 等情况，问题就复杂的多了，我们就很难去推断其他值的变化了。

#### （4）含有类类型成员的 union

在 C++ 早期版本中，在 union 中不能含有定义了构造函数和拷贝控制成员的类类型成员。 C++11 新标准取消了这一限制。不过，如果 union 的成员类型定义了自己的构造函数和/或拷贝控制成员，则该 union 的用法要比只含有内置类型成员的 union 复杂的多。

##### 默认构造函数和拷贝控制成员

当 union 包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员。但是如果 union 含有类类型的成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器将为 union 合成对应的版本并将其声明为**删除**的。例如，string类定义了五个拷贝控制成员以及一个默认构造函数。如果union 含有 string  类型的成员，并且没有自定义默认构造函数或某个拷贝控制成员，则编译器将合成缺少的成员并将其声明成删除的。如果在某个类中含有一个union 成员，而且该 union 含有删除的拷贝控制成员，则该类与之对应的拷贝控制操作也将是删除的。

``` c++
union MyUnion {
    int ival;
    string sval;
};
MyUnion u;//[error]the default constructor of "MyUnion" cannot be referenced -- it is a deleted function
```

##### 必须手动调用构造函数和析构函数

当 union 包含的是内置类型的成员时，我们可以使用普通的赋值语句改变union 保存的值。但是对于含有特殊类类型成员的 union 就没这么简单了。如果我们想将 union 的值改为类类型成员对应的值，或者将类类型成员的值改为一个其他值，则必须分别构造或析构该类类型的成员：

* 当我们将 union 的值改为类类型成员对应的值时，必须运行该类型的构造函数；
* 反之，当我们将类类型成员的值改为一个其他值时，必须运行该类型的析构函数。

<font color=blue>这是因为类类型通常会管理资源（如动态分配的内存、文件句柄等），而 `union` 只允许一个成员同时存在，并且它**不会自动销毁“不存在”的成员**，因此如果不小心管理这些资源，可能会导致资源泄漏或未定义行为。</font>

例如，当你为一个 `union` 成员赋值时，如果该成员是一个类类型（比如 `std::string`），编译器不能自动处理它的构造或析构，因为 `union` 并没有为每个成员单独分配构造或析构过程。所以你需要手动处理这些细节。你可以使用 `placement new` 来手动调用构造函数，同时确保调用析构函数。

``` C++
union MyUnion {
    MyUnion() {}
    ~MyUnion() {}
    int ival;
    string sval;
};
MyUnion u;
new(&u.sval) string("hello,world");
cout << u.sval << endl;//hello,world
u.sval.~string();
u.ival = 42;
cout << u.ival << endl;//42
```

#### （5）使用类管理 union

通过上面也可以看出，对于 union 来说，想要构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把含有类类型成员的 union 内嵌在一个类当中。这个类可以管理并控制与 union 的类类型成员有关的类型转换。

为了追踪 union 中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象称为 union 的**判别式（discriminant）**。我们可以使用判别式辨别 union 存储的值。为了保持 union 与其判别式同步，我们将判别式也作为类的成员。通常我们使用枚举类型来实现 union 的判别式。

``` c++
class Token {
public:
    Token() : tok(INT), ival(0) {}
    Token(const Token &t) : tok(t.tok) { copyUnion(t); }
    // Token(Token &&t);
    Token& operator=(const Token&);
    // Token& operator=(Token&&);
    ~Token() { if(tok == STR)  sval.~string(); }
    Token& operator=(const string&);
    Token& operator=(char);
    Token& operator=(int);
    Token& operator=(double);
private:
    enum {INT, CHAR, DBL, STR} tok; // 判别式
    union {
        char   cval;
        int    ival;
        double dval;
        string sval;
    };
    void copyUnion(const Token&);
};

Token& Token::operator=(int i)
{
    if(tok == STR)  sval.~string();
    ival = i;
    tok = INT;
    return *this;
}

Token& Token::operator=(char c)
{
    if(tok == STR)  sval.~string();
    cval = c;
    tok = CHAR;
    return *this;
}

Token& Token::operator=(double d)
{
    if(tok == STR)  sval.~string();
    dval = d;
    tok = DBL;
    return *this;
}

Token& Token::operator=(const string &s)
{
    if(tok == STR)  sval = s;
    else {
        new(&sval) string(s);
        tok = STR;
    }
    return *this;
}

Token& Token::operator=(int i)
{
    if(tok == STR)  sval.~string();
    ival = i;
    tok = INT;
    return *this;
}

void Token::copyUnion(const Token& t)
{
    switch(t.tok) {
        case INT: ival = t.ival; break;
        case CHAR: cval = t.cval; break;
        case DBL: dval = t.dval; break;
        case STR: new(&sval) string(t.sval); break;
    }
}

Token& Token::operator=(const Token& t)
{
    if(tok == STR && t.tok != STR) sval.~string();
    if(tok == STR && t.tok == STR) sval = t.sval;
    else copyUnion(t);
    tok = t.tok;
    return *this;
}
```

### 7. 局部类

类可以**定义在某个函数的内部**，我们称这样的类为局部类。**局部类定义的类型只在定义它的作用域内可**见。和嵌套类不同，局部类的成员受到严格限制。

> <font color=blue>局部类的所有成员（包括函数在内）都必须完整定义在类的内部。</font>因此，局部类的作用域与嵌套类相比相差很远。

在实际编程过程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的复杂性不可能太高。类似的，在局部类中也不允许声明静态数据成员，因为我们无法定义这样的成员。

#### （1）局部类不能使用函数作用域中的名字

局部类对其外层作用域中名字的访问权限受到很多限制，局部类只能访问外层作用域定义的**类型名**、静态变量以及**枚举类型**。如果局部类定义在某个函数内部，则该函数的普通局部变量不能被该局部类使用。

``` c++
int a = 10, b = 20;
int val = 100;
void localfunc(int val)
{
    static int sval = 30;
    enum color {RED, BLUE};
    struct Foo {
        color c;
        int fooVal;
        void func(color lc = RED)
        {
            // fooVal = val;   // 错误：val是一个局部变量
            fooVal = ::val; // 正确：使用一个全局对象
            fooVal = sval;  // 正确：使用一个静态局部变量
            lc = BLUE;      // 正确：使用一个枚举成员
        }
    };
}
```

之所以这样（不能使用外层函数的局部临时对象）是因为我们可以通过动态内存分配，将一个局部类的对象摆脱外层作用域的限制。因此当函数执行结束，栈空间回收，临时对象销毁时，这个局部类的对象再去调用函数中的局部临时对象就是不合理的了。

#### （2）常规的访问保护规则对局部类同样适用

外层函数对局部类的私有成员没有任何访问特权。当然，局部类可以将外层函数声明为友元（貌似不可行？）；或者更常见的情况是局部类将其成员声明为 public。在程序中有权访问局部类的代码非常优先。局部类已经封装在函数作用域中，通过信息隐藏进一步封装就显得没什么必要了。

#### （3）名字查找

这个有点类似于嵌套类的名字查找：

1. 局部类自己的成员
2. 外层函数的静态成员、类型别名和枚举
3. 全局作用于的变量

#### （2）常规的访问规则保护对局部类同样适用

外层函数对局部类的私有成员没有任何访问特权。当然，局部类可以将外层函数声明为友元；或者更常见的情况是局部类将其成员声明成公有的。在程序中有权访问局部类的代码非常有限。局部类已经封装在函数作用域中，通过隐藏信息进一步封装显得没什么必要了。





### 8. 固有的不可移植的特性

为了支持底层编程，C++ 提供了一些固有的不可移植（nonportable）。所谓不可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上或从一个编译器转移到另一个编译器时，通常需要重新编写该程序。

#### （1）算数类型

在前面我们已经提到过，算数类型的大小在不同的机器上所占用的字节数并不一致。例如，long 在 32 位机器上是 32bit；但在 64 位机器上是 64 bit。

#### （2）位域

类可以将其（非静态）数据成员定义成位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备**传递二进制数据**时，通常会用到位域。

> 位域在内存中的布局是与机器相关的。

位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用**无符号类型**保存一个位域。位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于制定成员所占的二进制比特数：

``` C++
typedef unsigned int Bit;

class File {
    Bit mode: 2;
    Bit modified: 1;
    Bit prot_owner: 3;
    Bit prot_group: 3;
    Bit prot_world: 3;
public:
    enum modes {READ = 01, WRITE = 02, EXECUTE = 03};
    File &open(modes);
    void cloes();
    void write();
    bool isRead() const;
    void setWrite();
};
```

如果可能的话，在类的内部连续定义的位域会压缩在同一整数的相邻位，从而提供压缩存储。例如在上面的声明中，五个位域可能会压缩在同一个 unsigned int 中。这些二进制位是否能压缩到同一个整数中以及如何压缩是与机器相关的。

取地址运算符（&）不能作用域位域，因此任何指针都不能指向类的位域。

位域的使用方式和类的其他数据成员并无差别，只不过我们一般通过位运算来操纵位域：

``` c++
File& File::open(modes m)
{
    mode = m;
    return *this;
}
void File::cloes()
{
    if(modified) {
        /*. save the modified content .*/
    }
}

void File::write()
{
    modified = 1;
}

bool File::isRead() const
{
    return mode & READ;
}

void File::setWrite()
{
    mode |= WRITE;
}
```

总而言之，由于以下原因，位域是不可移植的：

1. **字节对齐和填充**：

   不同的编译器和平台可能会对位域的对齐和填充方式有所不同。例如，某些编译器可能会在位域之间插入额外的填充位，以确保数据结构对齐，这会导致结构的内存布局在不同平台上有所不同。

2. **位域的存储顺序**：

   位域的存储顺序（即从低位到高位还是从高位到低位）也可能因平台而异。有些系统可能是从低位开始填充（little-endian），而其他系统可能是从高位开始填充（big-endian），这会影响位域的解释。

3. **最大位域大小**：

   在 C++ 标准中，没有规定位域的最大大小，因此在不同的编译器中，位域的大小限制可能会有所不同。

#### （3）volatile限定符

##### 为什么用volatile

volatile 的确切含义与机器有关，只能通过阅读编译器文档来理解。想要让使用了 volatile 的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行某些改变。

> `volatile` 的具体实现和效果可能依赖于特定的硬件架构和编译器。例如，不同的处理器架构对内存访问和优化的策略可能不同，某些平台可能不会按照预期行为处理 `volatile`。
>
> 编译器在优化代码时可能会做出不同的选择。某些编译器在遇到 `volatile` 变量时可能会禁用特定的优化，而其他编译器可能会对此变量的访问进行更激进的优化。不同的编译器和编译选项可能会影响 `volatile` 变量的行为，导致不同的执行结果。
>
> 虽然 `volatile` 通常用于处理多线程环境中的共享变量，但它并不能提供线程安全的保证。多个线程同时访问和修改 `volatile` 变量可能导致竞态条件和不可预测的行为。为了在多线程环境中安全地共享数据，应该使用同步原语（如互斥锁）而不是依赖于 `volatile`。
>
> `volatile` 仅仅表示变量可能被外部因素修改，但并没有提供关于如何正确地访问或修改这个变量的语义。因此，不同的开发者可能会对 `volatile` 的使用产生不同的理解，从而导致代码在不同环境中的行为不一致。

C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 **memory barrier**。这是 BS 在 "The C++ Programming Language" 对 volatile 修饰词的说明：

> A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.

volatile 关键字是一种**类型修饰符**，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：**int volatile vInt;** <font color=blue>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</font>

> e.g. 直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被改变时，应该将改对象声明位 volatile。关键字 volatile 告诉编译器不应该对这样的对象进行优化。

例如：

``` c++
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```

volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i 的地址中读取，因而编译器生成的汇编代码会重新从 i 的地址读取数据放在 b 中。

而优化做法是，如果我们没有对 i 指定 violatile，那么编译器可能用一个寄存器来保存 i 的值，那么由于在 a 和 b 读取之间，在语言层面上我们并没有修改 i 的值，但此时从系统层面上这个值 i 被修改了。由于编译器看不到对 i 的修改，因此寄存器里的副本不会被修改，但编译器对 a 和 b 的处理都是直接从寄存器中去读取值，所以此时 a 和 b 的值不一致。

因此说，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。

> 编译器可能会将一些变量放在寄存器中，对该元素的读取直接访问寄存器；当该变量被“显示”修改时，同时修改寄存器中的副本。
>
> 但是如果我们的修改是“隐式”的，例如其它线程修改了这个变量，对于当前线程来说由于我们没有“显式”修改该变量的值，因此编译器不会重新读取该变量的值到寄存器中。
>
> 因此，下次再从寄存器取出这个变量的值时，读取到的是修改之前的值。

一般来说，volatile 用在如下的地方：

* 终端服务程序中修改的供其他程序检测的变量需要加 volatile
* 多任务环境下各任务间共享的标志应该加 volatile
* 存储器映射的硬件寄存器通常也需要加 volatile 说明，因为每次对它的读写都可能有不同意义

##### const和volatile

用 volatile 修饰一个对象时，它的行为和 const 几乎一摸一样。

例如，和 const 一样：

* 可以把一个非 volatile int 赋给 volatile int，但是不能把非 volatile 对象赋给一个 volatile 对象。
* 一个非 volatile 指针可以指向 volatile 对象；但一个 volatile 指针不能只想非 volatile 对象
* volatile 对于指针而言同样有顶层和底层之分

##### 多线程下的volatile

有些变量是用 volatile 关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，该关键字的作用是防止优化编译器把变量从内存装入 CPU 寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile 的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，如下：

```C++
volatile bool bStop  =  FALSE;
```

(1) 在一个线程中：

```C++
while(!bStop)  {  ...  }  
bStop = false;  
return;    
```

(2) 在另外一个线程中，要终止上面的线程循环：

```C++
bStop = true;  
while(bStop);  //等待上面的线程终止，如果bStop不使用volatile申明，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。
```

这个关键字是用来设定某个对象的存储位置在内存中，而不是寄存器中。因为一般的对象编译器可能会将其的拷贝放在寄存器中用以加快指令的执行速度，例如下段代码中：

```C++
...  
int nMyCounter = 0;  
for(; nMyCounter < 100; nMyCounter ++)  
{  
...  
}  
...
```

在此段代码中，nMyCounter 的拷贝可能存放到某个寄存器中（循环中，对 nMyCounter 的测试及操作总是对此寄存器中的值进行），但是另外又有段代码执行了这样的操作：**nMyCounter -= 1;** 这个操作中，对 nMyCounter 的改变是对内存中的 nMyCounter 进行操作，于是出现了这样一个现象：nMyCounter 的改变不同步。

##### class与volatile

一个类可以定义 const 成员一样，他也可以将成员定义成 volatile。只有 volatile 的成员函数才能被 volatile 的对象调用。

##### 合成的拷贝对volatile对象无效

const 和 volatile 的一个重要区别是我们不能使用合成的拷贝/移动构造函数以及赋值运算符初始化 volatile 对象或从 volatile 对象赋值。因为合成的成员接受的是（const &obj）非 volatile 引用，显然我们不能把一个非 volatile 的引用绑定到一个 volatile 对象上。

如果一个类希望拷贝、移动或构造它的 volatile 对象，则该类必须自定义这些操。具体的，便是将星灿类型指定为 const volatile 引用。

#### （4）链接指示：extern “C”

C++ 语言有时需要调用其他语言编写的函数，最常见的是调用 C 语言编写的函数。像其他所有名字一样，其他语言中的函数名字也必须在 C++ 中声明，并且该声明必须制定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查函数调用的方式与普通 C++ 函数的方式相同，但是生成的代码有所区别。C++ 使用链接指示指出非 C++ 函数所用的语言。

> 要想把 C++ 代码和其他语言编写的代码放在一起使用，我们必须有权访问该语言的编译器，并且这个编译器与当前的 C++ 编译器是兼容的。

除了 C，我们还可以调用 FORTRAN 等语言的函数。

##### 链接指示形式

链接指示有两种形式：单个的或复合的。链接指示不能出现在函数或类的内部。链接指示必须出现在每个非 C++ 函数的声明处。

``` C++
// 单个的
extern "C" size_t strlen(const char *);
// 复合的
extern "C" {
    int strcmp(const char*, const char *);
    char *strcat(char *, const char *);
}
```

##### 链接指示与头文件

C++ 符合声明的形式和一应用于整个头文件，例如 C++ 的 cstring 头文件可能形如：

``` C++
extern "C" {
    #include <string.h>
}

// '#' not expected hereC/C++(10)
// extern "C" #include <string.h>
```

当一个 #include 指示被放置在复合链接指示的花括号中，头文件中的所有普通函数声明都被认为是由该链接所指示的语言编写的。**链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。**

##### 指向 extern “C” 函数的指针

编写函数所用的语言也是函数类型的一部分。这意味着：

* 对于使用链接指示的函数来说，它的每个声明都必须使用链接指示而且链接指示必须相同
* 如果我们通过链接指示声明了一个函数指针，那么该函数指针只能指向相同链接指示的函数
* C++ 中声明的函数指针不能指向 extern “C” 声明的函数

##### 链接指示对整个声明都有效

当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效：

``` C++
// fp是一个函数指针，它的形参是一个函数指针
extern "C" void (*fp)(void (*)(int));
```

对于 fp 来说，fp 必须指向 extern “C” 的函数，它的参数也必须是指向 extern “C” 的函数指针。

因为链接指示作用域声明语句的所有函数（以及函数指针），所以如果我们希望给 C++ 函数传入一个指向 C 函数的指针，则必须使用类型别名：

``` C++
extern "C" typedef void FC(int);
void f2(FC *);
```

##### 导出 C++ 函数到其他语言

通过使用链接指示对函数进行定义，我们可以令一个 C++ 函数在其他语言编写的函数程序中可用：

``` C++
// calc函数可以被C程序使用
extern "C" double calc(double dparm);
```

编译器将为该函数生成适用于制定语言的代码。

##### extern “C”应用

extern “C” 的应用常见于对源文件的编译，例如对于 C 语言中的库函数 `int strcmp(const char*,const char*);` 如果作为 C 程序编译，无需做特殊处理，但作为 C++ 程序编译时，需要加上 `extern "C"`。为了方便地在 C/C++ 程序中编译，我们一般这样实现：

``` C++
// 在编译C++版本的程序时，会预定义 __cplusplus
#ifdef __cplusplus
extern "C"
#endif 
int strcmp(const char*,const char*);
```

事实上，在 C++ STL 库中到处都是这种使用。

##### 重载函数和链接指示

链接指示和重载函数的相互作用依赖于目标语言。例如：

* 对于 C 语言来说，它不支持函数重载，那么下面的代码是错误的：

``` C++
extern "C" int cmp(int a, int b);
extern "C" int cmp(double a, double b);

/*==========================================*/

main.cpp:7:16: error: conflicting declaration of C function 'int cmp(double, double)'
    7 | extern "C" int cmp(double a, double b);
      |                ^~~
main.cpp:6:16: note: previous declaration 'int cmp(int, int)'
    6 | extern "C" int cmp(int a, int b);
```

* 而对于 C++ 来说，他支持函数重载，那么下面的代码是错误的：

``` C++
extern int cmp(int a, int b);
extern int cmp(double a, double b);
```

##### 为什么需要链接指示

以 C 语言为例，既然 C++ 是 C 的超集，那么 C++ 应该囊括了 C 所有的语言特性，那为什么 C++ 不可以直接使用 C 中的代码呢？

以函数名为例，C++ 由于支持函数重载，会重整函数的名字；而 C 语言不支持函数重载，它没有这样的操作。因此对于返回类型和形参完全相同的 C 和 C++ 函数来说，它们的函数名实际上是不同的。

##### 不可移植

**编译器支持**：并不是所有编译器都完全支持 C 和 C++ 的链接特性。有些编译器可能在实现 `extern "C"` 时存在差异，导致不兼容。

**不同的 ABI（应用二进制接口）**：不同平台和编译器的 ABI 可能不同。这可能会导致使用 `extern "C"` 的代码在不同的环境中表现不同，尤其是当涉及到数据结构、调用约定和返回值处理时。例如：

1. **数据结构的布局**：
   - 不同 ABI 可能对数据结构的内存布局（如对齐方式和填充）有不同的规定。这意味着在一个平台上定义的结构体在另一个平台上可能具有不同的内存布局，从而导致数据解释错误。比如，在一个平台上，某个结构体的字段可能按照特定顺序排列，而在另一个平台上，顺序可能会不同。
2. **调用约定的差异**：
   - 不同的 ABI 可能使用不同的调用约定，这包括参数的传递方式、返回值的处理、栈的清理等。即使两个平台都支持 `extern "C"`，如果它们的调用约定不同，C++ 代码可能无法正确调用 C 代码，或者反之。（例如，假如：C++ 参数从左到右的顺序入栈，而 C 以从右到左的顺序入栈。）
3. **数据类型的大小和对齐**：
   - 不同平台对数据类型的大小（如 `int`、`long` 等）和对齐要求可能不同。例如，某些平台上 `long` 可能是 32 位，而在另一些平台上可能是 64 位。这会导致在 C/C++ 代码之间传递数据时产生错误，特别是在使用 `extern "C"` 进行函数调用时。
4. **异常处理和返回值**：
   - C++ 的异常处理机制与 C 不同。虽然 `extern "C"` 可以用于使 C++ 函数可被 C 调用，但如果 C++ 函数抛出异常并被 C 代码调用，可能会导致不可预测的行为，尤其是当 ABI 不兼容时。
5. **链接和符号解析**：
   - 不同的 ABI 可能影响链接器如何处理符号。比如，某些 ABI 可能会对符号名称进行不同的修饰或处理，这可能导致链接错误或运行时错误。
6. **平台特定的特性**：
   - 某些平台可能实现了特定的 ABI 优化或功能，这些特性在其他平台上可能不存在。这会导致基于某一平台的代码在其他平台上无法正常工作。

















































































































































# C++ OOP

## 1. complex design

在class内定义的函数自动inline（inline只是对编译器的一种建议）

ctor的返回类型肯定是该class对象，所以无需写返回值

initialization list

overloading，overwrite

关于const的重载（const参数，const函数）

在单例模式中会把ctor设置为private

const对象只能调用const版本，non-const对象可以调用const和non-const版本

相同class的各个object互为友元

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数，因此在类中定义友元函数时，访问权限实质上并不对友元函数构成任何约束关系（但一般将其声明为private）

C++操作符就是个函数

所有成员函数都有一个隐藏的参数（this指针，指向调用的类对象）

引用相较于指针的一个好处就是传送者只需要传值（无需特殊符号），而无需考虑接受者是否以引用形式接收

typename()：创建临时对象，例如int()

运算符重载，根据是否需要用到this指针来决定放到全局还是class内，例如当我们执行 `cout << 1 << endl;` 时，意为通过`cout`对象调用`operator<<`，并传入参数`1`，因此说，重载输入输出运算符时，用不到输出对象的this指针，因此不能将其声明为类的成员函数，一般是声明为类的友元函数。

为什么重载输出运算符要返回引用？首先，通过返回引用可以在链式调用时避免临时对象的创建和销毁。其次，在C++中，设计重载运算符时，一个重要的原则就是尽量使自定义类型的行为与内置类型的行为一致。这样不仅使自定义类型的使用更自然，而且能够更好地融入C++语言的生态，提升语言的表达能力。返回引用正是遵循了这一原则。例如，内置类型的赋值操作返回的就是赋值后变量的引用，这使得连续赋值成为可能。通过使自定义类型的赋值运算符重载也返回引用，可以模仿这一行为，让自定义类型在使用时更加符合人们的直觉。例如，`(x=y)=z;`这条语句，在C++内置的int类型中，最后`x=z`，即`x=y`返回了`x`的引用，如果返回的是`x`的值，那么最后结果为`x=y`。

重载operator+时需要考虑隐式类型转换，例如我们封装了一个整数类型对象，如果我们将operator+声明为类的成员函数，那么`1+obj`似乎就不合法，因为整数1的operator+并没有针对obj的重载。因此此时将obj的operator+声明为友元函数更好。

## 2. string design

BigThree：拷贝构造，拷贝赋值，析构。当类中有指针时，需要重写这三个成员函数。

字符串长度的两种设计思路：`\0`结束符或者没有结束符但有一个整数表示长度。

检测self assignment。

----

ctor和dtor的行为如下：

``` C++
Complex *pc = new Complex(1, 2);
------------------------------>compile transfer
Complex *pc;
void *mem = operator new(sizeof(Complex));//分配内存
pc = static_cast<Complex*>(mem);//转型
pc->Complex::Complex(1, 2);//构造函数

delete pc;
------------------------------>compile transfer
Complex::~Complex(pc);//调用析构函数
operator delete(pc);//释放内存
```

 最后，要注意，我们不能显示直接调用ctor，这是标准所规定的，`Because constructors do not have names, they are never found during name lookup;`

----

内存块规定大小的一个好处：例如我们规定，内存块必须是16byte的倍数，那么二进制下，有4个bit是用不到的，这4个bit就可以另作他用，例如使用一个bit来标记这个内存块是否被使用。

如果我们不使用array delete去删除array new分配的内存，在我的电脑上测试，只会delete掉array[0]，说明此时delete会释放掉一些内存。

## 3. static

静态数据：与对象脱离，单独存放在内存中的一个区域，并且只有一份，注意在class中对于静态数据仅仅只是声明（如果是const则可以直接定义），对非静态数据成员是既声明又定义，因此在class外还需要对静态数据进行定义（分配内存）。另外就是这个定义必须是全局的而不是局部的，也即不能在函数中定义静态数据。（？？？）

静态函数：主要特征是没有this指针，因此用来处理静态数据，静态函数也可以被类实例以成员函数的形式调用。

分配内存的叫定义，声明只是说明了变量的数据类型和属性。

## 4. class relationship

composition表示has-a关系，关系双方的生命周期是同步的

delegation`/`composition by reference(pointer)`/`handler&body`/`pointer-to-implentation(pImpl)关系双方的生命周期不同步，因为指针可能没有指向一个对象。委托的好处是，通过指针指向不同的实现类对象，可以在不改变当前类的前提下实现不同的行为

inheritance表示is-a关系

## 5. convert function

转换函数没有return type，因为返回类型一定是你要转换的那个类型，并且一般要加上const

## 6. non-explicit-one-argument-function

小心隐式类型转换

## 7. pointer-like class

* 智能指针
* 迭代器

`->` 符号会传递（人为规定的，就是为了方便重载`->`）

`operator->`返回指针，``->``会传递

`operator*`返回引用

## 8. function-like class

所谓仿函数（functors）

## 9. template

成员模板，常用于处理派生，类型转换

模板特化，模板偏特化(个数/范围.e.g指针)

模板模板参数

注意标准库的容器一般有多个模板参数

## 10. standard library

container，algorithm，iterator，functors

## 11. varadic templates

注意`...`的位置

``` c++
void print() {}

template<typename T, typename... Types>
void print(const T& firstArg, const Types&... args)
{
    cout << firstArg << endl;
    print(args...);
    cout << "count of rest:" << sizeof...(args) << endl;
}

int main()
{
    print(__cplusplus, 1, 3.14, complex(1, 2));
    return 0;
}
```

## 12. ranged-base for

需要注意尽量使用传引用，引用相当于别名，且不可更改，java中所有对象都是reference

## 13. object model

子类对父类虚函数继承的仅仅只是使用权（地址，知道了函数的地址便可以使用函数），函数本身在内存中只有一份。

## 14. dynamic binding

指针+向上转型+虚函数

## 15. placement operator new/delete

我们虽然可以重载 member placement operator delete，但它们绝不会被delete调用。只有当new所调用的ctor抛出exception，才会调用这些重载版本的operator delete，主要用来归还未能完全创建成功的对象所占用的memory（理论上？）。

# C++ 11

## 1. variadic template

variadic: variable parament number and variable type which can be different

通过可变参数+递归实现一些操作

* 泛化和特化？

* hash？

* tuple？





## 2. nullptr

避免了C中NULL定义为0，而0是个整数类型的问题，nullptr的类型是`std::nullptr_t`

## 3. uniform initialization

为了解决C++之前初始化混乱（赋值号，小括号`parentheses`，大括号`braces`）的问题，C++11统一使用大括号来初始化。

``` C++
vector<int> vec{1, 2, 3};
int values[] {1, 2, 3};
```

例如上面的初始化就没有使用到小括号和赋值号 

大括号初始化的实质就是将 `{}` 里面的内容转化为一个 `initializer_list<T>` 来实现的，其内部是一个 `array<T,n>`，如果接收参数也是 `initializer_list<T>`，直接传过去，否则逐个分解在传过去。

如果使用`{}`进行初始化，则不能`narrowing convert`,由此可见统一初始化比较严格。

现在标准库中绝大多数算法和容器都能接受`initializer_list<T>`

## 4. explicit

* explicit for ctor taking one argument
* explicit for ctor taking more than one argument(暂时不知道有啥用)

无论是内置类型还是类类型，都支持这 4 种形式的初始化：

```cpp
int i1=0;   // (1)
int i2={0}; // (2)
int i3{0};  // (3)
int i4(0);  // (4)

std::string s1="hello";   // (1)
std::string s2={"hello"}; // (2)
std::string s3{"hello"};  // (3)
std::string s4("hello");  // (4)
```

C++ 通常会对 (2)(3) 两种形式做相同的处理，除了以下几种特殊情况：

- (2)不可用于构造函数初始值列表，而(3)可以
- 使用 auto 自动推导类型时，(2)(3)两种形式推导的结果不同：
  - auto i2 = {0}; // (2) i2 类型推导为 std::initializer_list
  - auto i3 {0}; // (3) i3 类型推导为 int
  - auto m2 = {0,1}; // (2) m2 类型推导为 std::initializer_list
  - auto m3 {0,1}; // (3) error: initializer for variable 'm3' with type 'auto' contains multiple expressions
- 对于不可拷贝对象（如 thread、atomic），(2)(3)结果不同
  - thread t2={f}; // error: chosen constructor is explicit in copy-initialization
  - thread t3{f}; // ok

## 5. alias template

## 6. template template argument

## 7. noexcept

move function注意不要抛出异常，否则容器（e.g. vector）不会调用

## 8. override,final

用于告诉编译器来帮你检查语法是否正确

final既可用于修斯class继承，也可用于修饰函数覆写

## 9. decltype

define a type equivalent to the type of an expresstion

1. declare return type
2. metaprogramming  
3. pass the type of a lambda: the type of lambda may be difficult to define

> 容器的比较函数传过去的应该是type

## 10. lambda

lambda **allowing** the definition of inline funtionality

``` c++
// 格式
auto f = [...](...)mutable throwSpec -> retType {
    ...
}
```

lambda的经典错误：

``` c++
int main()
{
    int id = 0;
    auto f = [id]() mutable {
        cout << id << endl;
        ++ id;
    };
    id = 10;
    f();
    f();
    f();
    cout << "id: " << id << endl;
    return 0;
}
```

误认为三个`f()`打印出来的值为10，11，12，其实是0，1，2。这是因为`f`看不到它后面的`id=10`，其实从lambda的本质能更好的看出：

``` c++
class Functor {
private:
    int id;
public:
    void operator()() {
        cout << id << endl;
        ++ id;
    }
};
```

当lambda创建的时候，它相当于直接把id作为他的非const数据成员了，后续对id的更改都是对它自己的那个id的更改，因此说它对外部的id无影响。

mutable的意思是，**可以在lambda中修改外部的数据，但修改之后的结果并不会同步到外部的数据。**

但如果是引用的话，后续对id的更改对lambda可见。

但要注意的是，lambda虽然神似functor，但它本质上依然不是functor？它没有默认构造函数等

## 11. non-type template parameters

例如array，他会传入一个整数表示array的大小，这就是非类型模板参数

## 12. tuple

实现tuple？

继承不会增加子类的空间

## 13. rvalue reference

rvalue can help solve the problem of unnecessary coping and enable pefect forwarding.

* lvalue: 可以出现在operator=左侧
* rvalue：只能出现在operator=右侧

you need to inform C++ that your move ctor and dtor does not throw exception.

底层实现是通过指针的浅拷贝，需要注意的是在浅拷贝之后，将原指针置为NULL，否则后续原指针所指对象生命结束时，可能把数据销毁，导致悬挂指针。

左值如何实现右值引用？`std::move()`

## 14. perfect forwarding 

perfect forwarding allows you to weite a single **function template** that takes n arbitrary arguments and forwards them transparently to another arbitrary funtion. The nature of the arguments(e.g. modifiable, const, lvalue, rvalue) is perserved in this forwarding process.

实现？		
## 15. array
数组的typedef：

``` C++
typedef int T[100]; 
T a;
```

## 16. hash
经验：当元素个数大于桶的个数，就将桶的个数扩展为原来的两倍

任意复杂类型的哈数值都可以表示为基本类型hash值的组合

# STL



## 1. Compoents

STL Components：

* container
* iterator
* allocator
* adapter
* algorithm 
* functor

STL 秉承前闭后开的理念

时间复杂度：

* constant time
* linear time
* sub-linear time
* quadratic time
* cubic time
* exponential time

> 不要盲目的觉得bsearch一定比linear search快，因为bsearch需要先sort，而sort可能很慢。

不同于OOP的data和method放在一个class中，STL中container和algorithm是分开的，这得益于中间人iterator，可以让container和algorithm的设计互不干扰

## 2. generic programming



## 3. iterator

模仿实现？

## 4. allocator

## 5. list

# 程序的前世今生







# Demo

## shared_ptr

## unique_ptr

## weak_ptr

## vector

## string

## deque

## unordered_map

## skiplist

## map 

## multimap

## red-black tree

## balance tree

## priority_queue

## stack

## queue

## bidirection Cycle List

## forward_list

## tuple

## seek

